"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  "node_modules/deep-extend/lib/deep-extend.js"(exports, module2) {
    "use strict";
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone[index] = cloneSpecificValue(item);
          } else {
            clone[index] = deepExtend({}, item);
          }
        } else {
          clone[index] = item;
        }
      });
      return clone;
    }
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    var deepExtend = module2.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] !== "object") {
        return false;
      }
      if (arguments.length < 2) {
        return arguments[0];
      }
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var val, src, clone;
      args.forEach(function(obj) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          return;
        }
        Object.keys(obj).forEach(function(key) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            return;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            return;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return;
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    };
  }
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module2) {
    "use strict";
    module2.exports = require_entities();
  }
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module2) {
    module2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module2) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode(string, exclude, keepEscaped) {
      var i, l, code, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i = 0, l = string.length; i < l; i++) {
        code = string.charCodeAt(i);
        if (keepEscaped && code === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code < 128) {
          result += cache[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    module2.exports = encode;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module2) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
        var i, l, b1, b2, b3, b4, chr, result = "";
        for (i = 0, l = seq2.length; i < l; i += 3) {
          b1 = parseInt(seq2.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq2.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    module2.exports = decode;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module2) {
    "use strict";
    module2.exports = function format(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module2) {
    "use strict";
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module2.exports = urlParse;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module2) {
    "use strict";
    module2.exports.encode = require_encode();
    module2.exports.decode = require_decode();
    module2.exports.format = require_format();
    module2.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module2) {
    module2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module2) {
    module2.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module2) {
    module2.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module2) {
    module2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class2(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class2(obj) === "[object String]";
    }
    var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty2.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match, name) {
      var code = 0;
      if (has(entities, name)) {
        return entities[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match;
    }
    function unescapeMd(str2) {
      if (str2.indexOf("\\") < 0) {
        return str2;
      }
      return str2.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str2) {
      if (str2.indexOf("\\") < 0 && str2.indexOf("&") < 0) {
        return str2;
      }
      return str2.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str2) {
      if (HTML_ESCAPE_TEST_RE.test(str2)) {
        return str2.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str2;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str2) {
      return str2.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str2) {
      str2 = str2.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str2 = str2.replace(//g, "\xDF");
      }
      return str2.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module2) {
    "use strict";
    module2.exports = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkDestination(str2, pos, max) {
      var code, level, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str2.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code = str2.charCodeAt(pos);
          if (code === 10) {
            return result;
          }
          if (code === 60) {
            return result;
          }
          if (code === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str2.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code = str2.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max) {
          if (str2.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str2.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkTitle(str2, pos, max) {
      var code, marker, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str2.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code = str2.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str2.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 40 && marker === 41) {
          return result;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max) {
          pos++;
          if (str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports, module2) {
    "use strict";
    var assign = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type2, result = "", rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type2 = tokens[i].type;
        if (typeof rules[type2] !== "undefined") {
          result += rules[type2](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        } else if (tokens[i].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i, len, type2, result = "", rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type2 = tokens[i].type;
        if (type2 === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type2] !== "undefined") {
          result += rules[tokens[i].type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    module2.exports = Renderer;
  }
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports, module2) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self = this;
      var chains = [""];
      self.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self.__cache__ = {};
      chains.forEach(function(chain) {
        self.__cache__[chain] = [];
        self.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module2.exports = Ruler;
  }
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module2) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module2.exports = function normalize(state) {
      var str2;
      str2 = state.src.replace(NEWLINES_RE, "\n");
      str2 = str2.replace(NULL_RE, "\uFFFD");
      state.src = str2;
    };
  }
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module2) {
    "use strict";
    module2.exports = function block(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module2) {
    "use strict";
    module2.exports = function inline(state) {
      var tokens = state.tokens, tok, i, l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module2) {
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    module2.exports = function linkify(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text = currentToken.content;
            links = state.md.linkify.match(text);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module2) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module2.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module2) {
    "use strict";
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str2, index, ch) {
      return str2.slice(0, index) + ch + str2.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text = token.content;
        pos = 0;
        max = text.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text.charCodeAt(t.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text = token.content;
                  max = text.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
          }
      }
    }
    module2.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/text_join.js
var require_text_join = __commonJS({
  "node_modules/markdown-it/lib/rules_core/text_join.js"(exports, module2) {
    "use strict";
    module2.exports = function text_join(state) {
      var j, l, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports, module2) {
    "use strict";
    function Token(type2, tag, nesting) {
      this.type = type2;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token.prototype.attrIndex = function attrIndex(name) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module2.exports = Token;
  }
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module2) {
    "use strict";
    var Token = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token;
    module2.exports = StateCore;
  }
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", require_text_join()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core();
    module2.exports = Core;
  }
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function getLine2(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str2) {
      var result = [], pos = 0, max = str2.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str2.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str2.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str2.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str2.charCodeAt(pos);
      }
      result.push(current + str2.substring(lastPos));
      return result;
    }
    module2.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine2(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module2) {
    "use strict";
    module2.exports = function code(state, startLine, endLine) {
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module2) {
    "use strict";
    module2.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i, l, level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module2.exports = function list(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str2, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str2.length;
      for (pos = 1; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str2, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str2, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str2.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str2.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str2.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module2) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module2.exports.HTML_TAG_RE = HTML_TAG_RE;
    module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module2) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module2.exports = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module2) {
    "use strict";
    module2.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module2) {
    "use strict";
    module2.exports = function paragraph(state, startLine) {
      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module2) {
    "use strict";
    var Token = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type2, tag, nesting) {
      var token = new Token(type2, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token;
    module2.exports = StateBlock;
  }
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module2.exports = ParserBlock;
  }
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module2) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module2.exports = function text(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/linkify.js
var require_linkify2 = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/linkify.js"(exports, module2) {
    "use strict";
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    module2.exports = function linkify(state, silent) {
      var pos, max, match, proto, link, url, fullUrl, token;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto = match[1];
      link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link)
        return false;
      url = link.url;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "linkify";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "linkify";
        token.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function newline(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module2.exports = function escape(state, silent) {
      var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module2) {
    "use strict";
    module2.exports = function backtick(state, silent) {
      var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i = 0; i < max; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module2.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i = max - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module2.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace(code) && code !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module2) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module2.exports = function autolink(state, silent) {
      var url, fullUrl, token, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module2) {
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLinkOpen(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module2.exports = function html_inline(state, silent) {
      var ch, match, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
        if (isLinkOpen(token.content))
          state.linkLevel++;
        if (isLinkClose(token.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module2) {
    "use strict";
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module2.exports = function entity(state, silent) {
      var ch, code, match, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token = state.push("text_special", "", 0);
            token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
            token.markup = match[0];
            token.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities, match[1])) {
            if (!silent) {
              token = state.push("text_special", "", 0);
              token.content = entities[match[1]];
              token.markup = match[0];
              token.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module2) {
    "use strict";
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module2.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/fragments_join.js
var require_fragments_join = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/fragments_join.js"(exports, module2) {
    "use strict";
    module2.exports = function fragments_join(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module2) {
    "use strict";
    var Token = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type2, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token(type2, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    module2.exports = StateInline;
  }
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["linkify", require_linkify2()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", require_fragments_join()]
    ];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str2, md, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str2, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module2.exports = ParserInline;
  }
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports, module2) {
    "use strict";
    module2.exports = function(opts) {
      var re = {};
      opts = opts || {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports, module2) {
    "use strict";
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class2(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class2(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class2(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class2(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class2(obj) === "[object Function]";
    }
    function escapeRE(str2) {
      return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self) {
          var tail = text.slice(pos);
          if (!self.re.http) {
            self.re.http = new RegExp(
              "^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path,
              "i"
            );
          }
          if (self.re.http.test(tail)) {
            return tail.match(self.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self) {
          var tail = text.slice(pos);
          if (!self.re.no_http) {
            self.re.no_http = new RegExp(
              "^" + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path,
              "i"
            );
          }
          if (self.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self) {
          var tail = text.slice(pos);
          if (!self.re.mailto) {
            self.re.mailto = new RegExp(
              "^" + self.re.src_email_name + "@" + self.re.src_host_strict,
              "i"
            );
          }
          if (self.re.mailto.test(tail)) {
            return tail.match(self.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self) {
      self.__index__ = -1;
      self.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self) {
        self.normalize(match);
      };
    }
    function compile(self) {
      var re = self.re = require_re()(self.__opts__);
      var tlds = self.__tlds__.slice();
      self.onCompile();
      if (!self.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self.__schemas__).forEach(function(name) {
        var val = self.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self.__compiled__[name] = compiled;
        if (isObject2(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self.__compiled__[self.__schemas__[alias]]) {
          return;
        }
        self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
        self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
      });
      self.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self.__compiled__).filter(function(name) {
        return name.length > 0 && self.__compiled__[name];
      }).map(escapeRE).join("|");
      self.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self.re.schema_at_start = RegExp("^" + self.re.schema_search.source, "i");
      self.re.pretest = RegExp(
        "(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self);
    }
    function Match(self, shift) {
      var start = self.__index__, end = self.__last_index__, text = self.__text_cache__.slice(start, end);
      this.schema = self.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self, shift) {
      var match = new Match(self, shift);
      self.__compiled__[match.schema].normalize(match, self);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema2, definition) {
      this.__schemas__[schema2] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set2(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema2, pos) {
      if (!this.__compiled__[schema2.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema2.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length)
        return null;
      var m = this.re.schema_at_start.exec(text);
      if (!m)
        return null;
      var len = this.testSchemaAt(text, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '' for Russian, '' for German,
        // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /*  */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '' for Russian, '' for German,
        // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /*  */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '' for Russian, '' for German,
        // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /*  */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = require("punycode");
    var config2 = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str2 = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str2) ? GOOD_DATA_RE.test(str2) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt(presetName, options) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt.prototype.configure = function(presets) {
      var self = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config2[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module2.exports = MarkdownIt;
  }
});

// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/markdown-it/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_lib();
  }
});

// node_modules/markdownlint-micromark/micromark.cjs
var require_micromark = __commonJS({
  "node_modules/markdownlint-micromark/micromark.cjs"(exports) {
    (() => {
      "use strict";
      var e = { d: (t2, n2) => {
        for (var r2 in n2)
          e.o(n2, r2) && !e.o(t2, r2) && Object.defineProperty(t2, r2, { enumerable: true, get: n2[r2] });
      }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      } }, t = {};
      e.r(t), e.d(t, { gfmAutolinkLiteral: () => F, gfmFootnote: () => P, gfmTable: () => G, parse: () => ct, postprocess: () => at, preprocess: () => st });
      var n = {};
      e.r(n), e.d(n, { attentionMarkers: () => ot, contentInitial: () => $e, disable: () => ut, document: () => Xe, flow: () => tt, flowInitial: () => et, insideSpan: () => it, string: () => nt, text: () => rt });
      const r = g(/[A-Za-z]/), i = g(/\d/), o = g(/[\dA-Fa-f]/), u = g(/[\dA-Za-z]/), c = g(/[!-/:-@[-`{-~]/), a = g(/[#-'*+\--9=?A-Z^-~]/);
      function l(e2) {
        return null !== e2 && (e2 < 32 || 127 === e2);
      }
      function s(e2) {
        return null !== e2 && (e2 < 0 || 32 === e2);
      }
      function f(e2) {
        return null !== e2 && e2 < -2;
      }
      function p(e2) {
        return -2 === e2 || -1 === e2 || 32 === e2;
      }
      const d = g(/\s/), m = g(/[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/);
      function g(e2) {
        return function(t2) {
          return null !== t2 && e2.test(String.fromCharCode(t2));
        };
      }
      const h = { tokenize: function(e2, t2, n2) {
        return function(t3) {
          return e2.consume(t3), r2;
        };
        function r2(t3) {
          return 87 === t3 || 119 === t3 ? (e2.consume(t3), i2) : n2(t3);
        }
        function i2(t3) {
          return 87 === t3 || 119 === t3 ? (e2.consume(t3), o2) : n2(t3);
        }
        function o2(t3) {
          return 46 === t3 ? (e2.consume(t3), u2) : n2(t3);
        }
        function u2(e3) {
          return null === e3 || f(e3) ? n2(e3) : t2(e3);
        }
      }, partial: true }, b = { tokenize: function(e2, t2, n2) {
        let r2, i2;
        return o2;
        function o2(t3) {
          return 38 === t3 ? e2.check(v, c2, u2)(t3) : 46 === t3 || 95 === t3 ? e2.check(k, c2, u2)(t3) : null === t3 || l(t3) || d(t3) || 45 !== t3 && m(t3) ? c2(t3) : (e2.consume(t3), o2);
        }
        function u2(t3) {
          return 46 === t3 ? (i2 = r2, r2 = void 0, e2.consume(t3), o2) : (95 === t3 && (r2 = true), e2.consume(t3), o2);
        }
        function c2(e3) {
          return i2 || r2 ? n2(e3) : t2(e3);
        }
      }, partial: true }, x = { tokenize: function(e2, t2) {
        let n2 = 0;
        return r2;
        function r2(u2) {
          return 38 === u2 ? e2.check(v, t2, i2)(u2) : (40 === u2 && n2++, 41 === u2 ? e2.check(k, o2, i2)(u2) : D(u2) ? t2(u2) : A(u2) ? e2.check(k, t2, i2)(u2) : (e2.consume(u2), r2));
        }
        function i2(t3) {
          return e2.consume(t3), r2;
        }
        function o2(e3) {
          return n2--, n2 < 0 ? t2(e3) : i2(e3);
        }
      }, partial: true }, k = { tokenize: function(e2, t2, n2) {
        return function(t3) {
          return e2.consume(t3), r2;
        };
        function r2(i2) {
          return A(i2) ? (e2.consume(i2), r2) : D(i2) ? t2(i2) : n2(i2);
        }
      }, partial: true }, v = { tokenize: function(e2, t2, n2) {
        return function(t3) {
          return e2.consume(t3), i2;
        };
        function i2(t3) {
          return r(t3) ? (e2.consume(t3), i2) : 59 === t3 ? (e2.consume(t3), o2) : n2(t3);
        }
        function o2(e3) {
          return D(e3) ? t2(e3) : n2(e3);
        }
      }, partial: true }, y = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          return 87 !== t3 && 119 !== t3 || !L(r2.previous) || I(r2.events) ? n2(t3) : (e2.enter("literalAutolink"), e2.enter("literalAutolinkWww"), e2.check(h, e2.attempt(b, e2.attempt(x, i2), n2), n2)(t3));
        };
        function i2(n3) {
          return e2.exit("literalAutolinkWww"), e2.exit("literalAutolink"), t2(n3);
        }
      }, previous: L }, w = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          return 72 !== t3 && 104 !== t3 || !T(r2.previous) || I(r2.events) ? n2(t3) : (e2.enter("literalAutolink"), e2.enter("literalAutolinkHttp"), e2.consume(t3), i2);
        };
        function i2(t3) {
          return 84 === t3 || 116 === t3 ? (e2.consume(t3), o2) : n2(t3);
        }
        function o2(t3) {
          return 84 === t3 || 116 === t3 ? (e2.consume(t3), u2) : n2(t3);
        }
        function u2(t3) {
          return 80 === t3 || 112 === t3 ? (e2.consume(t3), c2) : n2(t3);
        }
        function c2(t3) {
          return 83 === t3 || 115 === t3 ? (e2.consume(t3), a2) : a2(t3);
        }
        function a2(t3) {
          return 58 === t3 ? (e2.consume(t3), s2) : n2(t3);
        }
        function s2(t3) {
          return 47 === t3 ? (e2.consume(t3), f2) : n2(t3);
        }
        function f2(t3) {
          return 47 === t3 ? (e2.consume(t3), p2) : n2(t3);
        }
        function p2(t3) {
          return null === t3 || l(t3) || d(t3) || m(t3) ? n2(t3) : e2.attempt(b, e2.attempt(x, g2), n2)(t3);
        }
        function g2(n3) {
          return e2.exit("literalAutolinkHttp"), e2.exit("literalAutolink"), t2(n3);
        }
      }, previous: T }, q = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        let o2, c2;
        return function(t3) {
          return C(t3) && z(r2.previous) && !I(r2.events) ? (e2.enter("literalAutolink"), e2.enter("literalAutolinkEmail"), a2(t3)) : n2(t3);
        };
        function a2(t3) {
          return C(t3) ? (e2.consume(t3), a2) : 64 === t3 ? (e2.consume(t3), l2) : n2(t3);
        }
        function l2(t3) {
          return 46 === t3 ? e2.check(k, d2, s2)(t3) : 45 === t3 || 95 === t3 ? e2.check(k, n2, f2)(t3) : u(t3) ? (!c2 && i(t3) && (c2 = true), e2.consume(t3), l2) : d2(t3);
        }
        function s2(t3) {
          return e2.consume(t3), o2 = true, c2 = void 0, l2;
        }
        function f2(t3) {
          return e2.consume(t3), p2;
        }
        function p2(t3) {
          return 46 === t3 ? e2.check(k, n2, s2)(t3) : l2(t3);
        }
        function d2(r3) {
          return o2 && !c2 ? (e2.exit("literalAutolinkEmail"), e2.exit("literalAutolink"), t2(r3)) : n2(r3);
        }
      }, previous: z }, S = {}, F = { text: S };
      let E = 48;
      for (; E < 123; )
        S[E] = q, E++, 58 === E ? E = 65 : 91 === E && (E = 97);
      function A(e2) {
        return 33 === e2 || 34 === e2 || 39 === e2 || 41 === e2 || 42 === e2 || 44 === e2 || 46 === e2 || 58 === e2 || 59 === e2 || 60 === e2 || 63 === e2 || 95 === e2 || 126 === e2;
      }
      function D(e2) {
        return null === e2 || 60 === e2 || s(e2);
      }
      function C(e2) {
        return 43 === e2 || 45 === e2 || 46 === e2 || 95 === e2 || u(e2);
      }
      function L(e2) {
        return null === e2 || 40 === e2 || 42 === e2 || 95 === e2 || 126 === e2 || s(e2);
      }
      function T(e2) {
        return null === e2 || !r(e2);
      }
      function z(e2) {
        return 47 !== e2 && T(e2);
      }
      function I(e2) {
        let t2 = e2.length, n2 = false;
        for (; t2--; ) {
          const r2 = e2[t2][1];
          if (("labelLink" === r2.type || "labelImage" === r2.type) && !r2._balanced) {
            n2 = true;
            break;
          }
          if (r2._gfmAutolinkLiteralWalkedInto) {
            n2 = false;
            break;
          }
        }
        return e2.length > 0 && !n2 && (e2[e2.length - 1][1]._gfmAutolinkLiteralWalkedInto = true), n2;
      }
      function B(e2, t2, n2, r2) {
        const i2 = r2 ? r2 - 1 : Number.POSITIVE_INFINITY;
        let o2 = 0;
        return function(r3) {
          return p(r3) ? (e2.enter(n2), u2(r3)) : t2(r3);
        };
        function u2(r3) {
          return p(r3) && o2++ < i2 ? (e2.consume(r3), u2) : (e2.exit(n2), t2(r3));
        }
      }
      S[43] = q, S[45] = q, S[46] = q, S[95] = q, S[72] = [q, w], S[104] = [q, w], S[87] = [q, y], S[119] = [q, y];
      const R = { tokenize: function(e2, t2, n2) {
        return B(e2, function(e3) {
          return null === e3 || f(e3) ? t2(e3) : n2(e3);
        }, "linePrefix");
      }, partial: true };
      function M(e2) {
        return e2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
      }
      const N = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return B(e2, function(e3) {
          const i2 = r2.events[r2.events.length - 1];
          return i2 && "gfmFootnoteDefinitionIndent" === i2[1].type && 4 === i2[2].sliceSerialize(i2[1], true).length ? t2(e3) : n2(e3);
        }, "gfmFootnoteDefinitionIndent", 5);
      }, partial: true };
      function P() {
        return { document: { 91: { tokenize: H, continuation: { tokenize: j }, exit: U } }, text: { 91: { tokenize: V }, 93: { add: "after", tokenize: O, resolveTo: _ } } };
      }
      function O(e2, t2, n2) {
        const r2 = this;
        let i2 = r2.events.length;
        const o2 = r2.parser.gfmFootnotes || (r2.parser.gfmFootnotes = []);
        let u2;
        for (; i2--; ) {
          const e3 = r2.events[i2][1];
          if ("labelImage" === e3.type) {
            u2 = e3;
            break;
          }
          if ("gfmFootnoteCall" === e3.type || "labelLink" === e3.type || "label" === e3.type || "image" === e3.type || "link" === e3.type)
            break;
        }
        return function(i3) {
          if (!u2 || !u2._balanced)
            return n2(i3);
          const c2 = M(r2.sliceSerialize({ start: u2.end, end: r2.now() }));
          return 94 === c2.charCodeAt(0) && o2.includes(c2.slice(1)) ? (e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(i3), e2.exit("gfmFootnoteCallLabelMarker"), t2(i3)) : n2(i3);
        };
      }
      function _(e2, t2) {
        let n2, r2 = e2.length;
        for (; r2--; )
          if ("labelImage" === e2[r2][1].type && "enter" === e2[r2][0]) {
            n2 = e2[r2][1];
            break;
          }
        e2[r2 + 1][1].type = "data", e2[r2 + 3][1].type = "gfmFootnoteCallLabelMarker";
        const i2 = { type: "gfmFootnoteCall", start: Object.assign({}, e2[r2 + 3][1].start), end: Object.assign({}, e2[e2.length - 1][1].end) }, o2 = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e2[r2 + 3][1].end), end: Object.assign({}, e2[r2 + 3][1].end) };
        o2.end.column++, o2.end.offset++, o2.end._bufferIndex++;
        const u2 = { type: "gfmFootnoteCallString", start: Object.assign({}, o2.end), end: Object.assign({}, e2[e2.length - 1][1].start) }, c2 = { type: "chunkString", contentType: "string", start: Object.assign({}, u2.start), end: Object.assign({}, u2.end) }, a2 = [e2[r2 + 1], e2[r2 + 2], ["enter", i2, t2], e2[r2 + 3], e2[r2 + 4], ["enter", o2, t2], ["exit", o2, t2], ["enter", u2, t2], ["enter", c2, t2], ["exit", c2, t2], ["exit", u2, t2], e2[e2.length - 2], e2[e2.length - 1], ["exit", i2, t2]];
        return e2.splice(r2, e2.length - r2 + 1, ...a2), e2;
      }
      function V(e2, t2, n2) {
        const r2 = this, i2 = r2.parser.gfmFootnotes || (r2.parser.gfmFootnotes = []);
        let o2, u2 = 0;
        return function(t3) {
          return e2.enter("gfmFootnoteCall"), e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(t3), e2.exit("gfmFootnoteCallLabelMarker"), c2;
        };
        function c2(t3) {
          return 94 !== t3 ? n2(t3) : (e2.enter("gfmFootnoteCallMarker"), e2.consume(t3), e2.exit("gfmFootnoteCallMarker"), e2.enter("gfmFootnoteCallString"), e2.enter("chunkString").contentType = "string", a2);
        }
        function a2(c3) {
          let f2;
          return null === c3 || 91 === c3 || u2++ > 999 ? n2(c3) : 93 === c3 ? o2 ? (e2.exit("chunkString"), f2 = e2.exit("gfmFootnoteCallString"), i2.includes(M(r2.sliceSerialize(f2))) ? function(n3) {
            return e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(n3), e2.exit("gfmFootnoteCallLabelMarker"), e2.exit("gfmFootnoteCall"), t2;
          }(c3) : n2(c3)) : n2(c3) : (e2.consume(c3), s(c3) || (o2 = true), 92 === c3 ? l2 : a2);
        }
        function l2(t3) {
          return 91 === t3 || 92 === t3 || 93 === t3 ? (e2.consume(t3), u2++, a2) : a2(t3);
        }
      }
      function H(e2, t2, n2) {
        const r2 = this, i2 = r2.parser.gfmFootnotes || (r2.parser.gfmFootnotes = []);
        let o2, u2, c2 = 0;
        return function(t3) {
          return e2.enter("gfmFootnoteDefinition")._container = true, e2.enter("gfmFootnoteDefinitionLabel"), e2.enter("gfmFootnoteDefinitionLabelMarker"), e2.consume(t3), e2.exit("gfmFootnoteDefinitionLabelMarker"), a2;
        };
        function a2(t3) {
          return 94 === t3 ? (e2.enter("gfmFootnoteDefinitionMarker"), e2.consume(t3), e2.exit("gfmFootnoteDefinitionMarker"), e2.enter("gfmFootnoteDefinitionLabelString"), l2) : n2(t3);
        }
        function l2(t3) {
          let i3;
          return null === t3 || 91 === t3 || c2 > 999 ? n2(t3) : 93 === t3 ? u2 ? (i3 = e2.exit("gfmFootnoteDefinitionLabelString"), o2 = M(r2.sliceSerialize(i3)), e2.enter("gfmFootnoteDefinitionLabelMarker"), e2.consume(t3), e2.exit("gfmFootnoteDefinitionLabelMarker"), e2.exit("gfmFootnoteDefinitionLabel"), m2) : n2(t3) : f(t3) ? (e2.enter("lineEnding"), e2.consume(t3), e2.exit("lineEnding"), c2++, l2) : (e2.enter("chunkString").contentType = "string", p2(t3));
        }
        function p2(t3) {
          return null === t3 || f(t3) || 91 === t3 || 93 === t3 || c2 > 999 ? (e2.exit("chunkString"), l2(t3)) : (s(t3) || (u2 = true), c2++, e2.consume(t3), 92 === t3 ? d2 : p2);
        }
        function d2(t3) {
          return 91 === t3 || 92 === t3 || 93 === t3 ? (e2.consume(t3), c2++, p2) : p2(t3);
        }
        function m2(t3) {
          return 58 === t3 ? (e2.enter("definitionMarker"), e2.consume(t3), e2.exit("definitionMarker"), B(e2, g2, "gfmFootnoteDefinitionWhitespace")) : n2(t3);
        }
        function g2(e3) {
          return i2.includes(o2) || i2.push(o2), t2(e3);
        }
      }
      function j(e2, t2, n2) {
        return e2.check(R, t2, e2.attempt(N, t2, n2));
      }
      function U(e2) {
        e2.exit("gfmFootnoteDefinition");
      }
      const G = { flow: { null: { tokenize: function(e2, t2, n2) {
        const r2 = this, i2 = [];
        let o2, u2, c2 = 0;
        return function(t3) {
          return e2.enter("table")._align = i2, e2.enter("tableHead"), e2.enter("tableRow"), 124 === t3 ? a2(t3) : (c2++, e2.enter("temporaryTableCellContent"), m2(t3));
        };
        function a2(t3) {
          return e2.enter("tableCellDivider"), e2.consume(t3), e2.exit("tableCellDivider"), o2 = true, l2;
        }
        function l2(t3) {
          return null === t3 || f(t3) ? function(t4) {
            if (null === t4)
              return n2(t4);
            e2.exit("tableRow"), e2.exit("tableHead");
            const i3 = r2.interrupt;
            return r2.interrupt = true, e2.attempt({ tokenize: T2, partial: true }, function(t5) {
              return r2.interrupt = i3, e2.enter("tableDelimiterRow"), h2(t5);
            }, function(e3) {
              return r2.interrupt = i3, n2(e3);
            })(t4);
          }(t3) : p(t3) ? (e2.enter("whitespace"), e2.consume(t3), d2) : (o2 && (o2 = void 0, c2++), 124 === t3 ? a2(t3) : (e2.enter("temporaryTableCellContent"), m2(t3)));
        }
        function d2(t3) {
          return p(t3) ? (e2.consume(t3), d2) : (e2.exit("whitespace"), l2(t3));
        }
        function m2(t3) {
          return null === t3 || 124 === t3 || s(t3) ? (e2.exit("temporaryTableCellContent"), l2(t3)) : (e2.consume(t3), 92 === t3 ? g2 : m2);
        }
        function g2(t3) {
          return 92 === t3 || 124 === t3 ? (e2.consume(t3), m2) : m2(t3);
        }
        function h2(t3) {
          return null === t3 || f(t3) ? y2(t3) : p(t3) ? (e2.enter("whitespace"), e2.consume(t3), b2) : 45 === t3 ? (e2.enter("tableDelimiterFiller"), e2.consume(t3), u2 = true, i2.push("none"), x2) : 58 === t3 ? (e2.enter("tableDelimiterAlignment"), e2.consume(t3), e2.exit("tableDelimiterAlignment"), i2.push("left"), k2) : 124 === t3 ? (e2.enter("tableCellDivider"), e2.consume(t3), e2.exit("tableCellDivider"), h2) : n2(t3);
        }
        function b2(t3) {
          return p(t3) ? (e2.consume(t3), b2) : (e2.exit("whitespace"), h2(t3));
        }
        function x2(t3) {
          return 45 === t3 ? (e2.consume(t3), x2) : (e2.exit("tableDelimiterFiller"), 58 === t3 ? (e2.enter("tableDelimiterAlignment"), e2.consume(t3), e2.exit("tableDelimiterAlignment"), i2[i2.length - 1] = "left" === i2[i2.length - 1] ? "center" : "right", v2) : h2(t3));
        }
        function k2(t3) {
          return 45 === t3 ? (e2.enter("tableDelimiterFiller"), e2.consume(t3), u2 = true, x2) : n2(t3);
        }
        function v2(t3) {
          return null === t3 || f(t3) ? y2(t3) : p(t3) ? (e2.enter("whitespace"), e2.consume(t3), b2) : 124 === t3 ? (e2.enter("tableCellDivider"), e2.consume(t3), e2.exit("tableCellDivider"), h2) : n2(t3);
        }
        function y2(t3) {
          return e2.exit("tableDelimiterRow"), u2 && c2 === i2.length ? null === t3 ? w2(t3) : e2.check(Q, w2, e2.attempt({ tokenize: T2, partial: true }, B(e2, q2, "linePrefix", 4), w2))(t3) : n2(t3);
        }
        function w2(n3) {
          return e2.exit("table"), t2(n3);
        }
        function q2(t3) {
          return e2.enter("tableBody"), S2(t3);
        }
        function S2(t3) {
          return e2.enter("tableRow"), 124 === t3 ? F2(t3) : (e2.enter("temporaryTableCellContent"), D2(t3));
        }
        function F2(t3) {
          return e2.enter("tableCellDivider"), e2.consume(t3), e2.exit("tableCellDivider"), E2;
        }
        function E2(t3) {
          return null === t3 || f(t3) ? function(t4) {
            return e2.exit("tableRow"), null === t4 ? L2(t4) : e2.check(Q, L2, e2.attempt({ tokenize: T2, partial: true }, B(e2, S2, "linePrefix", 4), L2))(t4);
          }(t3) : p(t3) ? (e2.enter("whitespace"), e2.consume(t3), A2) : 124 === t3 ? F2(t3) : (e2.enter("temporaryTableCellContent"), D2(t3));
        }
        function A2(t3) {
          return p(t3) ? (e2.consume(t3), A2) : (e2.exit("whitespace"), E2(t3));
        }
        function D2(t3) {
          return null === t3 || 124 === t3 || s(t3) ? (e2.exit("temporaryTableCellContent"), E2(t3)) : (e2.consume(t3), 92 === t3 ? C2 : D2);
        }
        function C2(t3) {
          return 92 === t3 || 124 === t3 ? (e2.consume(t3), D2) : D2(t3);
        }
        function L2(t3) {
          return e2.exit("tableBody"), w2(t3);
        }
        function T2(e3, t3, n3) {
          return function(t4) {
            return e3.enter("lineEnding"), e3.consume(t4), e3.exit("lineEnding"), B(e3, i3, "linePrefix");
          };
          function i3(i4) {
            if (r2.parser.lazy[r2.now().line] || null === i4 || f(i4))
              return n3(i4);
            const o3 = r2.events[r2.events.length - 1];
            return !r2.parser.constructs.disable.null.includes("codeIndented") && o3 && "linePrefix" === o3[1].type && o3[2].sliceSerialize(o3[1], true).length >= 4 ? n3(i4) : (r2._gfmTableDynamicInterruptHack = true, e3.check(r2.parser.constructs.flow, function(e4) {
              return r2._gfmTableDynamicInterruptHack = false, n3(e4);
            }, function(e4) {
              return r2._gfmTableDynamicInterruptHack = false, t3(e4);
            })(i4));
          }
        }
      }, resolve: function(e2, t2) {
        let n2, r2, i2, o2, u2, c2, a2, l2 = -1;
        for (; ++l2 < e2.length; ) {
          const s2 = e2[l2][1];
          if (i2 && ("temporaryTableCellContent" === s2.type && (o2 = o2 || l2, u2 = l2), ("tableCellDivider" === s2.type || "tableRow" === s2.type) && u2)) {
            const n3 = { type: "tableContent", start: e2[o2][1].start, end: e2[u2][1].end }, r3 = { type: "chunkText", start: n3.start, end: n3.end, contentType: "text" };
            e2.splice(o2, u2 - o2 + 1, ["enter", n3, t2], ["enter", r3, t2], ["exit", r3, t2], ["exit", n3, t2]), l2 -= u2 - o2 - 3, o2 = void 0, u2 = void 0;
          }
          if ("exit" === e2[l2][0] && void 0 !== c2 && c2 + (a2 ? 0 : 1) < l2 && ("tableCellDivider" === s2.type || "tableRow" === s2.type && (c2 + 3 < l2 || "whitespace" !== e2[c2][1].type))) {
            const i3 = { type: r2 ? "tableDelimiter" : n2 ? "tableHeader" : "tableData", start: e2[c2][1].start, end: e2[l2][1].end };
            e2.splice(l2 + ("tableCellDivider" === s2.type ? 1 : 0), 0, ["exit", i3, t2]), e2.splice(c2, 0, ["enter", i3, t2]), l2 += 2, c2 = l2 + 1, a2 = true;
          }
          "tableRow" === s2.type && (i2 = "enter" === e2[l2][0], i2 && (c2 = l2 + 1, a2 = false)), "tableDelimiterRow" === s2.type && (r2 = "enter" === e2[l2][0], r2 && (c2 = l2 + 1, a2 = false)), "tableHead" === s2.type && (n2 = "enter" === e2[l2][0]);
        }
        return e2;
      } } } }, Q = { tokenize: function(e2, t2, n2) {
        let r2 = 0;
        return function(t3) {
          return e2.enter("check"), e2.consume(t3), i2;
        };
        function i2(o2) {
          return -1 === o2 || 32 === o2 ? (e2.consume(o2), r2++, 4 === r2 ? t2 : i2) : null === o2 || s(o2) ? t2(o2) : n2(o2);
        }
      }, partial: true };
      function W(e2, t2, n2, r2) {
        const i2 = e2.length;
        let o2, u2 = 0;
        if (t2 = t2 < 0 ? -t2 > i2 ? 0 : i2 + t2 : t2 > i2 ? i2 : t2, n2 = n2 > 0 ? n2 : 0, r2.length < 1e4)
          o2 = Array.from(r2), o2.unshift(t2, n2), [].splice.apply(e2, o2);
        else
          for (n2 && [].splice.apply(e2, [t2, n2]); u2 < r2.length; )
            o2 = r2.slice(u2, u2 + 1e4), o2.unshift(t2, 0), [].splice.apply(e2, o2), u2 += 1e4, t2 += 1e4;
      }
      function Z(e2, t2) {
        return e2.length > 0 ? (W(e2, e2.length, 0, t2), e2) : t2;
      }
      const J = {}.hasOwnProperty;
      function Y(e2, t2) {
        let n2;
        for (n2 in t2) {
          const r2 = (J.call(e2, n2) ? e2[n2] : void 0) || (e2[n2] = {}), i2 = t2[n2];
          let o2;
          for (o2 in i2) {
            J.call(r2, o2) || (r2[o2] = []);
            const e3 = i2[o2];
            K(r2[o2], Array.isArray(e3) ? e3 : e3 ? [e3] : []);
          }
        }
      }
      function K(e2, t2) {
        let n2 = -1;
        const r2 = [];
        for (; ++n2 < t2.length; )
          ("after" === t2[n2].add ? e2 : r2).push(t2[n2]);
        W(e2, 0, 0, r2);
      }
      const X = { tokenize: function(e2) {
        const t2 = e2.attempt(this.parser.constructs.contentInitial, function(n3) {
          if (null !== n3)
            return e2.enter("lineEnding"), e2.consume(n3), e2.exit("lineEnding"), B(e2, t2, "linePrefix");
          e2.consume(n3);
        }, function(t3) {
          return e2.enter("paragraph"), r2(t3);
        });
        let n2;
        return t2;
        function r2(t3) {
          const r3 = e2.enter("chunkText", { contentType: "text", previous: n2 });
          return n2 && (n2.next = r3), n2 = r3, i2(t3);
        }
        function i2(t3) {
          return null === t3 ? (e2.exit("chunkText"), e2.exit("paragraph"), void e2.consume(t3)) : f(t3) ? (e2.consume(t3), e2.exit("chunkText"), r2) : (e2.consume(t3), i2);
        }
      } }, $ = { tokenize: function(e2) {
        const t2 = this, n2 = [];
        let r2, i2, o2, u2 = 0;
        return c2;
        function c2(r3) {
          if (u2 < n2.length) {
            const i3 = n2[u2];
            return t2.containerState = i3[1], e2.attempt(i3[0].continuation, a2, l2)(r3);
          }
          return l2(r3);
        }
        function a2(e3) {
          if (u2++, t2.containerState._closeFlow) {
            t2.containerState._closeFlow = void 0, r2 && k2();
            const n3 = t2.events.length;
            let i3, o3 = n3;
            for (; o3--; )
              if ("exit" === t2.events[o3][0] && "chunkFlow" === t2.events[o3][1].type) {
                i3 = t2.events[o3][1].end;
                break;
              }
            x2(u2);
            let c3 = n3;
            for (; c3 < t2.events.length; )
              t2.events[c3][1].end = Object.assign({}, i3), c3++;
            return W(t2.events, o3 + 1, 0, t2.events.slice(n3)), t2.events.length = c3, l2(e3);
          }
          return c2(e3);
        }
        function l2(i3) {
          if (u2 === n2.length) {
            if (!r2)
              return d2(i3);
            if (r2.currentConstruct && r2.currentConstruct.concrete)
              return g2(i3);
            t2.interrupt = Boolean(r2.currentConstruct && !r2._gfmTableDynamicInterruptHack);
          }
          return t2.containerState = {}, e2.check(ee, s2, p2)(i3);
        }
        function s2(e3) {
          return r2 && k2(), x2(u2), d2(e3);
        }
        function p2(e3) {
          return t2.parser.lazy[t2.now().line] = u2 !== n2.length, o2 = t2.now().offset, g2(e3);
        }
        function d2(n3) {
          return t2.containerState = {}, e2.attempt(ee, m2, g2)(n3);
        }
        function m2(e3) {
          return u2++, n2.push([t2.currentConstruct, t2.containerState]), d2(e3);
        }
        function g2(n3) {
          return null === n3 ? (r2 && k2(), x2(0), void e2.consume(n3)) : (r2 = r2 || t2.parser.flow(t2.now()), e2.enter("chunkFlow", { contentType: "flow", previous: i2, _tokenizer: r2 }), h2(n3));
        }
        function h2(n3) {
          return null === n3 ? (b2(e2.exit("chunkFlow"), true), x2(0), void e2.consume(n3)) : f(n3) ? (e2.consume(n3), b2(e2.exit("chunkFlow")), u2 = 0, t2.interrupt = void 0, c2) : (e2.consume(n3), h2);
        }
        function b2(e3, n3) {
          const c3 = t2.sliceStream(e3);
          if (n3 && c3.push(null), e3.previous = i2, i2 && (i2.next = e3), i2 = e3, r2.defineSkip(e3.start), r2.write(c3), t2.parser.lazy[e3.start.line]) {
            let e4 = r2.events.length;
            for (; e4--; )
              if (r2.events[e4][1].start.offset < o2 && (!r2.events[e4][1].end || r2.events[e4][1].end.offset > o2))
                return;
            const n4 = t2.events.length;
            let i3, c4, a3 = n4;
            for (; a3--; )
              if ("exit" === t2.events[a3][0] && "chunkFlow" === t2.events[a3][1].type) {
                if (i3) {
                  c4 = t2.events[a3][1].end;
                  break;
                }
                i3 = true;
              }
            for (x2(u2), e4 = n4; e4 < t2.events.length; )
              t2.events[e4][1].end = Object.assign({}, c4), e4++;
            W(t2.events, a3 + 1, 0, t2.events.slice(n4)), t2.events.length = e4;
          }
        }
        function x2(r3) {
          let i3 = n2.length;
          for (; i3-- > r3; ) {
            const r4 = n2[i3];
            t2.containerState = r4[1], r4[0].exit.call(t2, e2);
          }
          n2.length = r3;
        }
        function k2() {
          r2.write([null]), i2 = void 0, r2 = void 0, t2.containerState._closeFlow = void 0;
        }
      } }, ee = { tokenize: function(e2, t2, n2) {
        return B(e2, e2.attempt(this.parser.constructs.document, t2, n2), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
      } };
      function te(e2) {
        const t2 = {};
        let n2, r2, i2, o2, u2, c2, a2, l2 = -1;
        for (; ++l2 < e2.length; ) {
          for (; l2 in t2; )
            l2 = t2[l2];
          if (n2 = e2[l2], l2 && "chunkFlow" === n2[1].type && "listItemPrefix" === e2[l2 - 1][1].type && (c2 = n2[1]._tokenizer.events, i2 = 0, i2 < c2.length && "lineEndingBlank" === c2[i2][1].type && (i2 += 2), i2 < c2.length && "content" === c2[i2][1].type))
            for (; ++i2 < c2.length && "content" !== c2[i2][1].type; )
              "chunkText" === c2[i2][1].type && (c2[i2][1]._isInFirstContentOfListItem = true, i2++);
          if ("enter" === n2[0])
            n2[1].contentType && (Object.assign(t2, ne(e2, l2)), l2 = t2[l2], a2 = true);
          else if (n2[1]._container) {
            for (i2 = l2, r2 = void 0; i2-- && (o2 = e2[i2], "lineEnding" === o2[1].type || "lineEndingBlank" === o2[1].type); )
              "enter" === o2[0] && (r2 && (e2[r2][1].type = "lineEndingBlank"), o2[1].type = "lineEnding", r2 = i2);
            r2 && (n2[1].end = Object.assign({}, e2[r2][1].start), u2 = e2.slice(r2, l2), u2.unshift(n2), W(e2, r2, l2 - r2 + 1, u2));
          }
        }
        return !a2;
      }
      function ne(e2, t2) {
        const n2 = e2[t2][1], r2 = e2[t2][2];
        let i2 = t2 - 1;
        const o2 = [], u2 = n2._tokenizer || r2.parser[n2.contentType](n2.start), c2 = u2.events, a2 = [], l2 = {};
        let s2, f2, p2 = -1, d2 = n2, m2 = 0, g2 = 0;
        const h2 = [g2];
        for (; d2; ) {
          for (; e2[++i2][1] !== d2; )
            ;
          o2.push(i2), d2._tokenizer || (s2 = r2.sliceStream(d2), d2.next || s2.push(null), f2 && u2.defineSkip(d2.start), d2._isInFirstContentOfListItem && (u2._gfmTasklistFirstContentOfListItem = true), u2.write(s2), d2._isInFirstContentOfListItem && (u2._gfmTasklistFirstContentOfListItem = void 0)), f2 = d2, d2 = d2.next;
        }
        for (d2 = n2; ++p2 < c2.length; )
          "exit" === c2[p2][0] && "enter" === c2[p2 - 1][0] && c2[p2][1].type === c2[p2 - 1][1].type && c2[p2][1].start.line !== c2[p2][1].end.line && (g2 = p2 + 1, h2.push(g2), d2._tokenizer = void 0, d2.previous = void 0, d2 = d2.next);
        for (u2.events = [], d2 ? (d2._tokenizer = void 0, d2.previous = void 0) : h2.pop(), p2 = h2.length; p2--; ) {
          const t3 = c2.slice(h2[p2], h2[p2 + 1]), n3 = o2.pop();
          a2.unshift([n3, n3 + t3.length - 1]), W(e2, n3, 2, t3);
        }
        for (p2 = -1; ++p2 < a2.length; )
          l2[m2 + a2[p2][0]] = m2 + a2[p2][1], m2 += a2[p2][1] - a2[p2][0] - 1;
        return l2;
      }
      const re = { tokenize: function(e2, t2) {
        let n2;
        return function(t3) {
          return e2.enter("content"), n2 = e2.enter("chunkContent", { contentType: "content" }), r2(t3);
        };
        function r2(t3) {
          return null === t3 ? i2(t3) : f(t3) ? e2.check(ie, o2, i2)(t3) : (e2.consume(t3), r2);
        }
        function i2(n3) {
          return e2.exit("chunkContent"), e2.exit("content"), t2(n3);
        }
        function o2(t3) {
          return e2.consume(t3), e2.exit("chunkContent"), n2.next = e2.enter("chunkContent", { contentType: "content", previous: n2 }), n2 = n2.next, r2;
        }
      }, resolve: function(e2) {
        return te(e2), e2;
      } }, ie = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          return e2.exit("chunkContent"), e2.enter("lineEnding"), e2.consume(t3), e2.exit("lineEnding"), B(e2, i2, "linePrefix");
        };
        function i2(i3) {
          if (null === i3 || f(i3))
            return n2(i3);
          const o2 = r2.events[r2.events.length - 1];
          return !r2.parser.constructs.disable.null.includes("codeIndented") && o2 && "linePrefix" === o2[1].type && o2[2].sliceSerialize(o2[1], true).length >= 4 ? t2(i3) : e2.interrupt(r2.parser.constructs.flow, n2, t2)(i3);
        }
      }, partial: true }, oe = { tokenize: function(e2) {
        const t2 = this, n2 = e2.attempt(R, function(r3) {
          if (null !== r3)
            return e2.enter("lineEndingBlank"), e2.consume(r3), e2.exit("lineEndingBlank"), t2.currentConstruct = void 0, n2;
          e2.consume(r3);
        }, e2.attempt(this.parser.constructs.flowInitial, r2, B(e2, e2.attempt(this.parser.constructs.flow, r2, e2.attempt(re, r2)), "linePrefix")));
        return n2;
        function r2(r3) {
          if (null !== r3)
            return e2.enter("lineEnding"), e2.consume(r3), e2.exit("lineEnding"), t2.currentConstruct = void 0, n2;
          e2.consume(r3);
        }
      } }, ue = { resolveAll: se() }, ce = le("string"), ae = le("text");
      function le(e2) {
        return { tokenize: function(t2) {
          const n2 = this, r2 = this.parser.constructs[e2], i2 = t2.attempt(r2, o2, u2);
          return o2;
          function o2(e3) {
            return a2(e3) ? i2(e3) : u2(e3);
          }
          function u2(e3) {
            if (null !== e3)
              return t2.enter("data"), t2.consume(e3), c2;
            t2.consume(e3);
          }
          function c2(e3) {
            return a2(e3) ? (t2.exit("data"), i2(e3)) : (t2.consume(e3), c2);
          }
          function a2(e3) {
            if (null === e3)
              return true;
            const t3 = r2[e3];
            let i3 = -1;
            if (t3)
              for (; ++i3 < t3.length; ) {
                const e4 = t3[i3];
                if (!e4.previous || e4.previous.call(n2, n2.previous))
                  return true;
              }
            return false;
          }
        }, resolveAll: se("text" === e2 ? fe : void 0) };
      }
      function se(e2) {
        return function(t2, n2) {
          let r2, i2 = -1;
          for (; ++i2 <= t2.length; )
            void 0 === r2 ? t2[i2] && "data" === t2[i2][1].type && (r2 = i2, i2++) : t2[i2] && "data" === t2[i2][1].type || (i2 !== r2 + 2 && (t2[r2][1].end = t2[i2 - 1][1].end, t2.splice(r2 + 2, i2 - r2 - 2), i2 = r2 + 2), r2 = void 0);
          return e2 ? e2(t2, n2) : t2;
        };
      }
      function fe(e2, t2) {
        let n2 = 0;
        for (; ++n2 <= e2.length; )
          if ((n2 === e2.length || "lineEnding" === e2[n2][1].type) && "data" === e2[n2 - 1][1].type) {
            const r2 = e2[n2 - 1][1], i2 = t2.sliceStream(r2);
            let o2, u2 = i2.length, c2 = -1, a2 = 0;
            for (; u2--; ) {
              const e3 = i2[u2];
              if ("string" == typeof e3) {
                for (c2 = e3.length; 32 === e3.charCodeAt(c2 - 1); )
                  a2++, c2--;
                if (c2)
                  break;
                c2 = -1;
              } else if (-2 === e3)
                o2 = true, a2++;
              else if (-1 !== e3) {
                u2++;
                break;
              }
            }
            if (a2) {
              const i3 = { type: n2 === e2.length || o2 || a2 < 2 ? "lineSuffix" : "hardBreakTrailing", start: { line: r2.end.line, column: r2.end.column - a2, offset: r2.end.offset - a2, _index: r2.start._index + u2, _bufferIndex: u2 ? c2 : r2.start._bufferIndex + c2 }, end: Object.assign({}, r2.end) };
              r2.end = Object.assign({}, i3.start), r2.start.offset === r2.end.offset ? Object.assign(r2, i3) : (e2.splice(n2, 0, ["enter", i3, t2], ["exit", i3, t2]), n2 += 2);
            }
            n2++;
          }
        return e2;
      }
      function pe(e2, t2, n2) {
        const r2 = [];
        let i2 = -1;
        for (; ++i2 < e2.length; ) {
          const o2 = e2[i2].resolveAll;
          o2 && !r2.includes(o2) && (t2 = o2(t2, n2), r2.push(o2));
        }
        return t2;
      }
      function de(e2, t2, n2) {
        let r2 = Object.assign(n2 ? Object.assign({}, n2) : { line: 1, column: 1, offset: 0 }, { _index: 0, _bufferIndex: -1 });
        const i2 = {}, o2 = [];
        let u2 = [], c2 = [], a2 = true;
        const l2 = { consume: function(e3) {
          f(e3) ? (r2.line++, r2.column = 1, r2.offset += -3 === e3 ? 2 : 1, v2()) : -1 !== e3 && (r2.column++, r2.offset++), r2._bufferIndex < 0 ? r2._index++ : (r2._bufferIndex++, r2._bufferIndex === u2[r2._index].length && (r2._bufferIndex = -1, r2._index++)), s2.previous = e3, a2 = true;
        }, enter: function(e3, t3) {
          const n3 = t3 || {};
          return n3.type = e3, n3.start = g2(), s2.events.push(["enter", n3, s2]), c2.push(n3), n3;
        }, exit: function(e3) {
          const t3 = c2.pop();
          return t3.end = g2(), s2.events.push(["exit", t3, s2]), t3;
        }, attempt: x2(function(e3, t3) {
          k2(e3, t3.from);
        }), check: x2(b2), interrupt: x2(b2, { interrupt: true }) }, s2 = { previous: null, code: null, containerState: {}, events: [], parser: e2, sliceStream: m2, sliceSerialize: function(e3, t3) {
          return function(e4, t4) {
            let n3 = -1;
            const r3 = [];
            let i3;
            for (; ++n3 < e4.length; ) {
              const o3 = e4[n3];
              let u3;
              if ("string" == typeof o3)
                u3 = o3;
              else
                switch (o3) {
                  case -5:
                    u3 = "\r";
                    break;
                  case -4:
                    u3 = "\n";
                    break;
                  case -3:
                    u3 = "\r\n";
                    break;
                  case -2:
                    u3 = t4 ? " " : "	";
                    break;
                  case -1:
                    if (!t4 && i3)
                      continue;
                    u3 = " ";
                    break;
                  default:
                    u3 = String.fromCharCode(o3);
                }
              i3 = -2 === o3, r3.push(u3);
            }
            return r3.join("");
          }(m2(e3), t3);
        }, now: g2, defineSkip: function(e3) {
          i2[e3.line] = e3.column, v2();
        }, write: function(e3) {
          return u2 = Z(u2, e3), function() {
            let e4;
            for (; r2._index < u2.length; ) {
              const t3 = u2[r2._index];
              if ("string" == typeof t3)
                for (e4 = r2._index, r2._bufferIndex < 0 && (r2._bufferIndex = 0); r2._index === e4 && r2._bufferIndex < t3.length; )
                  h2(t3.charCodeAt(r2._bufferIndex));
              else
                h2(t3);
            }
          }(), null !== u2[u2.length - 1] ? [] : (k2(t2, 0), s2.events = pe(o2, s2.events, s2), s2.events);
        } };
        let p2, d2 = t2.tokenize.call(s2, l2);
        return t2.resolveAll && o2.push(t2), s2;
        function m2(e3) {
          return function(e4, t3) {
            const n3 = t3.start._index, r3 = t3.start._bufferIndex, i3 = t3.end._index, o3 = t3.end._bufferIndex;
            let u3;
            return n3 === i3 ? u3 = [e4[n3].slice(r3, o3)] : (u3 = e4.slice(n3, i3), r3 > -1 && (u3[0] = u3[0].slice(r3)), o3 > 0 && u3.push(e4[i3].slice(0, o3))), u3;
          }(u2, e3);
        }
        function g2() {
          return Object.assign({}, r2);
        }
        function h2(e3) {
          a2 = void 0, p2 = e3, d2 = d2(e3);
        }
        function b2(e3, t3) {
          t3.restore();
        }
        function x2(e3, t3) {
          return function(n3, i3, o3) {
            let u3, f2, p3, d3;
            return Array.isArray(n3) ? h3(n3) : "tokenize" in n3 ? h3([n3]) : (m3 = n3, function(e4) {
              const t4 = null !== e4 && m3[e4], n4 = null !== e4 && m3.null;
              return h3([...Array.isArray(t4) ? t4 : t4 ? [t4] : [], ...Array.isArray(n4) ? n4 : n4 ? [n4] : []])(e4);
            });
            var m3;
            function h3(e4) {
              return u3 = e4, f2 = 0, 0 === e4.length ? o3 : b3(e4[f2]);
            }
            function b3(e4) {
              return function(n4) {
                return d3 = function() {
                  const e5 = g2(), t4 = s2.previous, n5 = s2.currentConstruct, i4 = s2.events.length, o4 = Array.from(c2);
                  return { restore: function() {
                    r2 = e5, s2.previous = t4, s2.currentConstruct = n5, s2.events.length = i4, c2 = o4, v2();
                  }, from: i4 };
                }(), p3 = e4, e4.partial || (s2.currentConstruct = e4), e4.name && s2.parser.constructs.disable.null.includes(e4.name) ? k3() : e4.tokenize.call(t3 ? Object.assign(Object.create(s2), t3) : s2, l2, x3, k3)(n4);
              };
            }
            function x3(t4) {
              return a2 = true, e3(p3, d3), i3;
            }
            function k3(e4) {
              return a2 = true, d3.restore(), ++f2 < u3.length ? b3(u3[f2]) : o3;
            }
          };
        }
        function k2(e3, t3) {
          e3.resolveAll && !o2.includes(e3) && o2.push(e3), e3.resolve && W(s2.events, t3, s2.events.length - t3, e3.resolve(s2.events.slice(t3), s2)), e3.resolveTo && (s2.events = e3.resolveTo(s2.events, s2));
        }
        function v2() {
          r2.line in i2 && r2.column < 2 && (r2.column = i2[r2.line], r2.offset += i2[r2.line] - 1);
        }
      }
      const me = { name: "thematicBreak", tokenize: function(e2, t2, n2) {
        let r2, i2 = 0;
        return function(t3) {
          return e2.enter("thematicBreak"), r2 = t3, o2(t3);
        };
        function o2(c2) {
          return c2 === r2 ? (e2.enter("thematicBreakSequence"), u2(c2)) : p(c2) ? B(e2, o2, "whitespace")(c2) : i2 < 3 || null !== c2 && !f(c2) ? n2(c2) : (e2.exit("thematicBreak"), t2(c2));
        }
        function u2(t3) {
          return t3 === r2 ? (e2.consume(t3), i2++, u2) : (e2.exit("thematicBreakSequence"), o2(t3));
        }
      } }, ge = { name: "list", tokenize: function(e2, t2, n2) {
        const r2 = this, o2 = r2.events[r2.events.length - 1];
        let u2 = o2 && "linePrefix" === o2[1].type ? o2[2].sliceSerialize(o2[1], true).length : 0, c2 = 0;
        return function(t3) {
          const o3 = r2.containerState.type || (42 === t3 || 43 === t3 || 45 === t3 ? "listUnordered" : "listOrdered");
          if ("listUnordered" === o3 ? !r2.containerState.marker || t3 === r2.containerState.marker : i(t3)) {
            if (r2.containerState.type || (r2.containerState.type = o3, e2.enter(o3, { _container: true })), "listUnordered" === o3)
              return e2.enter("listItemPrefix"), 42 === t3 || 45 === t3 ? e2.check(me, n2, l2)(t3) : l2(t3);
            if (!r2.interrupt || 49 === t3)
              return e2.enter("listItemPrefix"), e2.enter("listItemValue"), a2(t3);
          }
          return n2(t3);
        };
        function a2(t3) {
          return i(t3) && ++c2 < 10 ? (e2.consume(t3), a2) : (!r2.interrupt || c2 < 2) && (r2.containerState.marker ? t3 === r2.containerState.marker : 41 === t3 || 46 === t3) ? (e2.exit("listItemValue"), l2(t3)) : n2(t3);
        }
        function l2(t3) {
          return e2.enter("listItemMarker"), e2.consume(t3), e2.exit("listItemMarker"), r2.containerState.marker = r2.containerState.marker || t3, e2.check(R, r2.interrupt ? n2 : s2, e2.attempt(he, d2, f2));
        }
        function s2(e3) {
          return r2.containerState.initialBlankLine = true, u2++, d2(e3);
        }
        function f2(t3) {
          return p(t3) ? (e2.enter("listItemPrefixWhitespace"), e2.consume(t3), e2.exit("listItemPrefixWhitespace"), d2) : n2(t3);
        }
        function d2(n3) {
          return r2.containerState.size = u2 + r2.sliceSerialize(e2.exit("listItemPrefix"), true).length, t2(n3);
        }
      }, continuation: { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return r2.containerState._closeFlow = void 0, e2.check(R, function(n3) {
          return r2.containerState.furtherBlankLines = r2.containerState.furtherBlankLines || r2.containerState.initialBlankLine, B(e2, t2, "listItemIndent", r2.containerState.size + 1)(n3);
        }, function(n3) {
          return r2.containerState.furtherBlankLines || !p(n3) ? (r2.containerState.furtherBlankLines = void 0, r2.containerState.initialBlankLine = void 0, i2(n3)) : (r2.containerState.furtherBlankLines = void 0, r2.containerState.initialBlankLine = void 0, e2.attempt(be, t2, i2)(n3));
        });
        function i2(i3) {
          return r2.containerState._closeFlow = true, r2.interrupt = void 0, B(e2, e2.attempt(ge, t2, n2), "linePrefix", r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(i3);
        }
      } }, exit: function(e2) {
        e2.exit(this.containerState.type);
      } }, he = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return B(e2, function(e3) {
          const i2 = r2.events[r2.events.length - 1];
          return !p(e3) && i2 && "listItemPrefixWhitespace" === i2[1].type ? t2(e3) : n2(e3);
        }, "listItemPrefixWhitespace", r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
      }, partial: true }, be = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return B(e2, function(e3) {
          const i2 = r2.events[r2.events.length - 1];
          return i2 && "listItemIndent" === i2[1].type && i2[2].sliceSerialize(i2[1], true).length === r2.containerState.size ? t2(e3) : n2(e3);
        }, "listItemIndent", r2.containerState.size + 1);
      }, partial: true }, xe = { name: "blockQuote", tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          if (62 === t3) {
            const n3 = r2.containerState;
            return n3.open || (e2.enter("blockQuote", { _container: true }), n3.open = true), e2.enter("blockQuotePrefix"), e2.enter("blockQuoteMarker"), e2.consume(t3), e2.exit("blockQuoteMarker"), i2;
          }
          return n2(t3);
        };
        function i2(n3) {
          return p(n3) ? (e2.enter("blockQuotePrefixWhitespace"), e2.consume(n3), e2.exit("blockQuotePrefixWhitespace"), e2.exit("blockQuotePrefix"), t2) : (e2.exit("blockQuotePrefix"), t2(n3));
        }
      }, continuation: { tokenize: function(e2, t2, n2) {
        return B(e2, e2.attempt(xe, t2, n2), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
      } }, exit: function(e2) {
        e2.exit("blockQuote");
      } };
      function ke(e2, t2, n2, r2, i2, o2, u2, c2, a2) {
        const p2 = a2 || Number.POSITIVE_INFINITY;
        let d2 = 0;
        return function(t3) {
          return 60 === t3 ? (e2.enter(r2), e2.enter(i2), e2.enter(o2), e2.consume(t3), e2.exit(o2), m2) : null === t3 || 41 === t3 || l(t3) ? n2(t3) : (e2.enter(r2), e2.enter(u2), e2.enter(c2), e2.enter("chunkString", { contentType: "string" }), b2(t3));
        };
        function m2(n3) {
          return 62 === n3 ? (e2.enter(o2), e2.consume(n3), e2.exit(o2), e2.exit(i2), e2.exit(r2), t2) : (e2.enter(c2), e2.enter("chunkString", { contentType: "string" }), g2(n3));
        }
        function g2(t3) {
          return 62 === t3 ? (e2.exit("chunkString"), e2.exit(c2), m2(t3)) : null === t3 || 60 === t3 || f(t3) ? n2(t3) : (e2.consume(t3), 92 === t3 ? h2 : g2);
        }
        function h2(t3) {
          return 60 === t3 || 62 === t3 || 92 === t3 ? (e2.consume(t3), g2) : g2(t3);
        }
        function b2(i3) {
          return 40 === i3 ? ++d2 > p2 ? n2(i3) : (e2.consume(i3), b2) : 41 === i3 ? d2-- ? (e2.consume(i3), b2) : (e2.exit("chunkString"), e2.exit(c2), e2.exit(u2), e2.exit(r2), t2(i3)) : null === i3 || s(i3) ? d2 ? n2(i3) : (e2.exit("chunkString"), e2.exit(c2), e2.exit(u2), e2.exit(r2), t2(i3)) : l(i3) ? n2(i3) : (e2.consume(i3), 92 === i3 ? x2 : b2);
        }
        function x2(t3) {
          return 40 === t3 || 41 === t3 || 92 === t3 ? (e2.consume(t3), b2) : b2(t3);
        }
      }
      function ve(e2, t2, n2, r2, i2, o2) {
        const u2 = this;
        let c2, a2 = 0;
        return function(t3) {
          return e2.enter(r2), e2.enter(i2), e2.consume(t3), e2.exit(i2), e2.enter(o2), l2;
        };
        function l2(p2) {
          return null === p2 || 91 === p2 || 93 === p2 && !c2 || 94 === p2 && !a2 && "_hiddenFootnoteSupport" in u2.parser.constructs || a2 > 999 ? n2(p2) : 93 === p2 ? (e2.exit(o2), e2.enter(i2), e2.consume(p2), e2.exit(i2), e2.exit(r2), t2) : f(p2) ? (e2.enter("lineEnding"), e2.consume(p2), e2.exit("lineEnding"), l2) : (e2.enter("chunkString", { contentType: "string" }), s2(p2));
        }
        function s2(t3) {
          return null === t3 || 91 === t3 || 93 === t3 || f(t3) || a2++ > 999 ? (e2.exit("chunkString"), l2(t3)) : (e2.consume(t3), c2 = c2 || !p(t3), 92 === t3 ? d2 : s2);
        }
        function d2(t3) {
          return 91 === t3 || 92 === t3 || 93 === t3 ? (e2.consume(t3), a2++, s2) : s2(t3);
        }
      }
      function ye(e2, t2, n2, r2, i2, o2) {
        let u2;
        return function(t3) {
          return e2.enter(r2), e2.enter(i2), e2.consume(t3), e2.exit(i2), u2 = 40 === t3 ? 41 : t3, c2;
        };
        function c2(n3) {
          return n3 === u2 ? (e2.enter(i2), e2.consume(n3), e2.exit(i2), e2.exit(r2), t2) : (e2.enter(o2), a2(n3));
        }
        function a2(t3) {
          return t3 === u2 ? (e2.exit(o2), c2(u2)) : null === t3 ? n2(t3) : f(t3) ? (e2.enter("lineEnding"), e2.consume(t3), e2.exit("lineEnding"), B(e2, a2, "linePrefix")) : (e2.enter("chunkString", { contentType: "string" }), l2(t3));
        }
        function l2(t3) {
          return t3 === u2 || null === t3 || f(t3) ? (e2.exit("chunkString"), a2(t3)) : (e2.consume(t3), 92 === t3 ? s2 : l2);
        }
        function s2(t3) {
          return t3 === u2 || 92 === t3 ? (e2.consume(t3), l2) : l2(t3);
        }
      }
      function we(e2, t2) {
        let n2;
        return function r2(i2) {
          return f(i2) ? (e2.enter("lineEnding"), e2.consume(i2), e2.exit("lineEnding"), n2 = true, r2) : p(i2) ? B(e2, r2, n2 ? "linePrefix" : "lineSuffix")(i2) : t2(i2);
        };
      }
      const qe = { name: "definition", tokenize: function(e2, t2, n2) {
        const r2 = this;
        let i2;
        return function(t3) {
          return e2.enter("definition"), ve.call(r2, e2, o2, n2, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(t3);
        };
        function o2(t3) {
          return i2 = M(r2.sliceSerialize(r2.events[r2.events.length - 1][1]).slice(1, -1)), 58 === t3 ? (e2.enter("definitionMarker"), e2.consume(t3), e2.exit("definitionMarker"), we(e2, ke(e2, e2.attempt(Se, B(e2, u2, "whitespace"), B(e2, u2, "whitespace")), n2, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"))) : n2(t3);
        }
        function u2(o3) {
          return null === o3 || f(o3) ? (e2.exit("definition"), r2.parser.defined.includes(i2) || r2.parser.defined.push(i2), t2(o3)) : n2(o3);
        }
      } }, Se = { tokenize: function(e2, t2, n2) {
        return function(t3) {
          return s(t3) ? we(e2, r2)(t3) : n2(t3);
        };
        function r2(t3) {
          return 34 === t3 || 39 === t3 || 40 === t3 ? ye(e2, B(e2, i2, "whitespace"), n2, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(t3) : n2(t3);
        }
        function i2(e3) {
          return null === e3 || f(e3) ? t2(e3) : n2(e3);
        }
      }, partial: true }, Fe = { name: "codeIndented", tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          return e2.enter("codeIndented"), B(e2, i2, "linePrefix", 5)(t3);
        };
        function i2(e3) {
          const t3 = r2.events[r2.events.length - 1];
          return t3 && "linePrefix" === t3[1].type && t3[2].sliceSerialize(t3[1], true).length >= 4 ? o2(e3) : n2(e3);
        }
        function o2(t3) {
          return null === t3 ? c2(t3) : f(t3) ? e2.attempt(Ee, o2, c2)(t3) : (e2.enter("codeFlowValue"), u2(t3));
        }
        function u2(t3) {
          return null === t3 || f(t3) ? (e2.exit("codeFlowValue"), o2(t3)) : (e2.consume(t3), u2);
        }
        function c2(n3) {
          return e2.exit("codeIndented"), t2(n3);
        }
      } }, Ee = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return i2;
        function i2(t3) {
          return r2.parser.lazy[r2.now().line] ? n2(t3) : f(t3) ? (e2.enter("lineEnding"), e2.consume(t3), e2.exit("lineEnding"), i2) : B(e2, o2, "linePrefix", 5)(t3);
        }
        function o2(e3) {
          const o3 = r2.events[r2.events.length - 1];
          return o3 && "linePrefix" === o3[1].type && o3[2].sliceSerialize(o3[1], true).length >= 4 ? t2(e3) : f(e3) ? i2(e3) : n2(e3);
        }
      }, partial: true }, Ae = { name: "headingAtx", tokenize: function(e2, t2, n2) {
        const r2 = this;
        let i2 = 0;
        return function(t3) {
          return e2.enter("atxHeading"), e2.enter("atxHeadingSequence"), o2(t3);
        };
        function o2(c3) {
          return 35 === c3 && i2++ < 6 ? (e2.consume(c3), o2) : null === c3 || s(c3) ? (e2.exit("atxHeadingSequence"), r2.interrupt ? t2(c3) : u2(c3)) : n2(c3);
        }
        function u2(n3) {
          return 35 === n3 ? (e2.enter("atxHeadingSequence"), c2(n3)) : null === n3 || f(n3) ? (e2.exit("atxHeading"), t2(n3)) : p(n3) ? B(e2, u2, "whitespace")(n3) : (e2.enter("atxHeadingText"), a2(n3));
        }
        function c2(t3) {
          return 35 === t3 ? (e2.consume(t3), c2) : (e2.exit("atxHeadingSequence"), u2(t3));
        }
        function a2(t3) {
          return null === t3 || 35 === t3 || s(t3) ? (e2.exit("atxHeadingText"), u2(t3)) : (e2.consume(t3), a2);
        }
      }, resolve: function(e2, t2) {
        let n2, r2, i2 = e2.length - 2, o2 = 3;
        return "whitespace" === e2[o2][1].type && (o2 += 2), i2 - 2 > o2 && "whitespace" === e2[i2][1].type && (i2 -= 2), "atxHeadingSequence" === e2[i2][1].type && (o2 === i2 - 1 || i2 - 4 > o2 && "whitespace" === e2[i2 - 2][1].type) && (i2 -= o2 + 1 === i2 ? 2 : 4), i2 > o2 && (n2 = { type: "atxHeadingText", start: e2[o2][1].start, end: e2[i2][1].end }, r2 = { type: "chunkText", start: e2[o2][1].start, end: e2[i2][1].end, contentType: "text" }, W(e2, o2, i2 - o2 + 1, [["enter", n2, t2], ["enter", r2, t2], ["exit", r2, t2], ["exit", n2, t2]])), e2;
      } }, De = { name: "setextUnderline", tokenize: function(e2, t2, n2) {
        const r2 = this;
        let i2, o2, u2 = r2.events.length;
        for (; u2--; )
          if ("lineEnding" !== r2.events[u2][1].type && "linePrefix" !== r2.events[u2][1].type && "content" !== r2.events[u2][1].type) {
            o2 = "paragraph" === r2.events[u2][1].type;
            break;
          }
        return function(t3) {
          return r2.parser.lazy[r2.now().line] || !r2.interrupt && !o2 ? n2(t3) : (e2.enter("setextHeadingLine"), e2.enter("setextHeadingLineSequence"), i2 = t3, c2(t3));
        };
        function c2(t3) {
          return t3 === i2 ? (e2.consume(t3), c2) : (e2.exit("setextHeadingLineSequence"), B(e2, a2, "lineSuffix")(t3));
        }
        function a2(r3) {
          return null === r3 || f(r3) ? (e2.exit("setextHeadingLine"), t2(r3)) : n2(r3);
        }
      }, resolveTo: function(e2, t2) {
        let n2, r2, i2, o2 = e2.length;
        for (; o2--; )
          if ("enter" === e2[o2][0]) {
            if ("content" === e2[o2][1].type) {
              n2 = o2;
              break;
            }
            "paragraph" === e2[o2][1].type && (r2 = o2);
          } else
            "content" === e2[o2][1].type && e2.splice(o2, 1), i2 || "definition" !== e2[o2][1].type || (i2 = o2);
        const u2 = { type: "setextHeading", start: Object.assign({}, e2[r2][1].start), end: Object.assign({}, e2[e2.length - 1][1].end) };
        return e2[r2][1].type = "setextHeadingText", i2 ? (e2.splice(r2, 0, ["enter", u2, t2]), e2.splice(i2 + 1, 0, ["exit", e2[n2][1], t2]), e2[n2][1].end = Object.assign({}, e2[i2][1].end)) : e2[n2][1] = u2, e2.push(["exit", u2, t2]), e2;
      } }, Ce = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], Le = ["pre", "script", "style", "textarea"], Te = { name: "htmlFlow", tokenize: function(e2, t2, n2) {
        const i2 = this;
        let o2, c2, a2, l2, d2;
        return function(t3) {
          return e2.enter("htmlFlow"), e2.enter("htmlFlowData"), e2.consume(t3), m2;
        };
        function m2(u2) {
          return 33 === u2 ? (e2.consume(u2), g2) : 47 === u2 ? (e2.consume(u2), x2) : 63 === u2 ? (e2.consume(u2), o2 = 3, i2.interrupt ? t2 : O2) : r(u2) ? (e2.consume(u2), a2 = String.fromCharCode(u2), c2 = true, k2) : n2(u2);
        }
        function g2(u2) {
          return 45 === u2 ? (e2.consume(u2), o2 = 2, h2) : 91 === u2 ? (e2.consume(u2), o2 = 5, a2 = "CDATA[", l2 = 0, b2) : r(u2) ? (e2.consume(u2), o2 = 4, i2.interrupt ? t2 : O2) : n2(u2);
        }
        function h2(r2) {
          return 45 === r2 ? (e2.consume(r2), i2.interrupt ? t2 : O2) : n2(r2);
        }
        function b2(r2) {
          return r2 === a2.charCodeAt(l2++) ? (e2.consume(r2), l2 === a2.length ? i2.interrupt ? t2 : T2 : b2) : n2(r2);
        }
        function x2(t3) {
          return r(t3) ? (e2.consume(t3), a2 = String.fromCharCode(t3), k2) : n2(t3);
        }
        function k2(r2) {
          return null === r2 || 47 === r2 || 62 === r2 || s(r2) ? 47 !== r2 && c2 && Le.includes(a2.toLowerCase()) ? (o2 = 1, i2.interrupt ? t2(r2) : T2(r2)) : Ce.includes(a2.toLowerCase()) ? (o2 = 6, 47 === r2 ? (e2.consume(r2), v2) : i2.interrupt ? t2(r2) : T2(r2)) : (o2 = 7, i2.interrupt && !i2.parser.lazy[i2.now().line] ? n2(r2) : c2 ? w2(r2) : y2(r2)) : 45 === r2 || u(r2) ? (e2.consume(r2), a2 += String.fromCharCode(r2), k2) : n2(r2);
        }
        function v2(r2) {
          return 62 === r2 ? (e2.consume(r2), i2.interrupt ? t2 : T2) : n2(r2);
        }
        function y2(t3) {
          return p(t3) ? (e2.consume(t3), y2) : C2(t3);
        }
        function w2(t3) {
          return 47 === t3 ? (e2.consume(t3), C2) : 58 === t3 || 95 === t3 || r(t3) ? (e2.consume(t3), q2) : p(t3) ? (e2.consume(t3), w2) : C2(t3);
        }
        function q2(t3) {
          return 45 === t3 || 46 === t3 || 58 === t3 || 95 === t3 || u(t3) ? (e2.consume(t3), q2) : S2(t3);
        }
        function S2(t3) {
          return 61 === t3 ? (e2.consume(t3), F2) : p(t3) ? (e2.consume(t3), S2) : w2(t3);
        }
        function F2(t3) {
          return null === t3 || 60 === t3 || 61 === t3 || 62 === t3 || 96 === t3 ? n2(t3) : 34 === t3 || 39 === t3 ? (e2.consume(t3), d2 = t3, E2) : p(t3) ? (e2.consume(t3), F2) : (d2 = null, A2(t3));
        }
        function E2(t3) {
          return null === t3 || f(t3) ? n2(t3) : t3 === d2 ? (e2.consume(t3), D2) : (e2.consume(t3), E2);
        }
        function A2(t3) {
          return null === t3 || 34 === t3 || 39 === t3 || 60 === t3 || 61 === t3 || 62 === t3 || 96 === t3 || s(t3) ? S2(t3) : (e2.consume(t3), A2);
        }
        function D2(e3) {
          return 47 === e3 || 62 === e3 || p(e3) ? w2(e3) : n2(e3);
        }
        function C2(t3) {
          return 62 === t3 ? (e2.consume(t3), L2) : n2(t3);
        }
        function L2(t3) {
          return p(t3) ? (e2.consume(t3), L2) : null === t3 || f(t3) ? T2(t3) : n2(t3);
        }
        function T2(t3) {
          return 45 === t3 && 2 === o2 ? (e2.consume(t3), R2) : 60 === t3 && 1 === o2 ? (e2.consume(t3), M2) : 62 === t3 && 4 === o2 ? (e2.consume(t3), _2) : 63 === t3 && 3 === o2 ? (e2.consume(t3), O2) : 93 === t3 && 5 === o2 ? (e2.consume(t3), P2) : !f(t3) || 6 !== o2 && 7 !== o2 ? null === t3 || f(t3) ? z2(t3) : (e2.consume(t3), T2) : e2.check(ze, _2, z2)(t3);
        }
        function z2(t3) {
          return e2.exit("htmlFlowData"), I2(t3);
        }
        function I2(t3) {
          return null === t3 ? V2(t3) : f(t3) ? e2.attempt({ tokenize: B2, partial: true }, I2, V2)(t3) : (e2.enter("htmlFlowData"), T2(t3));
        }
        function B2(e3, t3, n3) {
          return function(t4) {
            return e3.enter("lineEnding"), e3.consume(t4), e3.exit("lineEnding"), r2;
          };
          function r2(e4) {
            return i2.parser.lazy[i2.now().line] ? n3(e4) : t3(e4);
          }
        }
        function R2(t3) {
          return 45 === t3 ? (e2.consume(t3), O2) : T2(t3);
        }
        function M2(t3) {
          return 47 === t3 ? (e2.consume(t3), a2 = "", N2) : T2(t3);
        }
        function N2(t3) {
          return 62 === t3 && Le.includes(a2.toLowerCase()) ? (e2.consume(t3), _2) : r(t3) && a2.length < 8 ? (e2.consume(t3), a2 += String.fromCharCode(t3), N2) : T2(t3);
        }
        function P2(t3) {
          return 93 === t3 ? (e2.consume(t3), O2) : T2(t3);
        }
        function O2(t3) {
          return 62 === t3 ? (e2.consume(t3), _2) : 45 === t3 && 2 === o2 ? (e2.consume(t3), O2) : T2(t3);
        }
        function _2(t3) {
          return null === t3 || f(t3) ? (e2.exit("htmlFlowData"), V2(t3)) : (e2.consume(t3), _2);
        }
        function V2(n3) {
          return e2.exit("htmlFlow"), t2(n3);
        }
      }, resolveTo: function(e2) {
        let t2 = e2.length;
        for (; t2-- && ("enter" !== e2[t2][0] || "htmlFlow" !== e2[t2][1].type); )
          ;
        return t2 > 1 && "linePrefix" === e2[t2 - 2][1].type && (e2[t2][1].start = e2[t2 - 2][1].start, e2[t2 + 1][1].start = e2[t2 - 2][1].start, e2.splice(t2 - 2, 2)), e2;
      }, concrete: true }, ze = { tokenize: function(e2, t2, n2) {
        return function(r2) {
          return e2.exit("htmlFlowData"), e2.enter("lineEndingBlank"), e2.consume(r2), e2.exit("lineEndingBlank"), e2.attempt(R, t2, n2);
        };
      }, partial: true }, Ie = { name: "codeFenced", tokenize: function(e2, t2, n2) {
        const r2 = this, i2 = { tokenize: function(e3, t3, n3) {
          let r3 = 0;
          return B(e3, function(t4) {
            return e3.enter("codeFencedFence"), e3.enter("codeFencedFenceSequence"), i3(t4);
          }, "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
          function i3(t4) {
            return t4 === a2 ? (e3.consume(t4), r3++, i3) : r3 < l2 ? n3(t4) : (e3.exit("codeFencedFenceSequence"), B(e3, o3, "whitespace")(t4));
          }
          function o3(r4) {
            return null === r4 || f(r4) ? (e3.exit("codeFencedFence"), t3(r4)) : n3(r4);
          }
        }, partial: true }, o2 = { tokenize: function(e3, t3, n3) {
          const r3 = this;
          return function(t4) {
            return e3.enter("lineEnding"), e3.consume(t4), e3.exit("lineEnding"), i3;
          };
          function i3(e4) {
            return r3.parser.lazy[r3.now().line] ? n3(e4) : t3(e4);
          }
        }, partial: true }, u2 = this.events[this.events.length - 1], c2 = u2 && "linePrefix" === u2[1].type ? u2[2].sliceSerialize(u2[1], true).length : 0;
        let a2, l2 = 0;
        return function(t3) {
          return e2.enter("codeFenced"), e2.enter("codeFencedFence"), e2.enter("codeFencedFenceSequence"), a2 = t3, p2(t3);
        };
        function p2(t3) {
          return t3 === a2 ? (e2.consume(t3), l2++, p2) : (e2.exit("codeFencedFenceSequence"), l2 < 3 ? n2(t3) : B(e2, d2, "whitespace")(t3));
        }
        function d2(t3) {
          return null === t3 || f(t3) ? b2(t3) : (e2.enter("codeFencedFenceInfo"), e2.enter("chunkString", { contentType: "string" }), m2(t3));
        }
        function m2(t3) {
          return null === t3 || s(t3) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceInfo"), B(e2, g2, "whitespace")(t3)) : 96 === t3 && t3 === a2 ? n2(t3) : (e2.consume(t3), m2);
        }
        function g2(t3) {
          return null === t3 || f(t3) ? b2(t3) : (e2.enter("codeFencedFenceMeta"), e2.enter("chunkString", { contentType: "string" }), h2(t3));
        }
        function h2(t3) {
          return null === t3 || f(t3) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceMeta"), b2(t3)) : 96 === t3 && t3 === a2 ? n2(t3) : (e2.consume(t3), h2);
        }
        function b2(n3) {
          return e2.exit("codeFencedFence"), r2.interrupt ? t2(n3) : x2(n3);
        }
        function x2(t3) {
          return null === t3 ? v2(t3) : f(t3) ? e2.attempt(o2, e2.attempt(i2, v2, c2 ? B(e2, x2, "linePrefix", c2 + 1) : x2), v2)(t3) : (e2.enter("codeFlowValue"), k2(t3));
        }
        function k2(t3) {
          return null === t3 || f(t3) ? (e2.exit("codeFlowValue"), x2(t3)) : (e2.consume(t3), k2);
        }
        function v2(n3) {
          return e2.exit("codeFenced"), t2(n3);
        }
      }, concrete: true }, Be = { AElig: "\xC6", AMP: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\u{1D504}", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\u{1D538}", ApplyFunction: "\u2061", Aring: "\xC5", Ascr: "\u{1D49C}", Assign: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", Bcy: "\u0411", Because: "\u2235", Bernoullis: "\u212C", Beta: "\u0392", Bfr: "\u{1D505}", Bopf: "\u{1D539}", Breve: "\u02D8", Bscr: "\u212C", Bumpeq: "\u224E", CHcy: "\u0427", COPY: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", Cayleys: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", CenterDot: "\xB7", Cfr: "\u212D", Chi: "\u03A7", CircleDot: "\u2299", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", Colon: "\u2237", Colone: "\u2A74", Congruent: "\u2261", Conint: "\u222F", ContourIntegral: "\u222E", Copf: "\u2102", Coproduct: "\u2210", CounterClockwiseContourIntegral: "\u2233", Cross: "\u2A2F", Cscr: "\u{1D49E}", Cup: "\u22D3", CupCap: "\u224D", DD: "\u2145", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", Delta: "\u0394", Dfr: "\u{1D507}", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", Diamond: "\u22C4", DifferentialD: "\u2146", Dopf: "\u{1D53B}", Dot: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", Downarrow: "\u21D3", Dscr: "\u{1D49F}", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\u{1D508}", Egrave: "\xC8", Element: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\u{1D53C}", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", Equilibrium: "\u21CC", Escr: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", ExponentialE: "\u2147", Fcy: "\u0424", Ffr: "\u{1D509}", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", Fopf: "\u{1D53D}", ForAll: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\u{1D50A}", Gg: "\u22D9", Gopf: "\u{1D53E}", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", Gt: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", HilbertSpace: "\u210B", Hopf: "\u210D", HorizontalLine: "\u2500", Hscr: "\u210B", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Igrave: "\xCC", Im: "\u2111", Imacr: "\u012A", ImaginaryI: "\u2148", Implies: "\u21D2", Int: "\u222C", Integral: "\u222B", Intersection: "\u22C2", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", Iogon: "\u012E", Iopf: "\u{1D540}", Iota: "\u0399", Iscr: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\u{1D50D}", Jopf: "\u{1D541}", Jscr: "\u{1D4A5}", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\u{1D50E}", Kopf: "\u{1D542}", Kscr: "\u{1D4A6}", LJcy: "\u0409", LT: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Larr: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", LeftRightArrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", Leftarrow: "\u21D0", Leftrightarrow: "\u21D4", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", Lfr: "\u{1D50F}", Ll: "\u22D8", Lleftarrow: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", LongLeftRightArrow: "\u27F7", LongRightArrow: "\u27F6", Longleftarrow: "\u27F8", Longleftrightarrow: "\u27FA", Longrightarrow: "\u27F9", Lopf: "\u{1D543}", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", Lscr: "\u2112", Lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", MinusPlus: "\u2213", Mopf: "\u{1D544}", Mscr: "\u2133", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", Nfr: "\u{1D511}", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", Nscr: "\u{1D4A9}", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\u{1D512}", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", Omicron: "\u039F", Oopf: "\u{1D546}", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", Or: "\u2A54", Oscr: "\u{1D4AA}", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", Pcy: "\u041F", Pfr: "\u{1D513}", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", Poincareplane: "\u210C", Popf: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", Prime: "\u2033", Product: "\u220F", Proportion: "\u2237", Proportional: "\u221D", Pscr: "\u{1D4AB}", Psi: "\u03A8", QUOT: '"', Qfr: "\u{1D514}", Qopf: "\u211A", Qscr: "\u{1D4AC}", RBarr: "\u2910", REG: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", Rfr: "\u211C", Rho: "\u03A1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", Rightarrow: "\u21D2", Ropf: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", Rscr: "\u211B", Rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\u{1D516}", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", Sopf: "\u{1D54A}", Sqrt: "\u221A", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", Sscr: "\u{1D4AE}", Star: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", SuchThat: "\u220B", Sum: "\u2211", Sup: "\u22D1", Superset: "\u2283", SupersetEqual: "\u2287", Supset: "\u22D1", THORN: "\xDE", TRADE: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\u{1D517}", Therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", Topf: "\u{1D54B}", TripleDot: "\u20DB", Tscr: "\u{1D4AF}", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\u{1D518}", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", Uopf: "\u{1D54C}", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", UpTee: "\u22A5", UpTeeArrow: "\u21A5", Uparrow: "\u21D1", Updownarrow: "\u21D5", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\u{1D4B0}", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", Vopf: "\u{1D54D}", Vscr: "\u{1D4B1}", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", Wfr: "\u{1D51A}", Wopf: "\u{1D54E}", Wscr: "\u{1D4B2}", Xfr: "\u{1D51B}", Xi: "\u039E", Xopf: "\u{1D54F}", Xscr: "\u{1D4B3}", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\u{1D51C}", Yopf: "\u{1D550}", Yscr: "\u{1D4B4}", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", ZeroWidthSpace: "\u200B", Zeta: "\u0396", Zfr: "\u2128", Zopf: "\u2124", Zscr: "\u{1D4B5}", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acute: "\xB4", acy: "\u0430", aelig: "\xE6", af: "\u2061", afr: "\u{1D51E}", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", amp: "&", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", aopf: "\u{1D552}", ap: "\u2248", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", apid: "\u224B", apos: "'", approx: "\u2248", approxeq: "\u224A", aring: "\xE5", ascr: "\u{1D4B6}", ast: "*", asymp: "\u2248", asympeq: "\u224D", atilde: "\xE3", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", beta: "\u03B2", beth: "\u2136", between: "\u226C", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxh: "\u2500", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", bprime: "\u2035", breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", bumpeq: "\u224F", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cedil: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", cfr: "\u{1D520}", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledR: "\xAE", circledS: "\u24C8", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", conint: "\u222E", copf: "\u{1D554}", coprod: "\u2210", copy: "\xA9", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dArr: "\u21D3", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", darr: "\u2193", dash: "\u2010", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", dcy: "\u0434", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", ddotseq: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}", dharl: "\u21C3", dharr: "\u21C2", diam: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", dot: "\u02D9", doteq: "\u2250", doteqdot: "\u2251", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", downarrow: "\u2193", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eDDot: "\u2A77", eDot: "\u2251", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", ecirc: "\xEA", ecolon: "\u2255", ecy: "\u044D", edot: "\u0117", ee: "\u2147", efDot: "\u2252", efr: "\u{1D522}", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", equals: "=", equest: "\u225F", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", erarr: "\u2971", escr: "\u212F", esdot: "\u2250", esim: "\u2242", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", expectation: "\u2130", exponentiale: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\u{1D523}", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", gE: "\u2267", gEl: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gammad: "\u03DD", gap: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", ge: "\u2265", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", gl: "\u2277", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\u{1D558}", grave: "`", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hArr: "\u21D4", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", hbar: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", horbar: "\u2015", hscr: "\u{1D4BD}", hslash: "\u210F", hstrok: "\u0127", hybull: "\u2043", hyphen: "\u2010", iacute: "\xED", ic: "\u2063", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", image: "\u2111", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", intcal: "\u22BA", integers: "\u2124", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\u{1D55A}", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", isin: "\u2208", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\u{1D527}", jmath: "\u0237", jopf: "\u{1D55B}", jscr: "\u{1D4BF}", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\u{1D528}", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\u{1D55C}", kscr: "\u{1D4C0}", lAarr: "\u21DA", lArr: "\u21D0", lAtail: "\u291B", lBarr: "\u290E", lE: "\u2266", lEg: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", laquo: "\xAB", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lceil: "\u2308", lcub: "{", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leftarrow: "\u2190", leftarrowtail: "\u21A2", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", leftthreetimes: "\u22CB", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", lessgtr: "\u2276", lesssim: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", measuredangle: "\u2221", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", mstpos: "\u223E", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nGtv: "\u226B\u0338", nLeftarrow: "\u21CD", nLeftrightarrow: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nLtv: "\u226A\u0338", nRightarrow: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nabla: "\u2207", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", neArr: "\u21D7", nearhk: "\u2924", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", nexist: "\u2204", nexists: "\u2204", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", ngsim: "\u2275", ngt: "\u226F", ngtr: "\u226F", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", nlArr: "\u21CD", nlE: "\u2266\u0338", nlarr: "\u219A", nldr: "\u2025", nle: "\u2270", nleftarrow: "\u219A", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nlsim: "\u2274", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nmid: "\u2224", nopf: "\u{1D55F}", not: "\xAC", notin: "\u2209", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", oS: "\u24C8", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", ocirc: "\xF4", ocy: "\u043E", odash: "\u229D", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\u{1D52C}", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", oopf: "\u{1D560}", opar: "\u29B7", operp: "\u29B9", oplus: "\u2295", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oscr: "\u2134", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimes: "\u2297", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\u{1D52D}", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", pointint: "\u2A15", popf: "\u{1D561}", pound: "\xA3", pr: "\u227A", prE: "\u2AB3", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", primes: "\u2119", prnE: "\u2AB5", prnap: "\u2AB9", prnsim: "\u22E8", prod: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\u{1D4C5}", psi: "\u03C8", puncsp: "\u2008", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", qprime: "\u2057", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', rAarr: "\u21DB", rArr: "\u21D2", rAtail: "\u291C", rBarr: "\u290F", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rceil: "\u2309", rcub: "}", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", reg: "\xAE", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", rightarrow: "\u2192", rightarrowtail: "\u21A3", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", rightthreetimes: "\u22CC", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", rsaquo: "\u203A", rscr: "\u{1D4C7}", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", sbquo: "\u201A", sc: "\u227B", scE: "\u2AB4", scap: "\u2AB8", scaron: "\u0161", sccue: "\u227D", sce: "\u2AB0", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", scnap: "\u2ABA", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", seArr: "\u21D8", searhk: "\u2925", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shortmid: "\u2223", shortparallel: "\u2225", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", subE: "\u2AC5", subdot: "\u2ABD", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", supE: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swarhk: "\u2926", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tbrk: "\u23B4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", thorn: "\xFE", tilde: "\u02DC", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uArr: "\u21D1", uHar: "\u2963", uacute: "\xFA", uarr: "\u2191", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udarr: "\u21C5", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", ufr: "\u{1D532}", ugrave: "\xF9", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uml: "\xA8", uogon: "\u0173", uopf: "\u{1D566}", uparrow: "\u2191", updownarrow: "\u2195", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", upsi: "\u03C5", upsih: "\u03D2", upsilon: "\u03C5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\u{1D4CA}", utdot: "\u22F0", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uuml: "\xFC", uwangle: "\u29A7", vArr: "\u21D5", vBar: "\u2AE8", vBarv: "\u2AE9", vDash: "\u22A8", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vcy: "\u0432", vdash: "\u22A2", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", vert: "|", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", wfr: "\u{1D534}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\u{1D536}", yicy: "\u0457", yopf: "\u{1D56A}", yscr: "\u{1D4CE}", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeetrf: "\u2128", zeta: "\u03B6", zfr: "\u{1D537}", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" }, Re = {}.hasOwnProperty, Me = { name: "characterReference", tokenize: function(e2, t2, n2) {
        const r2 = this;
        let c2, a2, l2 = 0;
        return function(t3) {
          return e2.enter("characterReference"), e2.enter("characterReferenceMarker"), e2.consume(t3), e2.exit("characterReferenceMarker"), s2;
        };
        function s2(t3) {
          return 35 === t3 ? (e2.enter("characterReferenceMarkerNumeric"), e2.consume(t3), e2.exit("characterReferenceMarkerNumeric"), f2) : (e2.enter("characterReferenceValue"), c2 = 31, a2 = u, p2(t3));
        }
        function f2(t3) {
          return 88 === t3 || 120 === t3 ? (e2.enter("characterReferenceMarkerHexadecimal"), e2.consume(t3), e2.exit("characterReferenceMarkerHexadecimal"), e2.enter("characterReferenceValue"), c2 = 6, a2 = o, p2) : (e2.enter("characterReferenceValue"), c2 = 7, a2 = i, p2(t3));
        }
        function p2(i2) {
          let o2;
          return 59 === i2 && l2 ? (o2 = e2.exit("characterReferenceValue"), a2 !== u || function(e3) {
            return !!Re.call(Be, e3) && Be[e3];
          }(r2.sliceSerialize(o2)) ? (e2.enter("characterReferenceMarker"), e2.consume(i2), e2.exit("characterReferenceMarker"), e2.exit("characterReference"), t2) : n2(i2)) : a2(i2) && l2++ < c2 ? (e2.consume(i2), p2) : n2(i2);
        }
      } }, Ne = { name: "characterEscape", tokenize: function(e2, t2, n2) {
        return function(t3) {
          return e2.enter("characterEscape"), e2.enter("escapeMarker"), e2.consume(t3), e2.exit("escapeMarker"), r2;
        };
        function r2(r3) {
          return c(r3) ? (e2.enter("characterEscapeValue"), e2.consume(r3), e2.exit("characterEscapeValue"), e2.exit("characterEscape"), t2) : n2(r3);
        }
      } }, Pe = { name: "lineEnding", tokenize: function(e2, t2) {
        return function(n2) {
          return e2.enter("lineEnding"), e2.consume(n2), e2.exit("lineEnding"), B(e2, t2, "linePrefix");
        };
      } }, Oe = { name: "labelEnd", tokenize: function(e2, t2, n2) {
        const r2 = this;
        let i2, o2, u2 = r2.events.length;
        for (; u2--; )
          if (("labelImage" === r2.events[u2][1].type || "labelLink" === r2.events[u2][1].type) && !r2.events[u2][1]._balanced) {
            i2 = r2.events[u2][1];
            break;
          }
        return function(t3) {
          return i2 ? i2._inactive ? a2(t3) : (o2 = r2.parser.defined.includes(M(r2.sliceSerialize({ start: i2.end, end: r2.now() }))), e2.enter("labelEnd"), e2.enter("labelMarker"), e2.consume(t3), e2.exit("labelMarker"), e2.exit("labelEnd"), c2) : n2(t3);
        };
        function c2(n3) {
          return 40 === n3 ? e2.attempt(_e, t2, o2 ? t2 : a2)(n3) : 91 === n3 ? e2.attempt(Ve, t2, o2 ? e2.attempt(He, t2, a2) : a2)(n3) : o2 ? t2(n3) : a2(n3);
        }
        function a2(e3) {
          return i2._balanced = true, n2(e3);
        }
      }, resolveTo: function(e2, t2) {
        let n2, r2, i2, o2, u2 = e2.length, c2 = 0;
        for (; u2--; )
          if (n2 = e2[u2][1], r2) {
            if ("link" === n2.type || "labelLink" === n2.type && n2._inactive)
              break;
            "enter" === e2[u2][0] && "labelLink" === n2.type && (n2._inactive = true);
          } else if (i2) {
            if ("enter" === e2[u2][0] && ("labelImage" === n2.type || "labelLink" === n2.type) && !n2._balanced && (r2 = u2, "labelLink" !== n2.type)) {
              c2 = 2;
              break;
            }
          } else
            "labelEnd" === n2.type && (i2 = u2);
        const a2 = { type: "labelLink" === e2[r2][1].type ? "link" : "image", start: Object.assign({}, e2[r2][1].start), end: Object.assign({}, e2[e2.length - 1][1].end) }, l2 = { type: "label", start: Object.assign({}, e2[r2][1].start), end: Object.assign({}, e2[i2][1].end) }, s2 = { type: "labelText", start: Object.assign({}, e2[r2 + c2 + 2][1].end), end: Object.assign({}, e2[i2 - 2][1].start) };
        return o2 = [["enter", a2, t2], ["enter", l2, t2]], o2 = Z(o2, e2.slice(r2 + 1, r2 + c2 + 3)), o2 = Z(o2, [["enter", s2, t2]]), o2 = Z(o2, pe(t2.parser.constructs.insideSpan.null, e2.slice(r2 + c2 + 4, i2 - 3), t2)), o2 = Z(o2, [["exit", s2, t2], e2[i2 - 2], e2[i2 - 1], ["exit", l2, t2]]), o2 = Z(o2, e2.slice(i2 + 1)), o2 = Z(o2, [["exit", a2, t2]]), W(e2, r2, e2.length, o2), e2;
      }, resolveAll: function(e2) {
        let t2, n2 = -1;
        for (; ++n2 < e2.length; )
          t2 = e2[n2][1], "labelImage" !== t2.type && "labelLink" !== t2.type && "labelEnd" !== t2.type || (e2.splice(n2 + 1, "labelImage" === t2.type ? 4 : 2), t2.type = "data", n2++);
        return e2;
      } }, _e = { tokenize: function(e2, t2, n2) {
        return function(t3) {
          return e2.enter("resource"), e2.enter("resourceMarker"), e2.consume(t3), e2.exit("resourceMarker"), we(e2, r2);
        };
        function r2(t3) {
          return 41 === t3 ? u2(t3) : ke(e2, i2, n2, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(t3);
        }
        function i2(t3) {
          return s(t3) ? we(e2, o2)(t3) : u2(t3);
        }
        function o2(t3) {
          return 34 === t3 || 39 === t3 || 40 === t3 ? ye(e2, we(e2, u2), n2, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(t3) : u2(t3);
        }
        function u2(r3) {
          return 41 === r3 ? (e2.enter("resourceMarker"), e2.consume(r3), e2.exit("resourceMarker"), e2.exit("resource"), t2) : n2(r3);
        }
      } }, Ve = { tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          return ve.call(r2, e2, i2, n2, "reference", "referenceMarker", "referenceString")(t3);
        };
        function i2(e3) {
          return r2.parser.defined.includes(M(r2.sliceSerialize(r2.events[r2.events.length - 1][1]).slice(1, -1))) ? t2(e3) : n2(e3);
        }
      } }, He = { tokenize: function(e2, t2, n2) {
        return function(t3) {
          return e2.enter("reference"), e2.enter("referenceMarker"), e2.consume(t3), e2.exit("referenceMarker"), r2;
        };
        function r2(r3) {
          return 93 === r3 ? (e2.enter("referenceMarker"), e2.consume(r3), e2.exit("referenceMarker"), e2.exit("reference"), t2) : n2(r3);
        }
      } }, je = { name: "labelStartImage", tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          return e2.enter("labelImage"), e2.enter("labelImageMarker"), e2.consume(t3), e2.exit("labelImageMarker"), i2;
        };
        function i2(t3) {
          return 91 === t3 ? (e2.enter("labelMarker"), e2.consume(t3), e2.exit("labelMarker"), e2.exit("labelImage"), o2) : n2(t3);
        }
        function o2(e3) {
          return 94 === e3 && "_hiddenFootnoteSupport" in r2.parser.constructs ? n2(e3) : t2(e3);
        }
      }, resolveAll: Oe.resolveAll };
      function Ue(e2) {
        return null === e2 || s(e2) || d(e2) ? 1 : m(e2) ? 2 : void 0;
      }
      const Ge = { name: "attention", tokenize: function(e2, t2) {
        const n2 = this.parser.constructs.attentionMarkers.null, r2 = this.previous, i2 = Ue(r2);
        let o2;
        return function(t3) {
          return e2.enter("attentionSequence"), o2 = t3, u2(t3);
        };
        function u2(c2) {
          if (c2 === o2)
            return e2.consume(c2), u2;
          const a2 = e2.exit("attentionSequence"), l2 = Ue(c2), s2 = !l2 || 2 === l2 && i2 || n2.includes(c2), f2 = !i2 || 2 === i2 && l2 || n2.includes(r2);
          return a2._open = Boolean(42 === o2 ? s2 : s2 && (i2 || !f2)), a2._close = Boolean(42 === o2 ? f2 : f2 && (l2 || !s2)), t2(c2);
        }
      }, resolveAll: function(e2, t2) {
        let n2, r2, i2, o2, u2, c2, a2, l2, s2 = -1;
        for (; ++s2 < e2.length; )
          if ("enter" === e2[s2][0] && "attentionSequence" === e2[s2][1].type && e2[s2][1]._close) {
            for (n2 = s2; n2--; )
              if ("exit" === e2[n2][0] && "attentionSequence" === e2[n2][1].type && e2[n2][1]._open && t2.sliceSerialize(e2[n2][1]).charCodeAt(0) === t2.sliceSerialize(e2[s2][1]).charCodeAt(0)) {
                if ((e2[n2][1]._close || e2[s2][1]._open) && (e2[s2][1].end.offset - e2[s2][1].start.offset) % 3 && !((e2[n2][1].end.offset - e2[n2][1].start.offset + e2[s2][1].end.offset - e2[s2][1].start.offset) % 3))
                  continue;
                c2 = e2[n2][1].end.offset - e2[n2][1].start.offset > 1 && e2[s2][1].end.offset - e2[s2][1].start.offset > 1 ? 2 : 1;
                const f2 = Object.assign({}, e2[n2][1].end), p2 = Object.assign({}, e2[s2][1].start);
                Qe(f2, -c2), Qe(p2, c2), o2 = { type: c2 > 1 ? "strongSequence" : "emphasisSequence", start: f2, end: Object.assign({}, e2[n2][1].end) }, u2 = { type: c2 > 1 ? "strongSequence" : "emphasisSequence", start: Object.assign({}, e2[s2][1].start), end: p2 }, i2 = { type: c2 > 1 ? "strongText" : "emphasisText", start: Object.assign({}, e2[n2][1].end), end: Object.assign({}, e2[s2][1].start) }, r2 = { type: c2 > 1 ? "strong" : "emphasis", start: Object.assign({}, o2.start), end: Object.assign({}, u2.end) }, e2[n2][1].end = Object.assign({}, o2.start), e2[s2][1].start = Object.assign({}, u2.end), a2 = [], e2[n2][1].end.offset - e2[n2][1].start.offset && (a2 = Z(a2, [["enter", e2[n2][1], t2], ["exit", e2[n2][1], t2]])), a2 = Z(a2, [["enter", r2, t2], ["enter", o2, t2], ["exit", o2, t2], ["enter", i2, t2]]), a2 = Z(a2, pe(t2.parser.constructs.insideSpan.null, e2.slice(n2 + 1, s2), t2)), a2 = Z(a2, [["exit", i2, t2], ["enter", u2, t2], ["exit", u2, t2], ["exit", r2, t2]]), e2[s2][1].end.offset - e2[s2][1].start.offset ? (l2 = 2, a2 = Z(a2, [["enter", e2[s2][1], t2], ["exit", e2[s2][1], t2]])) : l2 = 0, W(e2, n2 - 1, s2 - n2 + 3, a2), s2 = n2 + a2.length - l2 - 2;
                break;
              }
          }
        for (s2 = -1; ++s2 < e2.length; )
          "attentionSequence" === e2[s2][1].type && (e2[s2][1].type = "data");
        return e2;
      } };
      function Qe(e2, t2) {
        e2.column += t2, e2.offset += t2, e2._bufferIndex += t2;
      }
      const We = { name: "autolink", tokenize: function(e2, t2, n2) {
        let i2 = 1;
        return function(t3) {
          return e2.enter("autolink"), e2.enter("autolinkMarker"), e2.consume(t3), e2.exit("autolinkMarker"), e2.enter("autolinkProtocol"), o2;
        };
        function o2(t3) {
          return r(t3) ? (e2.consume(t3), c2) : a(t3) ? p2(t3) : n2(t3);
        }
        function c2(e3) {
          return 43 === e3 || 45 === e3 || 46 === e3 || u(e3) ? s2(e3) : p2(e3);
        }
        function s2(t3) {
          return 58 === t3 ? (e2.consume(t3), f2) : (43 === t3 || 45 === t3 || 46 === t3 || u(t3)) && i2++ < 32 ? (e2.consume(t3), s2) : p2(t3);
        }
        function f2(t3) {
          return 62 === t3 ? (e2.exit("autolinkProtocol"), h2(t3)) : null === t3 || 32 === t3 || 60 === t3 || l(t3) ? n2(t3) : (e2.consume(t3), f2);
        }
        function p2(t3) {
          return 64 === t3 ? (e2.consume(t3), i2 = 0, d2) : a(t3) ? (e2.consume(t3), p2) : n2(t3);
        }
        function d2(e3) {
          return u(e3) ? m2(e3) : n2(e3);
        }
        function m2(t3) {
          return 46 === t3 ? (e2.consume(t3), i2 = 0, d2) : 62 === t3 ? (e2.exit("autolinkProtocol").type = "autolinkEmail", h2(t3)) : g2(t3);
        }
        function g2(t3) {
          return (45 === t3 || u(t3)) && i2++ < 63 ? (e2.consume(t3), 45 === t3 ? g2 : m2) : n2(t3);
        }
        function h2(n3) {
          return e2.enter("autolinkMarker"), e2.consume(n3), e2.exit("autolinkMarker"), e2.exit("autolink"), t2;
        }
      } }, Ze = { name: "htmlText", tokenize: function(e2, t2, n2) {
        const i2 = this;
        let o2, c2, a2, l2;
        return function(t3) {
          return e2.enter("htmlText"), e2.enter("htmlTextData"), e2.consume(t3), d2;
        };
        function d2(t3) {
          return 33 === t3 ? (e2.consume(t3), m2) : 47 === t3 ? (e2.consume(t3), A2) : 63 === t3 ? (e2.consume(t3), F2) : r(t3) ? (e2.consume(t3), L2) : n2(t3);
        }
        function m2(t3) {
          return 45 === t3 ? (e2.consume(t3), g2) : 91 === t3 ? (e2.consume(t3), c2 = "CDATA[", a2 = 0, v2) : r(t3) ? (e2.consume(t3), S2) : n2(t3);
        }
        function g2(t3) {
          return 45 === t3 ? (e2.consume(t3), h2) : n2(t3);
        }
        function h2(t3) {
          return null === t3 || 62 === t3 ? n2(t3) : 45 === t3 ? (e2.consume(t3), b2) : x2(t3);
        }
        function b2(e3) {
          return null === e3 || 62 === e3 ? n2(e3) : x2(e3);
        }
        function x2(t3) {
          return null === t3 ? n2(t3) : 45 === t3 ? (e2.consume(t3), k2) : f(t3) ? (l2 = x2, O2(t3)) : (e2.consume(t3), x2);
        }
        function k2(t3) {
          return 45 === t3 ? (e2.consume(t3), V2) : x2(t3);
        }
        function v2(t3) {
          return t3 === c2.charCodeAt(a2++) ? (e2.consume(t3), a2 === c2.length ? y2 : v2) : n2(t3);
        }
        function y2(t3) {
          return null === t3 ? n2(t3) : 93 === t3 ? (e2.consume(t3), w2) : f(t3) ? (l2 = y2, O2(t3)) : (e2.consume(t3), y2);
        }
        function w2(t3) {
          return 93 === t3 ? (e2.consume(t3), q2) : y2(t3);
        }
        function q2(t3) {
          return 62 === t3 ? V2(t3) : 93 === t3 ? (e2.consume(t3), q2) : y2(t3);
        }
        function S2(t3) {
          return null === t3 || 62 === t3 ? V2(t3) : f(t3) ? (l2 = S2, O2(t3)) : (e2.consume(t3), S2);
        }
        function F2(t3) {
          return null === t3 ? n2(t3) : 63 === t3 ? (e2.consume(t3), E2) : f(t3) ? (l2 = F2, O2(t3)) : (e2.consume(t3), F2);
        }
        function E2(e3) {
          return 62 === e3 ? V2(e3) : F2(e3);
        }
        function A2(t3) {
          return r(t3) ? (e2.consume(t3), D2) : n2(t3);
        }
        function D2(t3) {
          return 45 === t3 || u(t3) ? (e2.consume(t3), D2) : C2(t3);
        }
        function C2(t3) {
          return f(t3) ? (l2 = C2, O2(t3)) : p(t3) ? (e2.consume(t3), C2) : V2(t3);
        }
        function L2(t3) {
          return 45 === t3 || u(t3) ? (e2.consume(t3), L2) : 47 === t3 || 62 === t3 || s(t3) ? T2(t3) : n2(t3);
        }
        function T2(t3) {
          return 47 === t3 ? (e2.consume(t3), V2) : 58 === t3 || 95 === t3 || r(t3) ? (e2.consume(t3), z2) : f(t3) ? (l2 = T2, O2(t3)) : p(t3) ? (e2.consume(t3), T2) : V2(t3);
        }
        function z2(t3) {
          return 45 === t3 || 46 === t3 || 58 === t3 || 95 === t3 || u(t3) ? (e2.consume(t3), z2) : I2(t3);
        }
        function I2(t3) {
          return 61 === t3 ? (e2.consume(t3), R2) : f(t3) ? (l2 = I2, O2(t3)) : p(t3) ? (e2.consume(t3), I2) : T2(t3);
        }
        function R2(t3) {
          return null === t3 || 60 === t3 || 61 === t3 || 62 === t3 || 96 === t3 ? n2(t3) : 34 === t3 || 39 === t3 ? (e2.consume(t3), o2 = t3, M2) : f(t3) ? (l2 = R2, O2(t3)) : p(t3) ? (e2.consume(t3), R2) : (e2.consume(t3), o2 = void 0, P2);
        }
        function M2(t3) {
          return t3 === o2 ? (e2.consume(t3), N2) : null === t3 ? n2(t3) : f(t3) ? (l2 = M2, O2(t3)) : (e2.consume(t3), M2);
        }
        function N2(e3) {
          return 62 === e3 || 47 === e3 || s(e3) ? T2(e3) : n2(e3);
        }
        function P2(t3) {
          return null === t3 || 34 === t3 || 39 === t3 || 60 === t3 || 61 === t3 || 96 === t3 ? n2(t3) : 62 === t3 || s(t3) ? T2(t3) : (e2.consume(t3), P2);
        }
        function O2(t3) {
          return e2.exit("htmlTextData"), e2.enter("lineEnding"), e2.consume(t3), e2.exit("lineEnding"), B(e2, _2, "linePrefix", i2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
        }
        function _2(t3) {
          return e2.enter("htmlTextData"), l2(t3);
        }
        function V2(r2) {
          return 62 === r2 ? (e2.consume(r2), e2.exit("htmlTextData"), e2.exit("htmlText"), t2) : n2(r2);
        }
      } }, Je = { name: "labelStartLink", tokenize: function(e2, t2, n2) {
        const r2 = this;
        return function(t3) {
          return e2.enter("labelLink"), e2.enter("labelMarker"), e2.consume(t3), e2.exit("labelMarker"), e2.exit("labelLink"), i2;
        };
        function i2(e3) {
          return 94 === e3 && "_hiddenFootnoteSupport" in r2.parser.constructs ? n2(e3) : t2(e3);
        }
      }, resolveAll: Oe.resolveAll }, Ye = { name: "hardBreakEscape", tokenize: function(e2, t2, n2) {
        return function(t3) {
          return e2.enter("hardBreakEscape"), e2.enter("escapeMarker"), e2.consume(t3), r2;
        };
        function r2(r3) {
          return f(r3) ? (e2.exit("escapeMarker"), e2.exit("hardBreakEscape"), t2(r3)) : n2(r3);
        }
      } }, Ke = { name: "codeText", tokenize: function(e2, t2, n2) {
        let r2, i2, o2 = 0;
        return function(t3) {
          return e2.enter("codeText"), e2.enter("codeTextSequence"), u2(t3);
        };
        function u2(t3) {
          return 96 === t3 ? (e2.consume(t3), o2++, u2) : (e2.exit("codeTextSequence"), c2(t3));
        }
        function c2(t3) {
          return null === t3 ? n2(t3) : 96 === t3 ? (i2 = e2.enter("codeTextSequence"), r2 = 0, l2(t3)) : 32 === t3 ? (e2.enter("space"), e2.consume(t3), e2.exit("space"), c2) : f(t3) ? (e2.enter("lineEnding"), e2.consume(t3), e2.exit("lineEnding"), c2) : (e2.enter("codeTextData"), a2(t3));
        }
        function a2(t3) {
          return null === t3 || 32 === t3 || 96 === t3 || f(t3) ? (e2.exit("codeTextData"), c2(t3)) : (e2.consume(t3), a2);
        }
        function l2(n3) {
          return 96 === n3 ? (e2.consume(n3), r2++, l2) : r2 === o2 ? (e2.exit("codeTextSequence"), e2.exit("codeText"), t2(n3)) : (i2.type = "codeTextData", a2(n3));
        }
      }, resolve: function(e2) {
        let t2, n2, r2 = e2.length - 4, i2 = 3;
        if (!("lineEnding" !== e2[i2][1].type && "space" !== e2[i2][1].type || "lineEnding" !== e2[r2][1].type && "space" !== e2[r2][1].type)) {
          for (t2 = i2; ++t2 < r2; )
            if ("codeTextData" === e2[t2][1].type) {
              e2[i2][1].type = "codeTextPadding", e2[r2][1].type = "codeTextPadding", i2 += 2, r2 -= 2;
              break;
            }
        }
        for (t2 = i2 - 1, r2++; ++t2 <= r2; )
          void 0 === n2 ? t2 !== r2 && "lineEnding" !== e2[t2][1].type && (n2 = t2) : t2 !== r2 && "lineEnding" !== e2[t2][1].type || (e2[n2][1].type = "codeTextData", t2 !== n2 + 2 && (e2[n2][1].end = e2[t2 - 1][1].end, e2.splice(n2 + 2, t2 - n2 - 2), r2 -= t2 - n2 - 2, t2 = n2 + 2), n2 = void 0);
        return e2;
      }, previous: function(e2) {
        return 96 !== e2 || "characterEscape" === this.events[this.events.length - 1][1].type;
      } }, Xe = { 42: ge, 43: ge, 45: ge, 48: ge, 49: ge, 50: ge, 51: ge, 52: ge, 53: ge, 54: ge, 55: ge, 56: ge, 57: ge, 62: xe }, $e = { 91: qe }, et = { [-2]: Fe, [-1]: Fe, 32: Fe }, tt = { 35: Ae, 42: me, 45: [De, me], 60: Te, 61: De, 95: me, 96: Ie, 126: Ie }, nt = { 38: Me, 92: Ne }, rt = { [-5]: Pe, [-4]: Pe, [-3]: Pe, 33: je, 38: Me, 42: Ge, 60: [We, Ze], 91: Je, 92: [Ye, Ne], 93: Oe, 95: Ge, 96: Ke }, it = { null: [Ge, ue] }, ot = { null: [42, 95] }, ut = { null: [] };
      function ct(e2 = {}) {
        const t2 = { defined: [], lazy: {}, constructs: function(e3) {
          const t3 = {};
          let n2 = -1;
          for (; ++n2 < e3.length; )
            Y(t3, e3[n2]);
          return t3;
        }([n].concat(e2.extensions || [])), content: r2(X), document: r2($), flow: r2(oe), string: r2(ce), text: r2(ae) };
        return t2;
        function r2(e3) {
          return function(n2) {
            return de(t2, e3, n2);
          };
        }
      }
      function at(e2) {
        for (; !te(e2); )
          ;
        return e2;
      }
      const lt = /[\0\t\n\r]/g;
      function st() {
        let e2, t2 = 1, n2 = "", r2 = true;
        return function(i2, o2, u2) {
          const c2 = [];
          let a2, l2, s2, f2, p2;
          for (i2 = n2 + i2.toString(o2), s2 = 0, n2 = "", r2 && (65279 === i2.charCodeAt(0) && s2++, r2 = void 0); s2 < i2.length; ) {
            if (lt.lastIndex = s2, a2 = lt.exec(i2), f2 = a2 && void 0 !== a2.index ? a2.index : i2.length, p2 = i2.charCodeAt(f2), !a2) {
              n2 = i2.slice(s2);
              break;
            }
            if (10 === p2 && s2 === f2 && e2)
              c2.push(-3), e2 = void 0;
            else
              switch (e2 && (c2.push(-5), e2 = void 0), s2 < f2 && (c2.push(i2.slice(s2, f2)), t2 += f2 - s2), p2) {
                case 0:
                  c2.push(65533), t2++;
                  break;
                case 9:
                  for (l2 = 4 * Math.ceil(t2 / 4), c2.push(-2); t2++ < l2; )
                    c2.push(-1);
                  break;
                case 10:
                  c2.push(-4), t2 = 1;
                  break;
                default:
                  e2 = true, t2 = 1;
              }
            s2 = f2 + 1;
          }
          return u2 && (e2 && c2.push(-5), n2 && c2.push(n2), c2.push(null)), c2;
        };
      }
      var ft = exports;
      for (var pt in t)
        ft[pt] = t[pt];
      t.__esModule && Object.defineProperty(ft, "__esModule", { value: true });
    })();
  }
});

// node_modules/markdownlint/helpers/micromark.cjs
var require_micromark2 = __commonJS({
  "node_modules/markdownlint/helpers/micromark.cjs"(exports, module2) {
    "use strict";
    var {
      gfmAutolinkLiteral,
      gfmFootnote,
      gfmTable,
      parse,
      postprocess,
      preprocess
      // @ts-ignore
    } = require_micromark();
    function getMicromarkEvents(markdown, options = {}) {
      options.extensions = options.extensions || [];
      options.extensions.push(gfmAutolinkLiteral, gfmFootnote(), gfmTable);
      const encoding = void 0;
      const eol = true;
      const parseContext = parse(options);
      parseContext.defined.includes = (searchElement) => searchElement.length > 0;
      const chunks = preprocess()(markdown, encoding, eol);
      const events = postprocess(parseContext.document().write(chunks));
      return events;
    }
    function micromarkParse(markdown, options = {}) {
      const events = getMicromarkEvents(markdown, options);
      const document = [];
      let current = {
        "children": document
      };
      const history = [current];
      for (const event of events) {
        const [kind, token, context] = event;
        const { type: type2, start, end } = token;
        const { "column": startColumn, "line": startLine } = start;
        const { "column": endColumn, "line": endLine } = end;
        let text = null;
        try {
          text = context.sliceSerialize(token);
        } catch {
        }
        if (kind === "enter") {
          const previous = current;
          history.push(previous);
          current = {
            type: type2,
            startLine,
            startColumn,
            endLine,
            endColumn,
            text,
            "children": []
          };
          previous.children.push(current);
        } else if (kind === "exit") {
          Object.freeze(current.children);
          Object.freeze(current);
          current = history.pop();
        }
      }
      Object.freeze(document);
      return document;
    }
    function filterByPredicate(tokens, allowed, transformChildren) {
      const result = [];
      const pending = [...tokens];
      let token = null;
      while (token = pending.shift()) {
        if (allowed(token)) {
          result.push(token);
        }
        if (token.children.length > 0) {
          const transformed = transformChildren ? transformChildren(token) : token.children;
          pending.unshift(...transformed);
        }
      }
      return result;
    }
    function filterByTypes(tokens, allowed) {
      return filterByPredicate(
        tokens,
        (token) => allowed.includes(token.type)
      );
    }
    function getHtmlTagInfo(token) {
      const htmlTagNameRe = /^<([^!>][^/\s>]*)/;
      if (token.type === "htmlText") {
        const match = htmlTagNameRe.exec(token.text);
        if (match) {
          const name = match[1];
          const close = name.startsWith("/");
          return {
            close,
            "name": close ? name.slice(1) : name
          };
        }
      }
      return null;
    }
    function getTokenTextByType(tokens, type2) {
      const filtered = tokens.filter((token) => token.type === type2);
      return filtered.length === 1 ? filtered[0].text : null;
    }
    function matchAndGetTokensByType(tokens, matchTypes, resultTypes) {
      if (tokens.length !== matchTypes.length) {
        return null;
      }
      resultTypes = resultTypes || matchTypes;
      const result = [];
      for (let i = 0; i < matchTypes.length; i++) {
        if (tokens[i].type !== matchTypes[i]) {
          return null;
        } else if (resultTypes.includes(matchTypes[i])) {
          result.push(tokens[i]);
        }
      }
      return result;
    }
    module2.exports = {
      "parse": micromarkParse,
      filterByPredicate,
      filterByTypes,
      getHtmlTagInfo,
      getMicromarkEvents,
      getTokenTextByType,
      matchAndGetTokensByType
    };
  }
});

// node_modules/markdownlint/lib/constants.js
var require_constants = __commonJS({
  "node_modules/markdownlint/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports.deprecatedRuleNames = ["MD002", "MD006"];
    module2.exports.fixableRuleNames = [
      "MD004",
      "MD005",
      "MD006",
      "MD007",
      "MD009",
      "MD010",
      "MD011",
      "MD012",
      "MD014",
      "MD018",
      "MD019",
      "MD020",
      "MD021",
      "MD022",
      "MD023",
      "MD026",
      "MD027",
      "MD030",
      "MD031",
      "MD032",
      "MD034",
      "MD037",
      "MD038",
      "MD039",
      "MD044",
      "MD047",
      "MD049",
      "MD050",
      "MD051",
      "MD053"
    ];
    module2.exports.homepage = "https://github.com/DavidAnson/markdownlint";
    module2.exports.version = "0.28.0";
  }
});

// node_modules/markdownlint/helpers/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/markdownlint/helpers/helpers.js"(exports, module2) {
    "use strict";
    var micromark = require_micromark2();
    var newLineRe = /\r\n?|\n/g;
    module2.exports.newLineRe = newLineRe;
    module2.exports.frontMatterRe = // eslint-disable-next-line max-len
    /((^---\s*$[\s\S]*?^---\s*)|(^\+\+\+\s*$[\s\S]*?^(\+\+\+|\.\.\.)\s*)|(^\{\s*$[\s\S]*?^\}\s*))(\r\n|\r|\n|$)/m;
    var inlineCommentStartRe = (
      // eslint-disable-next-line max-len
      /(<!--\s*markdownlint-(disable|enable|capture|restore|disable-file|enable-file|disable-line|disable-next-line|configure-file))(?:\s|-->)/gi
    );
    module2.exports.inlineCommentStartRe = inlineCommentStartRe;
    var htmlElementRe = /<(([A-Za-z][A-Za-z\d-]*)(?:\s[^`>]*)?)\/?>/g;
    module2.exports.htmlElementRe = htmlElementRe;
    module2.exports.listItemMarkerRe = /^([\s>]*)(?:[*+-]|\d+[.)])\s+/;
    module2.exports.orderedListItemMarkerRe = /^[\s>]*0*(\d+)[.)]/;
    var emphasisMarkersRe = /[_*]/g;
    var blockquotePrefixRe = /^[>\s]*/;
    module2.exports.blockquotePrefixRe = blockquotePrefixRe;
    var linkReferenceDefinitionRe = /^ {0,3}\[([^\]]*[^\\])\]:/;
    module2.exports.linkReferenceDefinitionRe = linkReferenceDefinitionRe;
    var allPunctuation = ".,;:!?\u3002\uFF0C\uFF1B\uFF1A\uFF01\uFF1F";
    module2.exports.allPunctuation = allPunctuation;
    module2.exports.allPunctuationNoQuestion = allPunctuation.replace(/[?]/gu, "");
    module2.exports.isNumber = function isNumber(obj) {
      return typeof obj === "number";
    };
    module2.exports.isString = function isString(obj) {
      return typeof obj === "string";
    };
    module2.exports.isEmptyString = function isEmptyString(str2) {
      return str2.length === 0;
    };
    module2.exports.isObject = function isObject2(obj) {
      return obj !== null && typeof obj === "object" && !Array.isArray(obj);
    };
    function isBlankLine(line) {
      const startComment = "<!--";
      const endComment = "-->";
      const removeComments = (s) => {
        while (true) {
          const start = s.indexOf(startComment);
          const end = s.indexOf(endComment);
          if (end !== -1 && (start === -1 || end < start)) {
            s = s.slice(end + endComment.length);
          } else if (start !== -1 && end !== -1) {
            s = s.slice(0, start) + s.slice(end + endComment.length);
          } else if (start !== -1 && end === -1) {
            s = s.slice(0, start);
          } else {
            return s;
          }
        }
      };
      return !line || !line.trim() || !removeComments(line).replace(/>/g, "").trim();
    }
    module2.exports.isBlankLine = isBlankLine;
    module2.exports.numericSortAscending = function numericSortAscending(a, b) {
      return a - b;
    };
    module2.exports.includesSorted = function includesSorted(array, element) {
      let left = 0;
      let right = array.length - 1;
      while (left <= right) {
        const mid = left + right >> 1;
        if (array[mid] < element) {
          left = mid + 1;
        } else if (array[mid] > element) {
          right = mid - 1;
        } else {
          return true;
        }
      }
      return false;
    };
    var htmlCommentBegin = "<!--";
    var htmlCommentEnd = "-->";
    var safeCommentCharacter = ".";
    var startsWithPipeRe = /^ *\|/;
    var notCrLfRe = /[^\r\n]/g;
    var notSpaceCrLfRe = /[^ \r\n]/g;
    var trailingSpaceRe = / +[\r\n]/g;
    var replaceTrailingSpace = (s) => s.replace(notCrLfRe, safeCommentCharacter);
    module2.exports.clearHtmlCommentText = function clearHtmlCommentText(text) {
      let i = 0;
      while ((i = text.indexOf(htmlCommentBegin, i)) !== -1) {
        const j = text.indexOf(htmlCommentEnd, i + 2);
        if (j === -1) {
          break;
        }
        if (j > i + htmlCommentBegin.length) {
          const content = text.slice(i + htmlCommentBegin.length, j);
          const lastLf = text.lastIndexOf("\n", i) + 1;
          const preText = text.slice(lastLf, i);
          const isBlock = preText.trim().length === 0;
          const couldBeTable = startsWithPipeRe.test(preText);
          const spansTableCells = couldBeTable && content.includes("\n");
          const isValid = isBlock || !(spansTableCells || content.startsWith(">") || content.startsWith("->") || content.endsWith("-") || content.includes("--"));
          if (isValid) {
            const clearedContent = content.replace(notSpaceCrLfRe, safeCommentCharacter).replace(trailingSpaceRe, replaceTrailingSpace);
            text = text.slice(0, i + htmlCommentBegin.length) + clearedContent + text.slice(j);
          }
        }
        i = j + htmlCommentEnd.length;
      }
      return text;
    };
    module2.exports.escapeForRegExp = function escapeForRegExp(str2) {
      return str2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    };
    module2.exports.fencedCodeBlockStyleFor = function fencedCodeBlockStyleFor(markup) {
      switch (markup[0]) {
        case "~":
          return "tilde";
        default:
          return "backtick";
      }
    };
    module2.exports.emphasisOrStrongStyleFor = function emphasisOrStrongStyleFor(markup) {
      switch (markup[0]) {
        case "*":
          return "asterisk";
        default:
          return "underscore";
      }
    };
    function indentFor(token) {
      const line = token.line.replace(/^[\s>]*(> |>)/, "");
      return line.length - line.trimStart().length;
    }
    module2.exports.indentFor = indentFor;
    module2.exports.headingStyleFor = function headingStyleFor(token) {
      if (token.map[1] - token.map[0] === 1) {
        if (/[^\\]#\s*$/.test(token.line)) {
          return "atx_closed";
        }
        return "atx";
      }
      return "setext";
    };
    module2.exports.unorderedListStyleFor = function unorderedListStyleFor(token) {
      switch (token.markup) {
        case "-":
          return "dash";
        case "+":
          return "plus";
        default:
          return "asterisk";
      }
    };
    function filterTokens(params, type2, handler) {
      for (const token of params.parsers.markdownit.tokens) {
        if (token.type === type2) {
          handler(token);
        }
      }
    }
    module2.exports.filterTokens = filterTokens;
    function isMathBlock(token) {
      return (token.tag === "$$" || token.tag === "math") && token.type.startsWith("math_block") && !token.type.endsWith("_end");
    }
    module2.exports.isMathBlock = isMathBlock;
    module2.exports.getLineMetadata = function getLineMetadata(params) {
      const lineMetadata = params.lines.map(
        (line, index) => [line, index, false, 0, false, false, false, false]
      );
      filterTokens(params, "fence", (token) => {
        lineMetadata[token.map[0]][3] = 1;
        lineMetadata[token.map[1] - 1][3] = -1;
        for (let i = token.map[0] + 1; i < token.map[1] - 1; i++) {
          lineMetadata[i][2] = true;
        }
      });
      filterTokens(params, "code_block", (token) => {
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][2] = true;
        }
      });
      filterTokens(params, "table_open", (token) => {
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][4] = true;
        }
      });
      filterTokens(params, "list_item_open", (token) => {
        let count = 1;
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][5] = count;
          count++;
        }
      });
      filterTokens(params, "hr", (token) => {
        lineMetadata[token.map[0]][6] = true;
      });
      for (const token of params.parsers.markdownit.tokens.filter(isMathBlock)) {
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][7] = true;
        }
      }
      return lineMetadata;
    };
    function forEachLine(lineMetadata, handler) {
      for (const metadata of lineMetadata) {
        handler(...metadata);
      }
    }
    module2.exports.forEachLine = forEachLine;
    module2.exports.flattenLists = function flattenLists(tokens) {
      const flattenedLists = [];
      const stack = [];
      let current = null;
      let nesting = 0;
      const nestingStack = [];
      let lastWithMap = { "map": [0, 1] };
      for (const token of tokens) {
        if (token.type === "bullet_list_open" || token.type === "ordered_list_open") {
          stack.push(current);
          current = {
            "unordered": token.type === "bullet_list_open",
            "parentsUnordered": !current || current.unordered && current.parentsUnordered,
            "open": token,
            "indent": indentFor(token),
            "parentIndent": current && current.indent || 0,
            "items": [],
            "nesting": nesting,
            "lastLineIndex": -1,
            "insert": flattenedLists.length
          };
          nesting++;
        } else if (token.type === "bullet_list_close" || token.type === "ordered_list_close") {
          current.lastLineIndex = lastWithMap.map[1];
          flattenedLists.splice(current.insert, 0, current);
          delete current.insert;
          current = stack.pop();
          nesting--;
        } else if (token.type === "list_item_open") {
          current.items.push(token);
        } else if (token.type === "blockquote_open") {
          nestingStack.push(nesting);
          nesting = 0;
        } else if (token.type === "blockquote_close") {
          nesting = nestingStack.pop() || 0;
        }
        if (token.map) {
          lastWithMap = token;
        }
      }
      return flattenedLists;
    };
    function forEachInlineChild(params, type2, handler) {
      filterTokens(params, "inline", (token) => {
        for (const child of token.children.filter((c) => c.type === type2)) {
          handler(child, token);
        }
      });
    }
    module2.exports.forEachInlineChild = forEachInlineChild;
    module2.exports.forEachHeading = function forEachHeading(params, handler) {
      let heading = null;
      for (const token of params.parsers.markdownit.tokens) {
        if (token.type === "heading_open") {
          heading = token;
        } else if (token.type === "heading_close") {
          heading = null;
        } else if (token.type === "inline" && heading) {
          handler(heading, token.content, token);
        }
      }
    };
    function forEachInlineCodeSpan(input, handler) {
      const backtickRe = /`+/g;
      let match = null;
      const backticksLengthAndIndex = [];
      while ((match = backtickRe.exec(input)) !== null) {
        backticksLengthAndIndex.push([match[0].length, match.index]);
      }
      const newLinesIndex = [];
      while ((match = newLineRe.exec(input)) !== null) {
        newLinesIndex.push(match.index);
      }
      let lineIndex = 0;
      let lineStartIndex = 0;
      let k = 0;
      for (let i = 0; i < backticksLengthAndIndex.length - 1; i++) {
        const [startLength, startIndex] = backticksLengthAndIndex[i];
        if (startIndex === 0 || input[startIndex - 1] !== "\\") {
          for (let j = i + 1; j < backticksLengthAndIndex.length; j++) {
            const [endLength, endIndex] = backticksLengthAndIndex[j];
            if (startLength === endLength) {
              for (; k < newLinesIndex.length; k++) {
                const newLineIndex = newLinesIndex[k];
                if (startIndex < newLineIndex) {
                  break;
                }
                lineIndex++;
                lineStartIndex = newLineIndex + 1;
              }
              const columnIndex = startIndex - lineStartIndex + startLength;
              handler(
                input.slice(startIndex + startLength, endIndex),
                lineIndex,
                columnIndex,
                startLength
              );
              i = j;
              break;
            }
          }
        }
      }
    }
    module2.exports.forEachInlineCodeSpan = forEachInlineCodeSpan;
    function ellipsify(text, start, end) {
      if (text.length <= 30) {
      } else if (start && end) {
        text = text.slice(0, 15) + "..." + text.slice(-15);
      } else if (end) {
        text = "..." + text.slice(-30);
      } else {
        text = text.slice(0, 30) + "...";
      }
      return text;
    }
    module2.exports.ellipsify = ellipsify;
    function addError(onError, lineNumber, detail, context, range, fixInfo) {
      onError({
        lineNumber,
        detail,
        context,
        range,
        fixInfo
      });
    }
    module2.exports.addError = addError;
    module2.exports.addErrorDetailIf = function addErrorDetailIf(onError, lineNumber, expected, actual, detail, context, range, fixInfo) {
      if (expected !== actual) {
        addError(
          onError,
          lineNumber,
          "Expected: " + expected + "; Actual: " + actual + (detail ? "; " + detail : ""),
          context,
          range,
          fixInfo
        );
      }
    };
    module2.exports.addErrorContext = function addErrorContext(onError, lineNumber, context, left, right, range, fixInfo) {
      context = ellipsify(context, left, right);
      addError(onError, lineNumber, void 0, context, range, fixInfo);
    };
    module2.exports.codeBlockAndSpanRanges = (params, lineMetadata) => {
      const exclusions = [];
      forEachLine(lineMetadata, (line, lineIndex, inCode, onFence) => {
        if (inCode && !onFence) {
          exclusions.push([lineIndex, 0, line.length]);
        }
      });
      filterTokens(params, "inline", (token) => {
        if (token.children.some((child) => child.type === "code_inline")) {
          const tokenLines = params.lines.slice(token.map[0], token.map[1]);
          forEachInlineCodeSpan(
            tokenLines.join("\n"),
            (code, lineIndex, columnIndex) => {
              const codeLines = code.split(newLineRe);
              for (const [i, line] of codeLines.entries()) {
                exclusions.push([
                  token.lineNumber - 1 + lineIndex + i,
                  i ? 0 : columnIndex,
                  line.length
                ]);
              }
            }
          );
        }
      });
      return exclusions;
    };
    module2.exports.htmlElementRanges = (params, lineMetadata) => {
      const exclusions = [];
      forEachLine(lineMetadata, (line, lineIndex, inCode) => {
        let match = null;
        while (!inCode && (match = htmlElementRe.exec(line)) !== null) {
          exclusions.push([lineIndex, match.index, match[0].length]);
        }
      });
      forEachInlineChild(params, "html_inline", (token, parent) => {
        const parentContent = parent.content;
        let tokenContent = token.content;
        const parentIndex = parentContent.indexOf(tokenContent);
        let deltaLines = 0;
        let indent = 0;
        for (let i = parentIndex - 1; i >= 0; i--) {
          if (parentContent[i] === "\n") {
            deltaLines++;
          } else if (deltaLines === 0) {
            indent++;
          }
        }
        let lineIndex = token.lineNumber - 1 + deltaLines;
        do {
          const index = tokenContent.indexOf("\n");
          const length = index === -1 ? tokenContent.length : index;
          exclusions.push([lineIndex, indent, length]);
          tokenContent = tokenContent.slice(length + 1);
          lineIndex++;
          indent = 0;
        } while (tokenContent.length > 0);
      });
      return exclusions;
    };
    var withinAnyRange = (ranges, lineIndex, index, length) => !ranges.every((span) => lineIndex !== span[0] || index < span[1] || index + length > span[1] + span[2]);
    module2.exports.withinAnyRange = withinAnyRange;
    module2.exports.rangeFromRegExp = function rangeFromRegExp(line, regexp) {
      let range = null;
      const match = line.match(regexp);
      if (match) {
        const column = match.index + 1;
        const length = match[0].length;
        range = [column, length];
      }
      return range;
    };
    module2.exports.frontMatterHasTitle = function frontMatterHasTitle(frontMatterLines, frontMatterTitlePattern) {
      const ignoreFrontMatter = frontMatterTitlePattern !== void 0 && !frontMatterTitlePattern;
      const frontMatterTitleRe = new RegExp(
        String(frontMatterTitlePattern || '^\\s*"?title"?\\s*[:=]'),
        "i"
      );
      return !ignoreFrontMatter && frontMatterLines.some((line) => frontMatterTitleRe.test(line));
    };
    function forEachLink(line, handler) {
      const findClosingSymbol = (index) => {
        const begin = line[index];
        const end = begin === "[" ? "]" : ")";
        let nesting = 0;
        let escaping2 = false;
        let pointy = false;
        for (let i = index + 1; i < line.length; i++) {
          const current = line[i];
          if (current === "\\") {
            escaping2 = !escaping2;
          } else if (!escaping2 && current === begin) {
            nesting++;
          } else if (!escaping2 && current === end) {
            if (nesting > 0) {
              nesting--;
            } else if (!pointy) {
              return i + 1;
            }
          } else if (i === index + 1 && begin === "(" && current === "<") {
            pointy = true;
          } else if (!escaping2 && pointy && current === ">") {
            pointy = false;
            nesting = 0;
          } else {
            escaping2 = false;
          }
        }
        return -1;
      };
      let escaping = false;
      for (let i = 0; i < line.length; i++) {
        const current = line[i];
        if (current === "\\") {
          escaping = !escaping;
        } else if (!escaping && current === "[") {
          const textEnd = findClosingSymbol(i);
          if (textEnd !== -1) {
            if (line[textEnd] === "(" || line[textEnd] === "[") {
              const destEnd = findClosingSymbol(textEnd);
              if (destEnd !== -1) {
                const link = line.slice(i, destEnd);
                const text = line.slice(i, textEnd);
                const dest = line.slice(textEnd, destEnd);
                handler(i, link, text, dest);
                i = destEnd;
              }
            }
            if (i < textEnd) {
              const text = line.slice(i, textEnd);
              handler(i, text, text);
              i = textEnd;
            }
          }
        } else {
          escaping = false;
        }
      }
    }
    module2.exports.forEachLink = forEachLink;
    function emphasisMarkersInContent(params) {
      const { lines } = params;
      const byLine = new Array(lines.length);
      for (const [tokenLineIndex, tokenLine] of lines.entries()) {
        const inLine = [];
        forEachLink(tokenLine, (index, match) => {
          let markerMatch = null;
          while (markerMatch = emphasisMarkersRe.exec(match)) {
            inLine.push(index + markerMatch.index);
          }
        });
        byLine[tokenLineIndex] = inLine;
      }
      filterTokens(params, "inline", (token) => {
        const { children, lineNumber, map: map2 } = token;
        if (children.some((child) => child.type === "code_inline")) {
          const tokenLines = lines.slice(map2[0], map2[1]);
          forEachInlineCodeSpan(
            tokenLines.join("\n"),
            (code, lineIndex, column, tickCount) => {
              const codeLines = code.split(newLineRe);
              for (const [codeLineIndex, codeLine] of codeLines.entries()) {
                const byLineIndex = lineNumber - 1 + lineIndex + codeLineIndex;
                const inLine = byLine[byLineIndex];
                const codeLineOffset = codeLineIndex ? 0 : column - 1 + tickCount;
                let match = null;
                while (match = emphasisMarkersRe.exec(codeLine)) {
                  inLine.push(codeLineOffset + match.index);
                }
                byLine[byLineIndex] = inLine;
              }
            }
          );
        }
      });
      return byLine;
    }
    module2.exports.emphasisMarkersInContent = emphasisMarkersInContent;
    function getReferenceLinkImageData(params) {
      const normalizeReference = (s) => s.toLowerCase().trim().replace(/\s+/g, " ");
      const definitions = /* @__PURE__ */ new Map();
      const definitionLineIndices = [];
      const duplicateDefinitions = [];
      const references = /* @__PURE__ */ new Map();
      const shortcuts = /* @__PURE__ */ new Map();
      const filteredTokens = micromark.filterByTypes(
        params.parsers.micromark.tokens,
        [
          // definitionLineIndices
          "definition",
          "gfmFootnoteDefinition",
          // definitions and definitionLineIndices
          "definitionLabelString",
          "gfmFootnoteDefinitionLabelString",
          // references and shortcuts
          "gfmFootnoteCall",
          "image",
          "link"
        ]
      );
      for (const token of filteredTokens) {
        let labelPrefix = "";
        switch (token.type) {
          case "definition":
          case "gfmFootnoteDefinition":
            for (let i = token.startLine; i <= token.endLine; i++) {
              definitionLineIndices.push(i - 1);
            }
            break;
          case "gfmFootnoteDefinitionLabelString":
            labelPrefix = "^";
          case "definitionLabelString":
            {
              const reference = normalizeReference(`${labelPrefix}${token.text}`);
              if (definitions.has(reference)) {
                duplicateDefinitions.push([reference, token.startLine - 1]);
              } else {
                definitions.set(reference, token.startLine - 1);
              }
            }
            break;
          case "gfmFootnoteCall":
          case "image":
          case "link":
            {
              let isShortcut = false;
              let isFullOrCollapsed = false;
              let labelText = null;
              let referenceStringText = null;
              const shortcutCandidate = micromark.matchAndGetTokensByType(token.children, ["label"]);
              if (shortcutCandidate) {
                labelText = micromark.getTokenTextByType(
                  shortcutCandidate[0].children,
                  "labelText"
                );
                isShortcut = labelText !== null;
              }
              const fullAndCollapsedCandidate = micromark.matchAndGetTokensByType(
                token.children,
                ["label", "reference"]
              );
              if (fullAndCollapsedCandidate) {
                labelText = micromark.getTokenTextByType(
                  fullAndCollapsedCandidate[0].children,
                  "labelText"
                );
                referenceStringText = micromark.getTokenTextByType(
                  fullAndCollapsedCandidate[1].children,
                  "referenceString"
                );
                isFullOrCollapsed = labelText !== null;
              }
              const footnote = micromark.matchAndGetTokensByType(
                token.children,
                [
                  "gfmFootnoteCallLabelMarker",
                  "gfmFootnoteCallMarker",
                  "gfmFootnoteCallString",
                  "gfmFootnoteCallLabelMarker"
                ],
                ["gfmFootnoteCallMarker", "gfmFootnoteCallString"]
              );
              if (footnote) {
                const callMarkerText = footnote[0].text;
                const callString = footnote[1].text;
                labelText = `${callMarkerText}${callString}`;
                isShortcut = true;
              }
              if (isShortcut || isFullOrCollapsed) {
                const referenceDatum = [
                  token.startLine - 1,
                  token.startColumn - 1,
                  token.text.length,
                  // @ts-ignore
                  labelText.length,
                  (referenceStringText || "").length
                ];
                const reference = normalizeReference(referenceStringText || labelText);
                const dictionary = isShortcut ? shortcuts : references;
                const referenceData = dictionary.get(reference) || [];
                referenceData.push(referenceDatum);
                dictionary.set(reference, referenceData);
              }
            }
            break;
        }
      }
      return {
        references,
        shortcuts,
        definitions,
        duplicateDefinitions,
        definitionLineIndices
      };
    }
    module2.exports.getReferenceLinkImageData = getReferenceLinkImageData;
    function getPreferredLineEnding(input, os) {
      let cr = 0;
      let lf = 0;
      let crlf = 0;
      const endings = input.match(newLineRe) || [];
      for (const ending of endings) {
        switch (ending) {
          case "\r":
            cr++;
            break;
          case "\n":
            lf++;
            break;
          case "\r\n":
            crlf++;
            break;
        }
      }
      let preferredLineEnding = null;
      if (!cr && !lf && !crlf) {
        preferredLineEnding = os && os.EOL || "\n";
      } else if (lf >= crlf && lf >= cr) {
        preferredLineEnding = "\n";
      } else if (crlf >= cr) {
        preferredLineEnding = "\r\n";
      } else {
        preferredLineEnding = "\r";
      }
      return preferredLineEnding;
    }
    module2.exports.getPreferredLineEnding = getPreferredLineEnding;
    function normalizeFixInfo(fixInfo, lineNumber) {
      return {
        "lineNumber": fixInfo.lineNumber || lineNumber,
        "editColumn": fixInfo.editColumn || 1,
        "deleteCount": fixInfo.deleteCount || 0,
        "insertText": fixInfo.insertText || ""
      };
    }
    function applyFix2(line, fixInfo, lineEnding) {
      const { editColumn, deleteCount, insertText } = normalizeFixInfo(fixInfo);
      const editIndex = editColumn - 1;
      return deleteCount === -1 ? null : line.slice(0, editIndex) + insertText.replace(/\n/g, lineEnding || "\n") + line.slice(editIndex + deleteCount);
    }
    module2.exports.applyFix = applyFix2;
    function applyFixes2(input, errors) {
      const lineEnding = getPreferredLineEnding(input, require("os"));
      const lines = input.split(newLineRe);
      let fixInfos = errors.filter((error) => error.fixInfo).map((error) => normalizeFixInfo(error.fixInfo, error.lineNumber));
      fixInfos.sort((a, b) => {
        const aDeletingLine = a.deleteCount === -1;
        const bDeletingLine = b.deleteCount === -1;
        return b.lineNumber - a.lineNumber || (aDeletingLine ? 1 : bDeletingLine ? -1 : 0) || b.editColumn - a.editColumn || b.insertText.length - a.insertText.length;
      });
      let lastFixInfo = {};
      fixInfos = fixInfos.filter((fixInfo) => {
        const unique = fixInfo.lineNumber !== lastFixInfo.lineNumber || fixInfo.editColumn !== lastFixInfo.editColumn || fixInfo.deleteCount !== lastFixInfo.deleteCount || fixInfo.insertText !== lastFixInfo.insertText;
        lastFixInfo = fixInfo;
        return unique;
      });
      lastFixInfo = {
        "lineNumber": -1
      };
      for (const fixInfo of fixInfos) {
        if (fixInfo.lineNumber === lastFixInfo.lineNumber && fixInfo.editColumn === lastFixInfo.editColumn && !fixInfo.insertText && fixInfo.deleteCount > 0 && lastFixInfo.insertText && !lastFixInfo.deleteCount) {
          fixInfo.insertText = lastFixInfo.insertText;
          lastFixInfo.lineNumber = 0;
        }
        lastFixInfo = fixInfo;
      }
      fixInfos = fixInfos.filter((fixInfo) => fixInfo.lineNumber);
      let lastLineIndex = -1;
      let lastEditIndex = -1;
      for (const fixInfo of fixInfos) {
        const { lineNumber, editColumn, deleteCount } = fixInfo;
        const lineIndex = lineNumber - 1;
        const editIndex = editColumn - 1;
        if (lineIndex !== lastLineIndex || deleteCount === -1 || editIndex + deleteCount <= lastEditIndex - (deleteCount > 0 ? 0 : 1)) {
          lines[lineIndex] = applyFix2(lines[lineIndex], fixInfo, lineEnding);
        }
        lastLineIndex = lineIndex;
        lastEditIndex = editIndex;
      }
      return lines.filter((line) => line !== null).join(lineEnding);
    }
    module2.exports.applyFixes = applyFixes2;
    module2.exports.getRangeAndFixInfoIfFound = (lines, lineIndex, search, replace, instance = 1) => {
      let range = null;
      let fixInfo = null;
      let searchIndex = -1;
      while (instance > 0) {
        searchIndex = lines[lineIndex].indexOf(search, searchIndex + 1);
        instance--;
      }
      if (searchIndex !== -1) {
        const column = searchIndex + 1;
        const length = search.length;
        range = [column, length];
        fixInfo = {
          "editColumn": column,
          "deleteCount": length,
          "insertText": replace
        };
      }
      return {
        range,
        fixInfo
      };
    };
    function getNextChildToken(parentToken, childToken, nextType, nextNextType) {
      const { children } = parentToken;
      const index = children.indexOf(childToken);
      if (index !== -1 && children.length > index + 2 && children[index + 1].type === nextType && children[index + 2].type === nextNextType) {
        return children[index + 1];
      }
      return null;
    }
    module2.exports.getNextChildToken = getNextChildToken;
    function expandTildePath(file, os) {
      const homedir = os && os.homedir && os.homedir();
      return homedir ? file.replace(/^~($|\/|\\)/, `${homedir}$1`) : file;
    }
    module2.exports.expandTildePath = expandTildePath;
  }
});

// node_modules/markdownlint/lib/md001.js
var require_md001 = __commonJS({
  "node_modules/markdownlint/lib/md001.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, filterTokens } = require_helpers2();
    module2.exports = {
      "names": ["MD001", "heading-increment", "header-increment"],
      "description": "Heading levels should only increment by one level at a time",
      "tags": ["headings", "headers"],
      "function": function MD001(params, onError) {
        let prevLevel = 0;
        filterTokens(params, "heading_open", function forToken(token) {
          const level = Number.parseInt(token.tag.slice(1), 10);
          if (prevLevel && level > prevLevel) {
            addErrorDetailIf(
              onError,
              token.lineNumber,
              "h" + (prevLevel + 1),
              "h" + level
            );
          }
          prevLevel = level;
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md002.js
var require_md002 = __commonJS({
  "node_modules/markdownlint/lib/md002.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf } = require_helpers2();
    module2.exports = {
      "names": ["MD002", "first-heading-h1", "first-header-h1"],
      "description": "First heading should be a top-level heading",
      "tags": ["headings", "headers"],
      "function": function MD002(params, onError) {
        const level = Number(params.config.level || 1);
        const tag = "h" + level;
        params.parsers.markdownit.tokens.every(function forToken(token) {
          if (token.type === "heading_open") {
            addErrorDetailIf(onError, token.lineNumber, tag, token.tag);
            return false;
          }
          return true;
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md003.js
var require_md003 = __commonJS({
  "node_modules/markdownlint/lib/md003.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, filterTokens, headingStyleFor } = require_helpers2();
    module2.exports = {
      "names": ["MD003", "heading-style", "header-style"],
      "description": "Heading style",
      "tags": ["headings", "headers"],
      "function": function MD003(params, onError) {
        let style = String(params.config.style || "consistent");
        filterTokens(params, "heading_open", function forToken(token) {
          const styleForToken = headingStyleFor(token);
          if (style === "consistent") {
            style = styleForToken;
          }
          if (styleForToken !== style) {
            const h12 = /h[12]/.test(token.tag);
            const setextWithAtx = style === "setext_with_atx" && (h12 && styleForToken === "setext" || !h12 && styleForToken === "atx");
            const setextWithAtxClosed = style === "setext_with_atx_closed" && (h12 && styleForToken === "setext" || !h12 && styleForToken === "atx_closed");
            if (!setextWithAtx && !setextWithAtxClosed) {
              let expected = style;
              if (style === "setext_with_atx") {
                expected = h12 ? "setext" : "atx";
              } else if (style === "setext_with_atx_closed") {
                expected = h12 ? "setext" : "atx_closed";
              }
              addErrorDetailIf(
                onError,
                token.lineNumber,
                expected,
                styleForToken
              );
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/cache.js
var require_cache = __commonJS({
  "node_modules/markdownlint/lib/cache.js"(exports, module2) {
    "use strict";
    var map2 = /* @__PURE__ */ new Map();
    module2.exports.set = (keyValuePairs) => {
      for (const [key, value] of Object.entries(keyValuePairs)) {
        map2.set(key, value);
      }
    };
    module2.exports.clear = () => map2.clear();
    module2.exports.codeBlockAndSpanRanges = () => map2.get("codeBlockAndSpanRanges");
    module2.exports.flattenedLists = () => map2.get("flattenedLists");
    module2.exports.htmlElementRanges = () => map2.get("htmlElementRanges");
    module2.exports.lineMetadata = () => map2.get("lineMetadata");
    module2.exports.referenceLinkImageData = () => map2.get("referenceLinkImageData");
  }
});

// node_modules/markdownlint/lib/md004.js
var require_md004 = __commonJS({
  "node_modules/markdownlint/lib/md004.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, listItemMarkerRe, unorderedListStyleFor } = require_helpers2();
    var { flattenedLists } = require_cache();
    var expectedStyleToMarker = {
      "dash": "-",
      "plus": "+",
      "asterisk": "*"
    };
    var differentItemStyle = {
      "dash": "plus",
      "plus": "asterisk",
      "asterisk": "dash"
    };
    var validStyles = Object.keys(expectedStyleToMarker);
    module2.exports = {
      "names": ["MD004", "ul-style"],
      "description": "Unordered list style",
      "tags": ["bullet", "ul"],
      "function": function MD004(params, onError) {
        const style = String(params.config.style || "consistent");
        let expectedStyle = style;
        const nestingStyles = [];
        for (const list of flattenedLists()) {
          if (list.unordered) {
            if (expectedStyle === "consistent") {
              expectedStyle = unorderedListStyleFor(list.items[0]);
            }
            for (const item of list.items) {
              const itemStyle = unorderedListStyleFor(item);
              if (style === "sublist") {
                const nesting = list.nesting;
                if (!nestingStyles[nesting]) {
                  nestingStyles[nesting] = itemStyle === nestingStyles[nesting - 1] ? differentItemStyle[itemStyle] : itemStyle;
                }
                expectedStyle = nestingStyles[nesting];
              }
              if (!validStyles.includes(expectedStyle)) {
                expectedStyle = validStyles[0];
              }
              let range = null;
              let fixInfo = null;
              const match = item.line.match(listItemMarkerRe);
              if (match) {
                const column = match.index + 1;
                const length = match[0].length;
                range = [column, length];
                fixInfo = {
                  "editColumn": match[1].length + 1,
                  "deleteCount": 1,
                  "insertText": expectedStyleToMarker[expectedStyle]
                };
              }
              addErrorDetailIf(
                onError,
                item.lineNumber,
                expectedStyle,
                itemStyle,
                null,
                null,
                range,
                fixInfo
              );
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md005.js
var require_md005 = __commonJS({
  "node_modules/markdownlint/lib/md005.js"(exports, module2) {
    "use strict";
    var {
      addError,
      addErrorDetailIf,
      indentFor,
      listItemMarkerRe,
      orderedListItemMarkerRe,
      rangeFromRegExp
    } = require_helpers2();
    var { flattenedLists } = require_cache();
    module2.exports = {
      "names": ["MD005", "list-indent"],
      "description": "Inconsistent indentation for list items at the same level",
      "tags": ["bullet", "ul", "indentation"],
      "function": function MD005(params, onError) {
        for (const list of flattenedLists()) {
          const expectedIndent = list.indent;
          let expectedEnd = 0;
          let actualEnd = -1;
          let endMatching = false;
          for (const item of list.items) {
            const { line, lineNumber } = item;
            const actualIndent = indentFor(item);
            let match = null;
            if (list.unordered) {
              addErrorDetailIf(
                onError,
                lineNumber,
                expectedIndent,
                actualIndent,
                null,
                null,
                rangeFromRegExp(line, listItemMarkerRe)
                // No fixInfo; MD007 handles this scenario better
              );
            } else if (match = orderedListItemMarkerRe.exec(line)) {
              actualEnd = match[0].length;
              expectedEnd = expectedEnd || actualEnd;
              const markerLength = match[1].length + 1;
              if (expectedIndent !== actualIndent || endMatching) {
                if (expectedEnd === actualEnd) {
                  endMatching = true;
                } else {
                  const detail = endMatching ? `Expected: (${expectedEnd}); Actual: (${actualEnd})` : `Expected: ${expectedIndent}; Actual: ${actualIndent}`;
                  const expected = endMatching ? expectedEnd - markerLength : expectedIndent;
                  const actual = endMatching ? actualEnd - markerLength : actualIndent;
                  addError(
                    onError,
                    lineNumber,
                    detail,
                    null,
                    rangeFromRegExp(line, listItemMarkerRe),
                    {
                      "editColumn": Math.min(actual, expected) + 1,
                      "deleteCount": Math.max(actual - expected, 0),
                      "insertText": "".padEnd(Math.max(expected - actual, 0))
                    }
                  );
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md006.js
var require_md006 = __commonJS({
  "node_modules/markdownlint/lib/md006.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, listItemMarkerRe, rangeFromRegExp } = require_helpers2();
    var { flattenedLists } = require_cache();
    module2.exports = {
      "names": ["MD006", "ul-start-left"],
      "description": "Consider starting bulleted lists at the beginning of the line",
      "tags": ["bullet", "ul", "indentation"],
      "function": function MD006(params, onError) {
        for (const list of flattenedLists()) {
          if (list.unordered && !list.nesting && list.indent !== 0) {
            for (const item of list.items) {
              const { lineNumber, line } = item;
              addErrorDetailIf(
                onError,
                lineNumber,
                0,
                list.indent,
                null,
                null,
                rangeFromRegExp(line, listItemMarkerRe),
                {
                  "deleteCount": line.length - line.trimStart().length
                }
              );
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md007.js
var require_md007 = __commonJS({
  "node_modules/markdownlint/lib/md007.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, indentFor, listItemMarkerRe } = require_helpers2();
    var { flattenedLists } = require_cache();
    module2.exports = {
      "names": ["MD007", "ul-indent"],
      "description": "Unordered list indentation",
      "tags": ["bullet", "ul", "indentation"],
      "function": function MD007(params, onError) {
        const indent = Number(params.config.indent || 2);
        const startIndented = !!params.config.start_indented;
        const startIndent = Number(params.config.start_indent || indent);
        for (const list of flattenedLists()) {
          if (list.unordered && list.parentsUnordered) {
            for (const item of list.items) {
              const { lineNumber, line } = item;
              const expectedIndent = (startIndented ? startIndent : 0) + list.nesting * indent;
              const actualIndent = indentFor(item);
              let range = null;
              let editColumn = 1;
              const match = line.match(listItemMarkerRe);
              if (match) {
                range = [1, match[0].length];
                editColumn += match[1].length - actualIndent;
              }
              addErrorDetailIf(
                onError,
                lineNumber,
                expectedIndent,
                actualIndent,
                null,
                null,
                range,
                {
                  editColumn,
                  "deleteCount": actualIndent,
                  "insertText": "".padEnd(expectedIndent)
                }
              );
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md009.js
var require_md009 = __commonJS({
  "node_modules/markdownlint/lib/md009.js"(exports, module2) {
    "use strict";
    var {
      addError,
      filterTokens,
      forEachLine,
      includesSorted,
      numericSortAscending
    } = require_helpers2();
    var { lineMetadata } = require_cache();
    module2.exports = {
      "names": ["MD009", "no-trailing-spaces"],
      "description": "Trailing spaces",
      "tags": ["whitespace"],
      "function": function MD009(params, onError) {
        let brSpaces = params.config.br_spaces;
        brSpaces = Number(brSpaces === void 0 ? 2 : brSpaces);
        const listItemEmptyLines = !!params.config.list_item_empty_lines;
        const strict = !!params.config.strict;
        const listItemLineNumbers = [];
        if (listItemEmptyLines) {
          filterTokens(params, "list_item_open", (token) => {
            for (let i = token.map[0]; i < token.map[1]; i++) {
              listItemLineNumbers.push(i + 1);
            }
          });
          listItemLineNumbers.sort(numericSortAscending);
        }
        const paragraphLineNumbers = [];
        const codeInlineLineNumbers = [];
        if (strict) {
          filterTokens(params, "paragraph_open", (token) => {
            for (let i = token.map[0]; i < token.map[1] - 1; i++) {
              paragraphLineNumbers.push(i + 1);
            }
          });
          const addLineNumberRange = (start, end) => {
            for (let i = start; i < end; i++) {
              codeInlineLineNumbers.push(i);
            }
          };
          filterTokens(params, "inline", (token) => {
            let start = 0;
            for (const child of token.children) {
              if (start > 0) {
                addLineNumberRange(start, child.lineNumber);
                start = 0;
              }
              if (child.type === "code_inline") {
                start = child.lineNumber;
              }
            }
            if (start > 0) {
              addLineNumberRange(start, token.map[1]);
            }
          });
        }
        const expected = brSpaces < 2 ? 0 : brSpaces;
        forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
          const lineNumber = lineIndex + 1;
          const trailingSpaces = line.length - line.trimEnd().length;
          if (trailingSpaces && !inCode && !includesSorted(listItemLineNumbers, lineNumber) && (expected !== trailingSpaces || strict && (!includesSorted(paragraphLineNumbers, lineNumber) || includesSorted(codeInlineLineNumbers, lineNumber)))) {
            const column = line.length - trailingSpaces + 1;
            addError(
              onError,
              lineNumber,
              "Expected: " + (expected === 0 ? "" : "0 or ") + expected + "; Actual: " + trailingSpaces,
              void 0,
              [column, trailingSpaces],
              {
                "editColumn": column,
                "deleteCount": trailingSpaces
              }
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md010.js
var require_md010 = __commonJS({
  "node_modules/markdownlint/lib/md010.js"(exports, module2) {
    "use strict";
    var { addError, filterTokens, forEachLine, withinAnyRange } = require_helpers2();
    var { codeBlockAndSpanRanges, lineMetadata } = require_cache();
    var tabRe = /\t+/g;
    module2.exports = {
      "names": ["MD010", "no-hard-tabs"],
      "description": "Hard tabs",
      "tags": ["whitespace", "hard_tab"],
      "function": function MD010(params, onError) {
        const codeBlocks = params.config.code_blocks;
        const includeCode = codeBlocks === void 0 ? true : !!codeBlocks;
        const ignoreCodeLanguages = new Set(
          (params.config.ignore_code_languages || []).map((language) => language.toLowerCase())
        );
        const spacesPerTab = params.config.spaces_per_tab;
        const spaceMultiplier = spacesPerTab === void 0 ? 1 : Math.max(0, Number(spacesPerTab));
        const exclusions = includeCode ? [] : codeBlockAndSpanRanges();
        filterTokens(params, "fence", (token) => {
          const language = token.info.trim().toLowerCase();
          if (ignoreCodeLanguages.has(language)) {
            for (let i = token.map[0] + 1; i < token.map[1] - 1; i++) {
              exclusions.push([i, 0, params.lines[i].length]);
            }
          }
        });
        forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
          if (includeCode || !inCode) {
            let match = null;
            while ((match = tabRe.exec(line)) !== null) {
              const { index } = match;
              const column = index + 1;
              const length = match[0].length;
              if (!withinAnyRange(exclusions, lineIndex, index, length)) {
                addError(
                  onError,
                  lineIndex + 1,
                  "Column: " + column,
                  null,
                  [column, length],
                  {
                    "editColumn": column,
                    "deleteCount": length,
                    "insertText": "".padEnd(length * spaceMultiplier)
                  }
                );
              }
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md011.js
var require_md011 = __commonJS({
  "node_modules/markdownlint/lib/md011.js"(exports, module2) {
    "use strict";
    var { addError, forEachLine, withinAnyRange } = require_helpers2();
    var { codeBlockAndSpanRanges, lineMetadata } = require_cache();
    var reversedLinkRe = /(^|[^\\])\(([^()]+)\)\[([^\]^][^\]]*)\](?!\()/g;
    module2.exports = {
      "names": ["MD011", "no-reversed-links"],
      "description": "Reversed link syntax",
      "tags": ["links"],
      "function": function MD011(params, onError) {
        const exclusions = codeBlockAndSpanRanges();
        forEachLine(lineMetadata(), (line, lineIndex, inCode, onFence) => {
          if (!inCode && !onFence) {
            let match = null;
            while ((match = reversedLinkRe.exec(line)) !== null) {
              const [reversedLink, preChar, linkText, linkDestination] = match;
              const index = match.index + preChar.length;
              const length = match[0].length - preChar.length;
              if (!linkText.endsWith("\\") && !linkDestination.endsWith("\\") && !withinAnyRange(exclusions, lineIndex, index, length)) {
                addError(
                  onError,
                  lineIndex + 1,
                  reversedLink.slice(preChar.length),
                  void 0,
                  [index + 1, length],
                  {
                    "editColumn": index + 1,
                    "deleteCount": length,
                    "insertText": `[${linkText}](${linkDestination})`
                  }
                );
              }
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md012.js
var require_md012 = __commonJS({
  "node_modules/markdownlint/lib/md012.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, forEachLine } = require_helpers2();
    var { lineMetadata } = require_cache();
    module2.exports = {
      "names": ["MD012", "no-multiple-blanks"],
      "description": "Multiple consecutive blank lines",
      "tags": ["whitespace", "blank_lines"],
      "function": function MD012(params, onError) {
        const maximum = Number(params.config.maximum || 1);
        let count = 0;
        forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
          count = inCode || line.trim().length > 0 ? 0 : count + 1;
          if (maximum < count) {
            addErrorDetailIf(
              onError,
              lineIndex + 1,
              maximum,
              count,
              null,
              null,
              null,
              {
                "deleteCount": -1
              }
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md013.js
var require_md013 = __commonJS({
  "node_modules/markdownlint/lib/md013.js"(exports, module2) {
    "use strict";
    var {
      addErrorDetailIf,
      filterTokens,
      forEachHeading,
      forEachLine,
      includesSorted
    } = require_helpers2();
    var { lineMetadata, referenceLinkImageData } = require_cache();
    var longLineRePrefix = "^.{";
    var longLineRePostfixRelaxed = "}.*\\s.*$";
    var longLineRePostfixStrict = "}.+$";
    var linkOrImageOnlyLineRe = /^[es]*(?:lT?L|I)[ES]*$/;
    var sternModeRe = /^(?:[#>\s]*\s)?\S*$/;
    var tokenTypeMap = {
      "em_open": "e",
      "em_close": "E",
      "image": "I",
      "link_open": "l",
      "link_close": "L",
      "strong_open": "s",
      "strong_close": "S",
      "text": "T"
    };
    module2.exports = {
      "names": ["MD013", "line-length"],
      "description": "Line length",
      "tags": ["line_length"],
      "function": function MD013(params, onError) {
        const lineLength = Number(params.config.line_length || 80);
        const headingLineLength = Number(params.config.heading_line_length || lineLength);
        const codeLineLength = Number(params.config.code_block_line_length || lineLength);
        const strict = !!params.config.strict;
        const stern = !!params.config.stern;
        const longLineRePostfix = strict || stern ? longLineRePostfixStrict : longLineRePostfixRelaxed;
        const longLineRe = new RegExp(longLineRePrefix + lineLength + longLineRePostfix);
        const longHeadingLineRe = new RegExp(longLineRePrefix + headingLineLength + longLineRePostfix);
        const longCodeLineRe = new RegExp(longLineRePrefix + codeLineLength + longLineRePostfix);
        const codeBlocks = params.config.code_blocks;
        const includeCodeBlocks = codeBlocks === void 0 ? true : !!codeBlocks;
        const tables = params.config.tables;
        const includeTables = tables === void 0 ? true : !!tables;
        let headings = params.config.headings;
        if (headings === void 0) {
          headings = params.config.headers;
        }
        const includeHeadings = headings === void 0 ? true : !!headings;
        const headingLineNumbers = [];
        forEachHeading(params, (heading) => {
          headingLineNumbers.push(heading.lineNumber);
        });
        const linkOnlyLineNumbers = [];
        filterTokens(params, "inline", (token) => {
          let childTokenTypes = "";
          for (const child of token.children) {
            if (child.type !== "text" || child.content !== "") {
              childTokenTypes += tokenTypeMap[child.type] || "x";
            }
          }
          if (linkOrImageOnlyLineRe.test(childTokenTypes)) {
            linkOnlyLineNumbers.push(token.lineNumber);
          }
        });
        const { definitionLineIndices } = referenceLinkImageData();
        forEachLine(lineMetadata(), (line, lineIndex, inCode, onFence, inTable) => {
          const lineNumber = lineIndex + 1;
          const isHeading = includesSorted(headingLineNumbers, lineNumber);
          const length = inCode ? codeLineLength : isHeading ? headingLineLength : lineLength;
          const lengthRe = inCode ? longCodeLineRe : isHeading ? longHeadingLineRe : longLineRe;
          if ((includeCodeBlocks || !inCode) && (includeTables || !inTable) && (includeHeadings || !isHeading) && !includesSorted(definitionLineIndices, lineIndex) && (strict || !(stern && sternModeRe.test(line)) && !includesSorted(linkOnlyLineNumbers, lineNumber)) && lengthRe.test(line)) {
            addErrorDetailIf(
              onError,
              lineNumber,
              length,
              line.length,
              null,
              null,
              [length + 1, line.length - length]
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md014.js
var require_md014 = __commonJS({
  "node_modules/markdownlint/lib/md014.js"(exports, module2) {
    "use strict";
    var { addErrorContext, filterTokens } = require_helpers2();
    var dollarCommandRe = /^(\s*)(\$\s+)/;
    module2.exports = {
      "names": ["MD014", "commands-show-output"],
      "description": "Dollar signs used before commands without showing output",
      "tags": ["code"],
      "function": function MD014(params, onError) {
        for (const type2 of ["code_block", "fence"]) {
          filterTokens(params, type2, (token) => {
            const margin = token.type === "fence" ? 1 : 0;
            const dollarInstances = [];
            let allDollars = true;
            for (let i = token.map[0] + margin; i < token.map[1] - margin; i++) {
              const line = params.lines[i];
              const lineTrim = line.trim();
              if (lineTrim) {
                const match = dollarCommandRe.exec(line);
                if (match) {
                  const column = match[1].length + 1;
                  const length = match[2].length;
                  dollarInstances.push([i, lineTrim, column, length]);
                } else {
                  allDollars = false;
                }
              }
            }
            if (allDollars) {
              for (const instance of dollarInstances) {
                const [i, lineTrim, column, length] = instance;
                addErrorContext(
                  onError,
                  i + 1,
                  lineTrim,
                  null,
                  null,
                  [column, length],
                  {
                    "editColumn": column,
                    "deleteCount": length
                  }
                );
              }
            }
          });
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md018.js
var require_md018 = __commonJS({
  "node_modules/markdownlint/lib/md018.js"(exports, module2) {
    "use strict";
    var { addErrorContext, forEachLine } = require_helpers2();
    var { lineMetadata } = require_cache();
    module2.exports = {
      "names": ["MD018", "no-missing-space-atx"],
      "description": "No space after hash on atx style heading",
      "tags": ["headings", "headers", "atx", "spaces"],
      "function": function MD018(params, onError) {
        forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
          if (!inCode && /^#+[^# \t]/.test(line) && !/#\s*$/.test(line) && !line.startsWith("#\uFE0F\u20E3")) {
            const hashCount = /^#+/.exec(line)[0].length;
            addErrorContext(
              onError,
              lineIndex + 1,
              line.trim(),
              null,
              null,
              [1, hashCount + 1],
              {
                "editColumn": hashCount + 1,
                "insertText": " "
              }
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md019.js
var require_md019 = __commonJS({
  "node_modules/markdownlint/lib/md019.js"(exports, module2) {
    "use strict";
    var { addErrorContext, filterTokens, headingStyleFor } = require_helpers2();
    module2.exports = {
      "names": ["MD019", "no-multiple-space-atx"],
      "description": "Multiple spaces after hash on atx style heading",
      "tags": ["headings", "headers", "atx", "spaces"],
      "function": function MD019(params, onError) {
        filterTokens(params, "heading_open", (token) => {
          if (headingStyleFor(token) === "atx") {
            const { line, lineNumber } = token;
            const match = /^(#+)([ \t]{2,})\S/.exec(line);
            if (match) {
              const [
                ,
                { "length": hashLength },
                { "length": spacesLength }
              ] = match;
              addErrorContext(
                onError,
                lineNumber,
                line.trim(),
                null,
                null,
                [1, hashLength + spacesLength + 1],
                {
                  "editColumn": hashLength + 1,
                  "deleteCount": spacesLength - 1
                }
              );
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md020.js
var require_md020 = __commonJS({
  "node_modules/markdownlint/lib/md020.js"(exports, module2) {
    "use strict";
    var { addErrorContext, forEachLine } = require_helpers2();
    var { lineMetadata } = require_cache();
    module2.exports = {
      "names": ["MD020", "no-missing-space-closed-atx"],
      "description": "No space inside hashes on closed atx style heading",
      "tags": ["headings", "headers", "atx_closed", "spaces"],
      "function": function MD020(params, onError) {
        forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
          if (!inCode) {
            const match = /^(#+)([ \t]*)([^#]*?[^#\\])([ \t]*)((?:\\#)?)(#+)(\s*)$/.exec(line);
            if (match) {
              const [
                ,
                leftHash,
                { "length": leftSpaceLength },
                content,
                { "length": rightSpaceLength },
                rightEscape,
                rightHash,
                { "length": trailSpaceLength }
              ] = match;
              const leftHashLength = leftHash.length;
              const rightHashLength = rightHash.length;
              const left = !leftSpaceLength;
              const right = !rightSpaceLength || rightEscape;
              const rightEscapeReplacement = rightEscape ? `${rightEscape} ` : "";
              if (left || right) {
                const range = left ? [
                  1,
                  leftHashLength + 1
                ] : [
                  line.length - trailSpaceLength - rightHashLength,
                  rightHashLength + 1
                ];
                addErrorContext(
                  onError,
                  lineIndex + 1,
                  line.trim(),
                  left,
                  right,
                  range,
                  {
                    "editColumn": 1,
                    "deleteCount": line.length,
                    "insertText": `${leftHash} ${content} ${rightEscapeReplacement}${rightHash}`
                  }
                );
              }
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md021.js
var require_md021 = __commonJS({
  "node_modules/markdownlint/lib/md021.js"(exports, module2) {
    "use strict";
    var { addErrorContext, filterTokens, headingStyleFor } = require_helpers2();
    var closedAtxRe = /^(#+)([ \t]+)([^ \t]|[^ \t].*[^ \t])([ \t]+)(#+)(\s*)$/;
    module2.exports = {
      "names": ["MD021", "no-multiple-space-closed-atx"],
      "description": "Multiple spaces inside hashes on closed atx style heading",
      "tags": ["headings", "headers", "atx_closed", "spaces"],
      "function": function MD021(params, onError) {
        filterTokens(params, "heading_open", (token) => {
          if (headingStyleFor(token) === "atx_closed") {
            const { line, lineNumber } = token;
            const match = closedAtxRe.exec(line);
            if (match) {
              const [
                ,
                leftHash,
                { "length": leftSpaceLength },
                content,
                { "length": rightSpaceLength },
                rightHash,
                { "length": trailSpaceLength }
              ] = match;
              const left = leftSpaceLength > 1;
              const right = rightSpaceLength > 1;
              if (left || right) {
                const length = line.length;
                const leftHashLength = leftHash.length;
                const rightHashLength = rightHash.length;
                const range = left ? [
                  1,
                  leftHashLength + leftSpaceLength + 1
                ] : [
                  length - trailSpaceLength - rightHashLength - rightSpaceLength,
                  rightSpaceLength + rightHashLength + 1
                ];
                addErrorContext(
                  onError,
                  lineNumber,
                  line.trim(),
                  left,
                  right,
                  range,
                  {
                    "editColumn": 1,
                    "deleteCount": length,
                    "insertText": `${leftHash} ${content} ${rightHash}`
                  }
                );
              }
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md022.js
var require_md022 = __commonJS({
  "node_modules/markdownlint/lib/md022.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, blockquotePrefixRe, filterTokens, isBlankLine } = require_helpers2();
    var getBlockQuote = (str2, count) => (str2 || "").match(blockquotePrefixRe)[0].trimEnd().concat("\n").repeat(count);
    module2.exports = {
      "names": ["MD022", "blanks-around-headings", "blanks-around-headers"],
      "description": "Headings should be surrounded by blank lines",
      "tags": ["headings", "headers", "blank_lines"],
      "function": function MD022(params, onError) {
        let linesAbove = params.config.lines_above;
        linesAbove = Number(linesAbove === void 0 ? 1 : linesAbove);
        let linesBelow = params.config.lines_below;
        linesBelow = Number(linesBelow === void 0 ? 1 : linesBelow);
        const { lines } = params;
        filterTokens(params, "heading_open", (token) => {
          const [topIndex, nextIndex] = token.map;
          let actualAbove = 0;
          for (let i = 0; i < linesAbove; i++) {
            if (isBlankLine(lines[topIndex - i - 1])) {
              actualAbove++;
            }
          }
          addErrorDetailIf(
            onError,
            topIndex + 1,
            linesAbove,
            actualAbove,
            "Above",
            lines[topIndex].trim(),
            null,
            {
              "insertText": getBlockQuote(lines[topIndex - 1], linesAbove - actualAbove)
            }
          );
          let actualBelow = 0;
          for (let i = 0; i < linesBelow; i++) {
            if (isBlankLine(lines[nextIndex + i])) {
              actualBelow++;
            }
          }
          addErrorDetailIf(
            onError,
            topIndex + 1,
            linesBelow,
            actualBelow,
            "Below",
            lines[topIndex].trim(),
            null,
            {
              "lineNumber": nextIndex + 1,
              "insertText": getBlockQuote(lines[nextIndex], linesBelow - actualBelow)
            }
          );
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md023.js
var require_md023 = __commonJS({
  "node_modules/markdownlint/lib/md023.js"(exports, module2) {
    "use strict";
    var { addErrorContext, filterTokens } = require_helpers2();
    var spaceBeforeHeadingRe = /^(\s+|[>\s]+\s\s)[^>\s]/;
    module2.exports = {
      "names": ["MD023", "heading-start-left", "header-start-left"],
      "description": "Headings must start at the beginning of the line",
      "tags": ["headings", "headers", "spaces"],
      "function": function MD023(params, onError) {
        filterTokens(params, "heading_open", function forToken(token) {
          const { lineNumber, line } = token;
          const match = line.match(spaceBeforeHeadingRe);
          if (match) {
            const [prefixAndFirstChar, prefix] = match;
            let deleteCount = prefix.length;
            const prefixLengthNoSpace = prefix.trimEnd().length;
            if (prefixLengthNoSpace) {
              deleteCount -= prefixLengthNoSpace - 1;
            }
            addErrorContext(
              onError,
              lineNumber,
              line,
              null,
              null,
              [1, prefixAndFirstChar.length],
              {
                "editColumn": prefixLengthNoSpace + 1,
                "deleteCount": deleteCount
              }
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md024.js
var require_md024 = __commonJS({
  "node_modules/markdownlint/lib/md024.js"(exports, module2) {
    "use strict";
    var { addErrorContext, forEachHeading } = require_helpers2();
    module2.exports = {
      "names": ["MD024", "no-duplicate-heading", "no-duplicate-header"],
      "description": "Multiple headings with the same content",
      "tags": ["headings", "headers"],
      "function": function MD024(params, onError) {
        const siblingsOnly = !!params.config.siblings_only || !!params.config.allow_different_nesting || false;
        const knownContents = [null, []];
        let lastLevel = 1;
        let knownContent = knownContents[lastLevel];
        forEachHeading(params, (heading, content) => {
          if (siblingsOnly) {
            const newLevel = heading.tag.slice(1);
            while (lastLevel < newLevel) {
              lastLevel++;
              knownContents[lastLevel] = [];
            }
            while (lastLevel > newLevel) {
              knownContents[lastLevel] = [];
              lastLevel--;
            }
            knownContent = knownContents[newLevel];
          }
          if (knownContent.includes(content)) {
            addErrorContext(
              onError,
              heading.lineNumber,
              heading.line.trim()
            );
          } else {
            knownContent.push(content);
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md025.js
var require_md025 = __commonJS({
  "node_modules/markdownlint/lib/md025.js"(exports, module2) {
    "use strict";
    var { addErrorContext, filterTokens, frontMatterHasTitle } = require_helpers2();
    module2.exports = {
      "names": ["MD025", "single-title", "single-h1"],
      "description": "Multiple top-level headings in the same document",
      "tags": ["headings", "headers"],
      "function": function MD025(params, onError) {
        const level = Number(params.config.level || 1);
        const tag = "h" + level;
        const foundFrontMatterTitle = frontMatterHasTitle(
          params.frontMatterLines,
          params.config.front_matter_title
        );
        let hasTopLevelHeading = false;
        filterTokens(params, "heading_open", function forToken(token) {
          if (token.tag === tag) {
            if (hasTopLevelHeading || foundFrontMatterTitle) {
              addErrorContext(
                onError,
                token.lineNumber,
                token.line.trim()
              );
            } else if (token.lineNumber === 1) {
              hasTopLevelHeading = true;
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md026.js
var require_md026 = __commonJS({
  "node_modules/markdownlint/lib/md026.js"(exports, module2) {
    "use strict";
    var { addError, allPunctuationNoQuestion, escapeForRegExp, forEachHeading } = require_helpers2();
    var endOfLineHtmlEntityRe = /&#?[\da-zA-Z]+;$/;
    module2.exports = {
      "names": ["MD026", "no-trailing-punctuation"],
      "description": "Trailing punctuation in heading",
      "tags": ["headings", "headers"],
      "function": function MD026(params, onError) {
        let punctuation = params.config.punctuation;
        punctuation = String(
          punctuation === void 0 ? allPunctuationNoQuestion : punctuation
        );
        const trailingPunctuationRe = new RegExp("\\s*[" + escapeForRegExp(punctuation) + "]+$");
        forEachHeading(params, (heading) => {
          const { line, lineNumber } = heading;
          const trimmedLine = line.replace(/([^\s#])[\s#]+$/, "$1");
          const match = trailingPunctuationRe.exec(trimmedLine);
          if (match && !endOfLineHtmlEntityRe.test(trimmedLine)) {
            const fullMatch = match[0];
            const column = match.index + 1;
            const length = fullMatch.length;
            addError(
              onError,
              lineNumber,
              `Punctuation: '${fullMatch}'`,
              null,
              [column, length],
              {
                "editColumn": column,
                "deleteCount": length
              }
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md027.js
var require_md027 = __commonJS({
  "node_modules/markdownlint/lib/md027.js"(exports, module2) {
    "use strict";
    var { addErrorContext, newLineRe } = require_helpers2();
    var spaceAfterBlockQuoteRe = /^((?:\s*>)+)(\s{2,})\S/;
    module2.exports = {
      "names": ["MD027", "no-multiple-space-blockquote"],
      "description": "Multiple spaces after blockquote symbol",
      "tags": ["blockquote", "whitespace", "indentation"],
      "function": function MD027(params, onError) {
        let blockquoteNesting = 0;
        let listItemNesting = 0;
        for (const token of params.parsers.markdownit.tokens) {
          const { content, lineNumber, type: type2 } = token;
          if (type2 === "blockquote_open") {
            blockquoteNesting++;
          } else if (type2 === "blockquote_close") {
            blockquoteNesting--;
          } else if (type2 === "list_item_open") {
            listItemNesting++;
          } else if (type2 === "list_item_close") {
            listItemNesting--;
          } else if (type2 === "inline" && blockquoteNesting) {
            const lineCount = content.split(newLineRe).length;
            for (let i = 0; i < lineCount; i++) {
              const line = params.lines[lineNumber + i - 1];
              const match = line.match(spaceAfterBlockQuoteRe);
              if (match) {
                const [
                  fullMatch,
                  { "length": blockquoteLength },
                  { "length": spaceLength }
                ] = match;
                if (!listItemNesting || fullMatch[fullMatch.length - 1] === ">") {
                  addErrorContext(
                    onError,
                    lineNumber + i,
                    line,
                    null,
                    null,
                    [1, fullMatch.length],
                    {
                      "editColumn": blockquoteLength + 1,
                      "deleteCount": spaceLength - 1
                    }
                  );
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md028.js
var require_md028 = __commonJS({
  "node_modules/markdownlint/lib/md028.js"(exports, module2) {
    "use strict";
    var { addError } = require_helpers2();
    module2.exports = {
      "names": ["MD028", "no-blanks-blockquote"],
      "description": "Blank line inside blockquote",
      "tags": ["blockquote", "whitespace"],
      "function": function MD028(params, onError) {
        let prevToken = {};
        let prevLineNumber = null;
        for (const token of params.parsers.markdownit.tokens) {
          if (token.type === "blockquote_open" && prevToken.type === "blockquote_close") {
            for (let lineNumber = prevLineNumber; lineNumber < token.lineNumber; lineNumber++) {
              addError(onError, lineNumber);
            }
          }
          prevToken = token;
          if (token.type === "blockquote_open") {
            prevLineNumber = token.map[1] + 1;
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md029.js
var require_md029 = __commonJS({
  "node_modules/markdownlint/lib/md029.js"(exports, module2) {
    "use strict";
    var {
      addErrorDetailIf,
      listItemMarkerRe,
      orderedListItemMarkerRe,
      rangeFromRegExp
    } = require_helpers2();
    var { flattenedLists } = require_cache();
    var listStyleExamples = {
      "one": "1/1/1",
      "ordered": "1/2/3",
      "zero": "0/0/0"
    };
    module2.exports = {
      "names": ["MD029", "ol-prefix"],
      "description": "Ordered list item prefix",
      "tags": ["ol"],
      "function": function MD029(params, onError) {
        const style = String(params.config.style || "one_or_ordered");
        const filteredLists = flattenedLists().filter((list) => !list.unordered);
        for (const list of filteredLists) {
          const { items } = list;
          let current = 1;
          let incrementing = false;
          if (items.length >= 2) {
            const first = orderedListItemMarkerRe.exec(items[0].line);
            const second = orderedListItemMarkerRe.exec(items[1].line);
            if (first && second) {
              const [, firstNumber] = first;
              const [, secondNumber] = second;
              if (secondNumber !== "1" || firstNumber === "0") {
                incrementing = true;
                if (firstNumber === "0") {
                  current = 0;
                }
              }
            }
          }
          let listStyle = style;
          if (listStyle === "one_or_ordered") {
            listStyle = incrementing ? "ordered" : "one";
          }
          if (listStyle === "zero") {
            current = 0;
          } else if (listStyle === "one") {
            current = 1;
          }
          for (const item of items) {
            const match = orderedListItemMarkerRe.exec(item.line);
            if (match) {
              addErrorDetailIf(
                onError,
                item.lineNumber,
                String(current),
                match[1],
                "Style: " + listStyleExamples[listStyle],
                null,
                rangeFromRegExp(item.line, listItemMarkerRe)
              );
              if (listStyle === "ordered") {
                current++;
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md030.js
var require_md030 = __commonJS({
  "node_modules/markdownlint/lib/md030.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf } = require_helpers2();
    var { flattenedLists } = require_cache();
    module2.exports = {
      "names": ["MD030", "list-marker-space"],
      "description": "Spaces after list markers",
      "tags": ["ol", "ul", "whitespace"],
      "function": function MD030(params, onError) {
        const ulSingle = Number(params.config.ul_single || 1);
        const olSingle = Number(params.config.ol_single || 1);
        const ulMulti = Number(params.config.ul_multi || 1);
        const olMulti = Number(params.config.ol_multi || 1);
        for (const list of flattenedLists()) {
          const lineCount = list.lastLineIndex - list.open.map[0];
          const allSingle = lineCount === list.items.length;
          const expectedSpaces = list.unordered ? allSingle ? ulSingle : ulMulti : allSingle ? olSingle : olMulti;
          for (const item of list.items) {
            const { line, lineNumber } = item;
            const match = /^[\s>]*\S+(\s*)/.exec(line);
            const [{ "length": matchLength }, { "length": actualSpaces }] = match;
            if (matchLength < line.length) {
              let fixInfo = null;
              if (expectedSpaces !== actualSpaces) {
                fixInfo = {
                  "editColumn": matchLength - actualSpaces + 1,
                  "deleteCount": actualSpaces,
                  "insertText": "".padEnd(expectedSpaces)
                };
              }
              addErrorDetailIf(
                onError,
                lineNumber,
                expectedSpaces,
                actualSpaces,
                null,
                null,
                [1, matchLength],
                fixInfo
              );
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md031.js
var require_md031 = __commonJS({
  "node_modules/markdownlint/lib/md031.js"(exports, module2) {
    "use strict";
    var { addErrorContext, forEachLine, isBlankLine } = require_helpers2();
    var { lineMetadata } = require_cache();
    var codeFencePrefixRe = /^(.*?)[`~]/;
    module2.exports = {
      "names": ["MD031", "blanks-around-fences"],
      "description": "Fenced code blocks should be surrounded by blank lines",
      "tags": ["code", "blank_lines"],
      "function": function MD031(params, onError) {
        const listItems = params.config.list_items;
        const includeListItems = listItems === void 0 ? true : !!listItems;
        const { lines } = params;
        forEachLine(lineMetadata(), (line, i, inCode, onFence, inTable, inItem) => {
          const onTopFence = onFence > 0;
          const onBottomFence = onFence < 0;
          if ((includeListItems || !inItem) && (onTopFence && !isBlankLine(lines[i - 1]) || onBottomFence && !isBlankLine(lines[i + 1]))) {
            const [, prefix] = line.match(codeFencePrefixRe) || [];
            const fixInfo = prefix === void 0 ? null : {
              "lineNumber": i + (onTopFence ? 1 : 2),
              "insertText": `${prefix.replace(/[^>]/g, " ").trim()}
`
            };
            addErrorContext(
              onError,
              i + 1,
              lines[i].trim(),
              null,
              null,
              null,
              fixInfo
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md032.js
var require_md032 = __commonJS({
  "node_modules/markdownlint/lib/md032.js"(exports, module2) {
    "use strict";
    var { addErrorContext, blockquotePrefixRe, isBlankLine } = require_helpers2();
    var { flattenedLists } = require_cache();
    module2.exports = {
      "names": ["MD032", "blanks-around-lists"],
      "description": "Lists should be surrounded by blank lines",
      "tags": ["bullet", "ul", "ol", "blank_lines"],
      "function": function MD032(params, onError) {
        const { lines } = params;
        const filteredLists = flattenedLists().filter((list) => !list.nesting);
        for (const list of filteredLists) {
          const firstIndex = list.open.map[0];
          if (!isBlankLine(lines[firstIndex - 1])) {
            const line = lines[firstIndex];
            const quotePrefix = line.match(blockquotePrefixRe)[0].trimEnd();
            addErrorContext(
              onError,
              firstIndex + 1,
              line.trim(),
              null,
              null,
              null,
              {
                "insertText": `${quotePrefix}
`
              }
            );
          }
          const lastIndex = list.lastLineIndex - 1;
          if (!isBlankLine(lines[lastIndex + 1])) {
            const line = lines[lastIndex];
            const quotePrefix = line.match(blockquotePrefixRe)[0].trimEnd();
            addErrorContext(
              onError,
              lastIndex + 1,
              line.trim(),
              null,
              null,
              null,
              {
                "lineNumber": lastIndex + 2,
                "insertText": `${quotePrefix}
`
              }
            );
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md033.js
var require_md033 = __commonJS({
  "node_modules/markdownlint/lib/md033.js"(exports, module2) {
    "use strict";
    var { addError } = require_helpers2();
    var { filterByTypes, getHtmlTagInfo, parse } = require_micromark2();
    var nextLinesRe = /[\r\n][\s\S]*$/;
    module2.exports = {
      "names": ["MD033", "no-inline-html"],
      "description": "Inline HTML",
      "tags": ["html"],
      "function": function MD033(params, onError) {
        let allowedElements = params.config.allowed_elements;
        allowedElements = Array.isArray(allowedElements) ? allowedElements : [];
        allowedElements = allowedElements.map((element) => element.toLowerCase());
        const pending = [[0, params.parsers.micromark.tokens]];
        let current = null;
        while (current = pending.shift()) {
          const [offset, tokens] = current;
          for (const token of filterByTypes(tokens, ["htmlFlow", "htmlText"])) {
            if (token.type === "htmlText") {
              const htmlTagInfo = getHtmlTagInfo(token);
              if (htmlTagInfo && !htmlTagInfo.close && !allowedElements.includes(htmlTagInfo.name.toLowerCase())) {
                const range = [
                  token.startColumn,
                  token.text.replace(nextLinesRe, "").length
                ];
                addError(
                  onError,
                  token.startLine + offset,
                  "Element: " + htmlTagInfo.name,
                  void 0,
                  range
                );
              }
            } else {
              const options = {
                "extensions": [
                  {
                    "disable": {
                      "null": ["codeIndented", "htmlFlow"]
                    }
                  }
                ]
              };
              const lines = params.lines.slice(token.startLine - 1, token.endLine).join("\n");
              const flowTokens = parse(lines, options);
              pending.push(
                [token.startLine - 1, flowTokens]
              );
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md034.js
var require_md034 = __commonJS({
  "node_modules/markdownlint/lib/md034.js"(exports, module2) {
    "use strict";
    var { addErrorContext } = require_helpers2();
    var { filterByPredicate, getHtmlTagInfo } = require_micromark2();
    module2.exports = {
      "names": ["MD034", "no-bare-urls"],
      "description": "Bare URL used",
      "tags": ["links", "url"],
      "function": function MD034(params, onError) {
        const literalAutolinks = filterByPredicate(
          params.parsers.micromark.tokens,
          (token) => token.type === "literalAutolink",
          (token) => {
            const { children } = token;
            const result = [];
            for (let i = 0; i < children.length; i++) {
              const openToken = children[i];
              const openTagInfo = getHtmlTagInfo(openToken);
              if (openTagInfo && !openTagInfo.close) {
                let count = 1;
                for (let j = i + 1; j < children.length; j++) {
                  const closeToken = children[j];
                  const closeTagInfo = getHtmlTagInfo(closeToken);
                  if (closeTagInfo && openTagInfo.name === closeTagInfo.name) {
                    if (closeTagInfo.close) {
                      count--;
                      if (count === 0) {
                        i = j;
                        break;
                      }
                    } else {
                      count++;
                    }
                  }
                }
              } else {
                result.push(openToken);
              }
            }
            return result;
          }
        );
        for (const token of literalAutolinks) {
          const range = [
            token.startColumn,
            token.endColumn - token.startColumn
          ];
          const fixInfo = {
            "editColumn": range[0],
            "deleteCount": range[1],
            "insertText": `<${token.text}>`
          };
          addErrorContext(
            onError,
            token.startLine,
            token.text,
            null,
            null,
            range,
            fixInfo
          );
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md035.js
var require_md035 = __commonJS({
  "node_modules/markdownlint/lib/md035.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf } = require_helpers2();
    var { filterByTypes } = require_micromark2();
    module2.exports = {
      "names": ["MD035", "hr-style"],
      "description": "Horizontal rule style",
      "tags": ["hr"],
      "function": function MD035(params, onError) {
        let style = String(params.config.style || "consistent").trim();
        const thematicBreaks = filterByTypes(params.parsers.micromark.tokens, ["thematicBreak"]);
        for (const token of thematicBreaks) {
          const { startLine, text } = token;
          if (style === "consistent") {
            style = text;
          }
          addErrorDetailIf(onError, startLine, style, text);
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md036.js
var require_md036 = __commonJS({
  "node_modules/markdownlint/lib/md036.js"(exports, module2) {
    "use strict";
    var { addErrorContext, allPunctuation } = require_helpers2();
    module2.exports = {
      "names": ["MD036", "no-emphasis-as-heading", "no-emphasis-as-header"],
      "description": "Emphasis used instead of a heading",
      "tags": ["headings", "headers", "emphasis"],
      "function": function MD036(params, onError) {
        let punctuation = params.config.punctuation;
        punctuation = String(punctuation === void 0 ? allPunctuation : punctuation);
        const re = new RegExp("[" + punctuation + "]$");
        function base(token) {
          if (token.type === "paragraph_open") {
            return function inParagraph(t) {
              const children = t.children.filter(function notEmptyText(child) {
                return child.type !== "text" || child.content !== "";
              });
              if (children.length === 3 && (children[0].type === "strong_open" || children[0].type === "em_open") && children[1].type === "text" && !re.test(children[1].content)) {
                addErrorContext(
                  onError,
                  t.lineNumber,
                  children[1].content
                );
              }
              return base;
            };
          } else if (token.type === "blockquote_open") {
            return function inBlockquote(t) {
              if (t.type !== "blockquote_close") {
                return inBlockquote;
              }
              return base;
            };
          } else if (token.type === "list_item_open") {
            return function inListItem(t) {
              if (t.type !== "list_item_close") {
                return inListItem;
              }
              return base;
            };
          }
          return base;
        }
        let state = base;
        for (const token of params.parsers.markdownit.tokens) {
          state = state(token);
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md037.js
var require_md037 = __commonJS({
  "node_modules/markdownlint/lib/md037.js"(exports, module2) {
    "use strict";
    var {
      addErrorContext,
      emphasisMarkersInContent,
      forEachLine,
      isBlankLine,
      withinAnyRange
    } = require_helpers2();
    var { htmlElementRanges, lineMetadata } = require_cache();
    var emphasisRe = /(^|[^\\]|\\\\)(?:(\*{1,3})|(_{1,3}))/g;
    var embeddedUnderscoreRe = /([A-Za-z\d])_([A-Za-z\d])/g;
    var asteriskListItemMarkerRe = /^([\s>]*)\*(\s+)/;
    var leftSpaceRe = /^\s+/;
    var rightSpaceRe = /\s+$/;
    var tablePipeRe = /\|/;
    module2.exports = {
      "names": ["MD037", "no-space-in-emphasis"],
      "description": "Spaces inside emphasis markers",
      "tags": ["whitespace", "emphasis"],
      "function": function MD037(params, onError) {
        const exclusions = htmlElementRanges();
        let effectiveEmphasisLength, emphasisIndex, emphasisKind, emphasisLength, pendingError = null;
        function resetRunTracking() {
          emphasisIndex = -1;
          emphasisLength = 0;
          emphasisKind = "";
          effectiveEmphasisLength = 0;
          pendingError = null;
        }
        function handleRunEnd(line, lineIndex, contextLength, match, matchIndex, inTable) {
          let content = line.substring(emphasisIndex, matchIndex);
          if (!emphasisLength) {
            content = content.trimStart();
          }
          if (!match) {
            content = content.trimEnd();
          }
          const leftSpace = leftSpaceRe.test(content);
          const rightSpace = rightSpaceRe.test(content);
          if ((leftSpace || rightSpace) && (!inTable || !tablePipeRe.test(content))) {
            const contextStart = emphasisIndex - emphasisLength;
            const contextEnd = matchIndex + contextLength;
            const column = contextStart + 1;
            const length = contextEnd - contextStart;
            if (!withinAnyRange(exclusions, lineIndex, column, length)) {
              const context = line.substring(contextStart, contextEnd);
              const leftMarker = line.substring(contextStart, emphasisIndex);
              const rightMarker = match ? match[2] || match[3] : "";
              const fixedText = `${leftMarker}${content.trim()}${rightMarker}`;
              return [
                onError,
                lineIndex + 1,
                context,
                leftSpace,
                rightSpace,
                [column, length],
                {
                  "editColumn": column,
                  "deleteCount": length,
                  "insertText": fixedText
                }
              ];
            }
          }
          return null;
        }
        const ignoreMarkersByLine = emphasisMarkersInContent(params);
        resetRunTracking();
        forEachLine(
          lineMetadata(),
          (line, lineIndex, inCode, onFence, inTable, inItem, onBreak, inMath) => {
            const onItemStart = inItem === 1;
            if (inCode || onFence || inTable || onBreak || onItemStart || isBlankLine(line)) {
              resetRunTracking();
            }
            if (inCode || onFence || onBreak || inMath) {
              return;
            }
            let patchedLine = line.replace(embeddedUnderscoreRe, "$1 $2");
            if (onItemStart) {
              patchedLine = patchedLine.replace(asteriskListItemMarkerRe, "$1 $2");
            }
            let match = null;
            while (match = emphasisRe.exec(patchedLine)) {
              const ignoreMarkersForLine = ignoreMarkersByLine[lineIndex];
              const matchIndex = match.index + match[1].length;
              if (ignoreMarkersForLine.includes(matchIndex)) {
                continue;
              }
              const matchLength = match[0].length - match[1].length;
              const matchKind = (match[2] || match[3])[0];
              if (emphasisIndex === -1) {
                emphasisIndex = matchIndex + matchLength;
                emphasisLength = matchLength;
                emphasisKind = matchKind;
                effectiveEmphasisLength = matchLength;
              } else if (matchKind === emphasisKind) {
                if (matchLength === effectiveEmphasisLength) {
                  if (pendingError) {
                    addErrorContext(...pendingError);
                    pendingError = null;
                  }
                  const error = handleRunEnd(
                    line,
                    lineIndex,
                    effectiveEmphasisLength,
                    match,
                    matchIndex,
                    inTable
                  );
                  if (error) {
                    addErrorContext(...error);
                  }
                  resetRunTracking();
                } else if (matchLength === 3) {
                  effectiveEmphasisLength = matchLength - effectiveEmphasisLength;
                } else if (effectiveEmphasisLength === 3) {
                  effectiveEmphasisLength -= matchLength;
                } else {
                  effectiveEmphasisLength += matchLength;
                }
                if (emphasisRe.lastIndex > 1) {
                  emphasisRe.lastIndex--;
                }
              } else if (emphasisRe.lastIndex > 1) {
                emphasisRe.lastIndex--;
              }
            }
            if (emphasisIndex !== -1) {
              pendingError = pendingError || handleRunEnd(line, lineIndex, 0, null, line.length, inTable);
              emphasisIndex = 0;
              emphasisLength = 0;
            }
          }
        );
      }
    };
  }
});

// node_modules/markdownlint/lib/md038.js
var require_md038 = __commonJS({
  "node_modules/markdownlint/lib/md038.js"(exports, module2) {
    "use strict";
    var { addErrorContext } = require_helpers2();
    var { filterByTypes } = require_micromark2();
    var leftSpaceRe = /^\s(?:[^`]|$)/;
    var rightSpaceRe = /[^`]\s$/;
    var trimCodeText = (text, start, end) => {
      text = text.replace(/^\s+$/, "");
      if (start) {
        text = text.replace(/^\s+?(\s`|\S)/, "$1");
      }
      if (end) {
        text = text.replace(/(`\s|\S)\s+$/, "$1");
      }
      return text;
    };
    var tokenIfType = (token, type2) => token && token.type === type2 && token;
    module2.exports = {
      "names": ["MD038", "no-space-in-code"],
      "description": "Spaces inside code span elements",
      "tags": ["whitespace", "code"],
      "function": function MD038(params, onError) {
        const codeTextTokens = filterByTypes(params.parsers.micromark.tokens, ["codeText"]);
        for (const token of codeTextTokens) {
          const { children } = token;
          const first = 0;
          const last = children.length - 1;
          const startSequence = tokenIfType(children[first], "codeTextSequence");
          const endSequence = tokenIfType(children[last], "codeTextSequence");
          const startData = tokenIfType(children[first + 1], "codeTextData") || tokenIfType(children[first + 2], "codeTextData");
          const endData = tokenIfType(children[last - 1], "codeTextData") || tokenIfType(children[last - 2], "codeTextData");
          if (startSequence && endSequence && startData && endData) {
            const spaceLeft = leftSpaceRe.test(startData.text);
            const spaceRight = !spaceLeft && rightSpaceRe.test(endData.text);
            if (spaceLeft || spaceRight) {
              let lineNumber = startSequence.startLine;
              let range = null;
              let fixInfo = null;
              if (startSequence.startLine === endSequence.endLine) {
                range = [
                  startSequence.startColumn,
                  endSequence.endColumn - startSequence.startColumn
                ];
                fixInfo = {
                  "editColumn": startSequence.endColumn,
                  "deleteCount": endSequence.startColumn - startSequence.endColumn,
                  "insertText": trimCodeText(startData.text, true, true)
                };
              } else if (spaceLeft) {
                range = [
                  startSequence.startColumn,
                  startData.endColumn - startSequence.startColumn
                ];
                fixInfo = {
                  "editColumn": startSequence.endColumn,
                  "deleteCount": startData.endColumn - startData.startColumn,
                  "insertText": trimCodeText(startData.text, true, false)
                };
              } else {
                lineNumber = endSequence.endLine;
                range = [
                  endData.startColumn,
                  endSequence.endColumn - endData.startColumn
                ];
                fixInfo = {
                  "editColumn": endData.startColumn,
                  "deleteCount": endData.endColumn - endData.startColumn,
                  "insertText": trimCodeText(endData.text, false, true)
                };
              }
              const context = params.lines[lineNumber - 1].substring(range[0] - 1, range[0] - 1 + range[1]);
              addErrorContext(
                onError,
                lineNumber,
                context,
                spaceLeft,
                spaceRight,
                range,
                fixInfo
              );
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md039.js
var require_md039 = __commonJS({
  "node_modules/markdownlint/lib/md039.js"(exports, module2) {
    "use strict";
    var { addErrorContext, filterTokens } = require_helpers2();
    var spaceInLinkRe = /\[(?:\s[^\]]*|[^\]]*?\s)\](?=(\([^)]*\)|\[[^\]]*\]))/;
    module2.exports = {
      "names": ["MD039", "no-space-in-links"],
      "description": "Spaces inside link text",
      "tags": ["whitespace", "links"],
      "function": function MD039(params, onError) {
        filterTokens(params, "inline", (token) => {
          const { children } = token;
          let { lineNumber } = token;
          let inLink = false;
          let linkText = "";
          let lineIndex = 0;
          for (const child of children) {
            const { content, markup, type: type2 } = child;
            if (type2 === "link_open") {
              inLink = true;
              linkText = "";
            } else if (type2 === "link_close") {
              inLink = false;
              const left = linkText.trimStart().length !== linkText.length;
              const right = linkText.trimEnd().length !== linkText.length;
              if (left || right) {
                const line = params.lines[lineNumber - 1];
                let range = null;
                let fixInfo = null;
                const match = line.slice(lineIndex).match(spaceInLinkRe);
                if (match) {
                  const column = match.index + lineIndex + 1;
                  const length = match[0].length;
                  range = [column, length];
                  fixInfo = {
                    "editColumn": column + 1,
                    "deleteCount": length - 2,
                    "insertText": linkText.trim()
                  };
                  lineIndex = column + length - 1;
                }
                addErrorContext(
                  onError,
                  lineNumber,
                  `[${linkText}]`,
                  left,
                  right,
                  range,
                  fixInfo
                );
              }
            } else if (type2 === "softbreak" || type2 === "hardbreak") {
              lineNumber++;
              lineIndex = 0;
            } else if (inLink) {
              linkText += type2.endsWith("_inline") ? `${markup}${content}${markup}` : content || markup;
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md040.js
var require_md040 = __commonJS({
  "node_modules/markdownlint/lib/md040.js"(exports, module2) {
    "use strict";
    var { addError, addErrorContext, filterTokens } = require_helpers2();
    module2.exports = {
      "names": ["MD040", "fenced-code-language"],
      "description": "Fenced code blocks should have a language specified",
      "tags": ["code", "language"],
      "function": function MD040(params, onError) {
        let allowed = params.config.allowed_languages;
        allowed = Array.isArray(allowed) ? allowed : [];
        const languageOnly = !!params.config.language_only;
        filterTokens(params, "fence", function forToken(token) {
          const lang = token.info.trim().split(/\s+/u).shift();
          if (lang === "") {
            addErrorContext(onError, token.lineNumber, token.line);
          } else if (allowed.length > 0 && !allowed.includes(lang)) {
            addError(
              onError,
              token.lineNumber,
              `"${lang}" is not allowed`
            );
          }
          if (languageOnly && token.info !== lang) {
            addError(
              onError,
              token.lineNumber,
              `Info string contains more than language: "${token.info}"`
            );
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md041.js
var require_md041 = __commonJS({
  "node_modules/markdownlint/lib/md041.js"(exports, module2) {
    "use strict";
    var { addErrorContext, frontMatterHasTitle } = require_helpers2();
    module2.exports = {
      "names": ["MD041", "first-line-heading", "first-line-h1"],
      "description": "First line in a file should be a top-level heading",
      "tags": ["headings", "headers"],
      "function": function MD041(params, onError) {
        const level = Number(params.config.level || 1);
        const tag = "h" + level;
        const foundFrontMatterTitle = frontMatterHasTitle(
          params.frontMatterLines,
          params.config.front_matter_title
        );
        if (!foundFrontMatterTitle) {
          const htmlHeadingRe = new RegExp(`^<h${level}[ />]`, "i");
          params.parsers.markdownit.tokens.every((token) => {
            let isError = false;
            if (token.type === "html_block") {
              if (token.content.startsWith("<!--")) {
                return true;
              } else if (!htmlHeadingRe.test(token.content)) {
                isError = true;
              }
            } else if (token.type !== "heading_open" || token.tag !== tag) {
              isError = true;
            }
            if (isError) {
              addErrorContext(onError, token.lineNumber, token.line);
            }
            return false;
          });
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md042.js
var require_md042 = __commonJS({
  "node_modules/markdownlint/lib/md042.js"(exports, module2) {
    "use strict";
    var { addErrorContext, escapeForRegExp, filterTokens } = require_helpers2();
    module2.exports = {
      "names": ["MD042", "no-empty-links"],
      "description": "No empty links",
      "tags": ["links"],
      "function": function MD042(params, onError) {
        filterTokens(params, "inline", function forToken(token) {
          let inLink = false;
          let linkText = "";
          let emptyLink = false;
          for (const child of token.children) {
            if (child.type === "link_open") {
              inLink = true;
              linkText = "";
              for (const attr of child.attrs) {
                if (attr[0] === "href" && (!attr[1] || attr[1] === "#")) {
                  emptyLink = true;
                }
              }
            } else if (child.type === "link_close") {
              inLink = false;
              if (emptyLink) {
                let context = `[${linkText}]`;
                let range = null;
                const match = child.line.match(
                  new RegExp(`${escapeForRegExp(context)}\\((?:|#|<>)\\)`)
                );
                if (match) {
                  context = match[0];
                  range = [match.index + 1, match[0].length];
                }
                addErrorContext(
                  onError,
                  child.lineNumber,
                  context,
                  null,
                  null,
                  range
                );
                emptyLink = false;
              }
            } else if (inLink) {
              linkText += child.content;
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md043.js
var require_md043 = __commonJS({
  "node_modules/markdownlint/lib/md043.js"(exports, module2) {
    "use strict";
    var { addErrorContext, addErrorDetailIf, forEachHeading } = require_helpers2();
    module2.exports = {
      "names": ["MD043", "required-headings", "required-headers"],
      "description": "Required heading structure",
      "tags": ["headings", "headers"],
      "function": function MD043(params, onError) {
        const requiredHeadings = params.config.headings || params.config.headers;
        const matchCase = params.config.match_case || false;
        if (Array.isArray(requiredHeadings)) {
          const levels = {};
          for (const level of [1, 2, 3, 4, 5, 6]) {
            levels["h" + level] = "######".substr(-level);
          }
          let i = 0;
          let matchAny = false;
          let hasError = false;
          let anyHeadings = false;
          const getExpected = () => requiredHeadings[i++] || "[None]";
          const handleCase = (str2) => matchCase ? str2 : str2.toLowerCase();
          forEachHeading(params, (heading, content) => {
            if (!hasError) {
              anyHeadings = true;
              const actual = levels[heading.tag] + " " + content;
              const expected = getExpected();
              if (expected === "*") {
                const nextExpected = getExpected();
                if (handleCase(nextExpected) !== handleCase(actual)) {
                  matchAny = true;
                  i--;
                }
              } else if (expected === "+") {
                matchAny = true;
              } else if (handleCase(expected) === handleCase(actual)) {
                matchAny = false;
              } else if (matchAny) {
                i--;
              } else {
                addErrorDetailIf(
                  onError,
                  heading.lineNumber,
                  expected,
                  actual
                );
                hasError = true;
              }
            }
          });
          const extraHeadings = requiredHeadings.length - i;
          if (!hasError && (extraHeadings > 1 || extraHeadings === 1 && requiredHeadings[i] !== "*") && (anyHeadings || !requiredHeadings.every((heading) => heading === "*"))) {
            addErrorContext(
              onError,
              params.lines.length,
              requiredHeadings[i]
            );
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md044.js
var require_md044 = __commonJS({
  "node_modules/markdownlint/lib/md044.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, escapeForRegExp, withinAnyRange } = require_helpers2();
    var { filterByPredicate, filterByTypes, parse } = require_micromark2();
    var ignoredChildTypes = /* @__PURE__ */ new Set(
      ["codeFencedFence", "definition", "reference", "resource"]
    );
    module2.exports = {
      "names": ["MD044", "proper-names"],
      "description": "Proper names should have the correct capitalization",
      "tags": ["spelling"],
      "function": function MD044(params, onError) {
        let names = params.config.names;
        names = Array.isArray(names) ? names : [];
        names.sort((a, b) => b.length - a.length || a.localeCompare(b));
        const codeBlocks = params.config.code_blocks;
        const includeCodeBlocks = codeBlocks === void 0 ? true : !!codeBlocks;
        const htmlElements = params.config.html_elements;
        const includeHtmlElements = htmlElements === void 0 ? true : !!htmlElements;
        const scannedTypes = /* @__PURE__ */ new Set(["data", "htmlFlowData"]);
        if (includeCodeBlocks) {
          scannedTypes.add("codeFlowValue");
          scannedTypes.add("codeTextData");
        }
        const contentTokens = filterByPredicate(
          params.parsers.micromark.tokens,
          (token) => scannedTypes.has(token.type),
          (token) => {
            let { children } = token;
            if (!includeHtmlElements && token.type === "htmlFlow") {
              children = children.slice(1, -1);
            }
            return children.filter((t) => !ignoredChildTypes.has(t.type));
          }
        );
        const exclusions = [];
        const autoLinked = /* @__PURE__ */ new Set();
        for (const name of names) {
          const escapedName = escapeForRegExp(name);
          const startNamePattern = /^\W/.test(name) ? "" : "\\b_*";
          const endNamePattern = /\W$/.test(name) ? "" : "_*\\b";
          const namePattern = `(${startNamePattern})(${escapedName})${endNamePattern}`;
          const nameRe = new RegExp(namePattern, "gi");
          for (const token of contentTokens) {
            let match = null;
            while ((match = nameRe.exec(token.text)) !== null) {
              const [, leftMatch, nameMatch] = match;
              const index = token.startColumn - 1 + match.index + leftMatch.length;
              const length = nameMatch.length;
              const lineIndex = token.startLine - 1;
              if (!withinAnyRange(exclusions, lineIndex, index, length) && !names.includes(nameMatch)) {
                let urlRanges = [];
                if (!autoLinked.has(token)) {
                  urlRanges = filterByTypes(
                    parse(token.text),
                    ["literalAutolink"]
                  ).map(
                    (t) => [
                      lineIndex,
                      token.startColumn - 1 + t.startColumn - 1,
                      t.endColumn - t.startColumn
                    ]
                  );
                  exclusions.push(...urlRanges);
                  autoLinked.add(token);
                }
                if (!withinAnyRange(urlRanges, lineIndex, index, length)) {
                  const column = index + 1;
                  addErrorDetailIf(
                    onError,
                    token.startLine,
                    name,
                    nameMatch,
                    null,
                    null,
                    [column, length],
                    {
                      "editColumn": column,
                      "deleteCount": length,
                      "insertText": name
                    }
                  );
                }
              }
              exclusions.push([lineIndex, index, length]);
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md045.js
var require_md045 = __commonJS({
  "node_modules/markdownlint/lib/md045.js"(exports, module2) {
    "use strict";
    var { addError, forEachInlineChild } = require_helpers2();
    module2.exports = {
      "names": ["MD045", "no-alt-text"],
      "description": "Images should have alternate text (alt text)",
      "tags": ["accessibility", "images"],
      "function": function MD045(params, onError) {
        forEachInlineChild(params, "image", function forToken(token) {
          if (token.content === "") {
            addError(onError, token.lineNumber);
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md046.js
var require_md046 = __commonJS({
  "node_modules/markdownlint/lib/md046.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf } = require_helpers2();
    var tokenTypeToStyle = {
      "fence": "fenced",
      "code_block": "indented"
    };
    module2.exports = {
      "names": ["MD046", "code-block-style"],
      "description": "Code block style",
      "tags": ["code"],
      "function": function MD046(params, onError) {
        let expectedStyle = String(params.config.style || "consistent");
        const codeBlocksAndFences = params.parsers.markdownit.tokens.filter(
          (token) => token.type === "code_block" || token.type === "fence"
        );
        for (const token of codeBlocksAndFences) {
          const { lineNumber, type: type2 } = token;
          if (expectedStyle === "consistent") {
            expectedStyle = tokenTypeToStyle[type2];
          }
          addErrorDetailIf(
            onError,
            lineNumber,
            expectedStyle,
            tokenTypeToStyle[type2]
          );
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md047.js
var require_md047 = __commonJS({
  "node_modules/markdownlint/lib/md047.js"(exports, module2) {
    "use strict";
    var { addError, isBlankLine } = require_helpers2();
    module2.exports = {
      "names": ["MD047", "single-trailing-newline"],
      "description": "Files should end with a single newline character",
      "tags": ["blank_lines"],
      "function": function MD047(params, onError) {
        const lastLineNumber = params.lines.length;
        const lastLine = params.lines[lastLineNumber - 1];
        if (!isBlankLine(lastLine)) {
          addError(
            onError,
            lastLineNumber,
            null,
            null,
            [lastLine.length, 1],
            {
              "insertText": "\n",
              "editColumn": lastLine.length + 1
            }
          );
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md048.js
var require_md048 = __commonJS({
  "node_modules/markdownlint/lib/md048.js"(exports, module2) {
    "use strict";
    var { addErrorDetailIf, fencedCodeBlockStyleFor } = require_helpers2();
    module2.exports = {
      "names": ["MD048", "code-fence-style"],
      "description": "Code fence style",
      "tags": ["code"],
      "function": function MD048(params, onError) {
        const style = String(params.config.style || "consistent");
        let expectedStyle = style;
        const fenceTokens = params.parsers.markdownit.tokens.filter(
          (token) => token.type === "fence"
        );
        for (const fenceToken of fenceTokens) {
          const { lineNumber, markup } = fenceToken;
          if (expectedStyle === "consistent") {
            expectedStyle = fencedCodeBlockStyleFor(markup);
          }
          addErrorDetailIf(
            onError,
            lineNumber,
            expectedStyle,
            fencedCodeBlockStyleFor(markup)
          );
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md049-md050.js
var require_md049_md050 = __commonJS({
  "node_modules/markdownlint/lib/md049-md050.js"(exports, module2) {
    "use strict";
    var {
      addError,
      emphasisOrStrongStyleFor,
      forEachInlineChild,
      getNextChildToken,
      getRangeAndFixInfoIfFound
    } = require_helpers2();
    var impl = (params, onError, tagPrefix, asterisk, underline, style) => {
      let lastLineNumber = -1;
      const instances = /* @__PURE__ */ new Map();
      forEachInlineChild(params, `${tagPrefix}_open`, (token, parent) => {
        const { lineNumber, markup } = token;
        const markupStyle = emphasisOrStrongStyleFor(markup);
        if (style === "consistent") {
          style = markupStyle;
        }
        if (style !== markupStyle) {
          let rangeAndFixInfo = {};
          const contentToken = getNextChildToken(
            parent,
            token,
            "text",
            `${tagPrefix}_close`
          );
          if (contentToken) {
            const { content } = contentToken;
            const actual = `${markup}${content}${markup}`;
            const expectedMarkup = style === "asterisk" ? asterisk : underline;
            const expected = `${expectedMarkup}${content}${expectedMarkup}`;
            if (lastLineNumber !== lineNumber) {
              lastLineNumber = lineNumber;
              instances.clear();
            }
            const instance = (instances.get(expected) || 0) + 1;
            instances.set(expected, instance);
            rangeAndFixInfo = getRangeAndFixInfoIfFound(
              params.lines,
              lineNumber - 1,
              actual,
              expected,
              instance
            );
          }
          addError(
            onError,
            lineNumber,
            `Expected: ${style}; Actual: ${markupStyle}`,
            null,
            rangeAndFixInfo.range,
            rangeAndFixInfo.fixInfo
          );
        }
      });
    };
    module2.exports = [
      {
        "names": ["MD049", "emphasis-style"],
        "description": "Emphasis style should be consistent",
        "tags": ["emphasis"],
        "function": function MD049(params, onError) {
          const style = String(params.config.style || "consistent");
          return impl(params, onError, "em", "*", "_", style);
        }
      },
      {
        "names": ["MD050", "strong-style"],
        "description": "Strong style should be consistent",
        "tags": ["emphasis"],
        "function": function MD050(params, onError) {
          const style = String(params.config.style || "consistent");
          return impl(params, onError, "strong", "**", "__", style);
        }
      }
    ];
  }
});

// node_modules/markdownlint/lib/md051.js
var require_md051 = __commonJS({
  "node_modules/markdownlint/lib/md051.js"(exports, module2) {
    "use strict";
    var {
      addError,
      addErrorDetailIf,
      escapeForRegExp,
      filterTokens,
      forEachInlineChild,
      forEachHeading,
      htmlElementRe
    } = require_helpers2();
    var idRe = /\sid\s*=\s*['"]?([^'"\s>]+)/iu;
    var nameRe = /\sname\s*=\s*['"]?([^'"\s>]+)/iu;
    function convertHeadingToHTMLFragment(inline) {
      const inlineText = inline.children.filter((token) => token.type !== "html_inline").map((token) => token.content).join("");
      return "#" + encodeURIComponent(
        inlineText.toLowerCase().replace(
          /[^\p{Letter}\p{Mark}\p{Number}\p{Connector_Punctuation}\- ]/gu,
          ""
        ).replace(/ /gu, "-")
      );
    }
    module2.exports = {
      "names": ["MD051", "link-fragments"],
      "description": "Link fragments should be valid",
      "tags": ["links"],
      "function": function MD051(params, onError) {
        const fragments = /* @__PURE__ */ new Map();
        forEachHeading(params, (heading, content, inline) => {
          const fragment = convertHeadingToHTMLFragment(inline);
          const count = fragments.get(fragment) || 0;
          if (count) {
            fragments.set(`${fragment}-${count}`, 0);
          }
          fragments.set(fragment, count + 1);
        });
        const processHtmlToken = (token) => {
          let match = null;
          while ((match = htmlElementRe.exec(token.content)) !== null) {
            const [tag, , element] = match;
            const anchorMatch = idRe.exec(tag) || element.toLowerCase() === "a" && nameRe.exec(tag);
            if (anchorMatch) {
              fragments.set(`#${anchorMatch[1]}`, 0);
            }
          }
        };
        filterTokens(params, "html_block", processHtmlToken);
        forEachInlineChild(params, "html_inline", processHtmlToken);
        forEachInlineChild(params, "link_open", (token) => {
          const { attrs, lineNumber, line } = token;
          const href = attrs.find((attr) => attr[0] === "href");
          const id = href && href[1];
          if (id && id.length > 1 && id[0] === "#" && !fragments.has(id)) {
            let context = id;
            let range = null;
            let fixInfo = null;
            const match = line.match(
              new RegExp(`\\[.*?\\]\\(${escapeForRegExp(context)}\\)`)
            );
            if (match) {
              [context] = match;
              const index = match.index;
              const length = context.length;
              range = [index + 1, length];
              fixInfo = {
                "editColumn": index + (length - id.length),
                "deleteCount": id.length,
                "insertText": null
              };
            }
            const idLower = id.toLowerCase();
            const mixedCaseKey = [...fragments.keys()].find((key) => idLower === key.toLowerCase());
            if (mixedCaseKey) {
              (fixInfo || {}).insertText = mixedCaseKey;
              addErrorDetailIf(
                onError,
                lineNumber,
                mixedCaseKey,
                id,
                void 0,
                context,
                range,
                fixInfo
              );
            } else {
              addError(
                onError,
                lineNumber,
                void 0,
                context,
                // @ts-ignore
                range
              );
            }
          }
        });
      }
    };
  }
});

// node_modules/markdownlint/lib/md052.js
var require_md052 = __commonJS({
  "node_modules/markdownlint/lib/md052.js"(exports, module2) {
    "use strict";
    var { addError } = require_helpers2();
    var { referenceLinkImageData } = require_cache();
    module2.exports = {
      "names": ["MD052", "reference-links-images"],
      "description": "Reference links and images should use a label that is defined",
      "tags": ["images", "links"],
      "function": function MD052(params, onError) {
        const { lines } = params;
        const { references, definitions } = referenceLinkImageData();
        for (const reference of references.entries()) {
          const [label, datas] = reference;
          if (!definitions.has(label)) {
            for (const data of datas) {
              const [lineIndex, index, length] = data;
              const context = lines[lineIndex].slice(index, index + length);
              addError(
                onError,
                lineIndex + 1,
                `Missing link or image reference definition: "${label}"`,
                context,
                [index + 1, context.length]
              );
            }
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/md053.js
var require_md053 = __commonJS({
  "node_modules/markdownlint/lib/md053.js"(exports, module2) {
    "use strict";
    var { addError, ellipsify, linkReferenceDefinitionRe } = require_helpers2();
    var { referenceLinkImageData } = require_cache();
    module2.exports = {
      "names": ["MD053", "link-image-reference-definitions"],
      "description": "Link and image reference definitions should be needed",
      "tags": ["images", "links"],
      "function": function MD053(params, onError) {
        const ignored = new Set(params.config.ignored_definitions || ["//"]);
        const lines = params.lines;
        const { references, shortcuts, definitions, duplicateDefinitions } = referenceLinkImageData();
        const singleLineDefinition = (line) => line.replace(linkReferenceDefinitionRe, "").trim().length > 0;
        const deleteFixInfo = {
          "deleteCount": -1
        };
        for (const definition of definitions.entries()) {
          const [label, lineIndex] = definition;
          if (!ignored.has(label) && !references.has(label) && !shortcuts.has(label)) {
            const line = lines[lineIndex];
            addError(
              onError,
              lineIndex + 1,
              `Unused link or image reference definition: "${label}"`,
              ellipsify(line),
              [1, line.length],
              singleLineDefinition(line) ? deleteFixInfo : 0
            );
          }
        }
        for (const duplicateDefinition of duplicateDefinitions) {
          const [label, lineIndex] = duplicateDefinition;
          if (!ignored.has(label)) {
            const line = lines[lineIndex];
            addError(
              onError,
              lineIndex + 1,
              `Duplicate link or image reference definition: "${label}"`,
              ellipsify(line),
              [1, line.length],
              singleLineDefinition(line) ? deleteFixInfo : 0
            );
          }
        }
      }
    };
  }
});

// node_modules/markdownlint/lib/rules.js
var require_rules = __commonJS({
  "node_modules/markdownlint/lib/rules.js"(exports, module2) {
    "use strict";
    var { homepage, version } = require_constants();
    var rules = [
      require_md001(),
      require_md002(),
      require_md003(),
      require_md004(),
      require_md005(),
      require_md006(),
      require_md007(),
      require_md009(),
      require_md010(),
      require_md011(),
      require_md012(),
      require_md013(),
      require_md014(),
      require_md018(),
      require_md019(),
      require_md020(),
      require_md021(),
      require_md022(),
      require_md023(),
      require_md024(),
      require_md025(),
      require_md026(),
      require_md027(),
      require_md028(),
      require_md029(),
      require_md030(),
      require_md031(),
      require_md032(),
      require_md033(),
      require_md034(),
      require_md035(),
      require_md036(),
      require_md037(),
      require_md038(),
      require_md039(),
      require_md040(),
      require_md041(),
      require_md042(),
      require_md043(),
      require_md044(),
      require_md045(),
      require_md046(),
      require_md047(),
      require_md048(),
      ...require_md049_md050(),
      require_md051(),
      require_md052(),
      require_md053()
    ];
    for (const rule of rules) {
      const name = rule.names[0].toLowerCase();
      rule["information"] = new URL(`${homepage}/blob/v${version}/doc/${name}.md`);
    }
    module2.exports = rules;
  }
});

// node_modules/markdownlint/lib/markdownlint.js
var require_markdownlint = __commonJS({
  "node_modules/markdownlint/lib/markdownlint.js"(exports, module2) {
    "use strict";
    var path2 = require("path");
    var { promisify } = require("util");
    var markdownit = require_markdown_it();
    var micromark = require_micromark2();
    var { deprecatedRuleNames } = require_constants();
    var rules = require_rules();
    var helpers = require_helpers2();
    var cache = require_cache();
    var dynamicRequire = typeof __non_webpack_require__ === "undefined" ? require : (
      /* c8 ignore next */
      __non_webpack_require__
    );
    function validateRuleList(ruleList, synchronous) {
      let result = null;
      if (ruleList.length === rules.length) {
        return result;
      }
      const allIds = {};
      for (const [index, rule] of ruleList.entries()) {
        let newError = function(property) {
          return new Error(
            "Property '" + property + "' of custom rule at index " + customIndex + " is incorrect."
          );
        };
        const customIndex = index - rules.length;
        for (const property of ["names", "tags"]) {
          const value = rule[property];
          if (!result && (!value || !Array.isArray(value) || value.length === 0 || !value.every(helpers.isString) || value.some(helpers.isEmptyString))) {
            result = newError(property);
          }
        }
        for (const propertyInfo of [
          ["description", "string"],
          ["function", "function"]
        ]) {
          const property = propertyInfo[0];
          const value = rule[property];
          if (!result && (!value || typeof value !== propertyInfo[1])) {
            result = newError(property);
          }
        }
        if (!result && rule.information && Object.getPrototypeOf(rule.information) !== URL.prototype) {
          result = newError("information");
        }
        if (!result && rule.asynchronous !== void 0 && typeof rule.asynchronous !== "boolean") {
          result = newError("asynchronous");
        }
        if (!result && rule.asynchronous && synchronous) {
          result = new Error(
            "Custom rule " + rule.names.join("/") + " at index " + customIndex + " is asynchronous and can not be used in a synchronous context."
          );
        }
        if (!result) {
          for (const name of rule.names) {
            const nameUpper = name.toUpperCase();
            if (!result && allIds[nameUpper] !== void 0) {
              result = new Error("Name '" + name + "' of custom rule at index " + customIndex + " is already used as a name or tag.");
            }
            allIds[nameUpper] = true;
          }
          for (const tag of rule.tags) {
            const tagUpper = tag.toUpperCase();
            if (!result && allIds[tagUpper]) {
              result = new Error("Tag '" + tag + "' of custom rule at index " + customIndex + " is already used as a name.");
            }
            allIds[tagUpper] = false;
          }
        }
      }
      return result;
    }
    function newResults(ruleList) {
      const lintResults = {};
      function toString2(useAlias) {
        let ruleNameToRule = null;
        const results = [];
        const keys = Object.keys(lintResults);
        keys.sort();
        for (const file of keys) {
          const fileResults = lintResults[file];
          if (Array.isArray(fileResults)) {
            for (const result of fileResults) {
              const ruleMoniker = result.ruleNames ? result.ruleNames.join("/") : result.ruleName + "/" + result.ruleAlias;
              results.push(
                file + ": " + result.lineNumber + ": " + ruleMoniker + " " + result.ruleDescription + (result.errorDetail ? " [" + result.errorDetail + "]" : "") + (result.errorContext ? ' [Context: "' + result.errorContext + '"]' : "")
              );
            }
          } else {
            if (!ruleNameToRule) {
              ruleNameToRule = {};
              for (const rule of ruleList) {
                const ruleName = rule.names[0].toUpperCase();
                ruleNameToRule[ruleName] = rule;
              }
            }
            for (const [ruleName, ruleResults] of Object.entries(fileResults)) {
              const rule = ruleNameToRule[ruleName.toUpperCase()];
              for (const lineNumber of ruleResults) {
                const nameIndex = Math.min(useAlias ? 1 : 0, rule.names.length - 1);
                const result = file + ": " + lineNumber + ": " + // @ts-ignore
                rule.names[nameIndex] + " " + // @ts-ignore
                rule.description;
                results.push(result);
              }
            }
          }
        }
        return results.join("\n");
      }
      Object.defineProperty(lintResults, "toString", { "value": toString2 });
      return lintResults;
    }
    function removeFrontMatter(content, frontMatter) {
      let frontMatterLines = [];
      if (frontMatter) {
        const frontMatterMatch = content.match(frontMatter);
        if (frontMatterMatch && !frontMatterMatch.index) {
          const contentMatched = frontMatterMatch[0];
          content = content.slice(contentMatched.length);
          frontMatterLines = contentMatched.split(helpers.newLineRe);
          if (frontMatterLines.length > 0 && frontMatterLines[frontMatterLines.length - 1] === "") {
            frontMatterLines.length--;
          }
        }
      }
      return {
        "content": content,
        "frontMatterLines": frontMatterLines
      };
    }
    function freezeToken(token) {
      if (token.attrs) {
        for (const attr of token.attrs) {
          Object.freeze(attr);
        }
        Object.freeze(token.attrs);
      }
      if (token.children) {
        for (const child of token.children) {
          freezeToken(child);
        }
        Object.freeze(token.children);
      }
      if (token.map) {
        Object.freeze(token.map);
      }
      Object.freeze(token);
    }
    function annotateAndFreezeTokens(tokens, lines) {
      let trMap = null;
      for (const token of tokens) {
        if (token.type === "tr_open") {
          trMap = token.map;
        } else if (token.type === "tr_close") {
          trMap = null;
        }
        if (!token.map && trMap) {
          token.map = [...trMap];
        }
        if (token.map) {
          token.line = lines[token.map[0]];
          token.lineNumber = token.map[0] + 1;
          while (token.map[1] && !(lines[token.map[1] - 1] || "").trim()) {
            token.map[1]--;
          }
        }
        if (token.children) {
          const codeSpanExtraLines = [];
          if (token.children.some((child) => child.type === "code_inline")) {
            helpers.forEachInlineCodeSpan(token.content, (code) => {
              codeSpanExtraLines.push(code.split(helpers.newLineRe).length - 1);
            });
          }
          let lineNumber = token.lineNumber;
          for (const child of token.children) {
            child.lineNumber = lineNumber;
            child.line = lines[lineNumber - 1];
            if (child.type === "softbreak" || child.type === "hardbreak") {
              lineNumber++;
            } else if (child.type === "code_inline") {
              lineNumber += codeSpanExtraLines.shift();
            }
          }
        }
        freezeToken(token);
      }
      Object.freeze(tokens);
    }
    function mapAliasToRuleNames(ruleList) {
      const aliasToRuleNames = {};
      for (const rule of ruleList) {
        const ruleName = rule.names[0].toUpperCase();
        for (const name of rule.names) {
          const nameUpper = name.toUpperCase();
          aliasToRuleNames[nameUpper] = [ruleName];
        }
        for (const tag of rule.tags) {
          const tagUpper = tag.toUpperCase();
          const ruleNames = aliasToRuleNames[tagUpper] || [];
          ruleNames.push(ruleName);
          aliasToRuleNames[tagUpper] = ruleNames;
        }
      }
      return aliasToRuleNames;
    }
    function getEffectiveConfig(ruleList, config2, aliasToRuleNames) {
      const defaultKey = Object.keys(config2).filter(
        (key) => key.toUpperCase() === "DEFAULT"
      );
      const ruleDefault = defaultKey.length === 0 || !!config2[defaultKey[0]];
      const effectiveConfig = {};
      for (const rule of ruleList) {
        const ruleName = rule.names[0].toUpperCase();
        effectiveConfig[ruleName] = ruleDefault;
      }
      for (const ruleName of deprecatedRuleNames) {
        effectiveConfig[ruleName] = false;
      }
      for (const key of Object.keys(config2)) {
        let value = config2[key];
        if (value) {
          if (!(value instanceof Object)) {
            value = {};
          }
        } else {
          value = false;
        }
        const keyUpper = key.toUpperCase();
        for (const ruleName of aliasToRuleNames[keyUpper] || []) {
          effectiveConfig[ruleName] = value;
        }
      }
      return effectiveConfig;
    }
    function parseConfiguration(name, content, parsers) {
      let config2 = null;
      let message = "";
      const errors = [];
      let index = 0;
      (parsers || [JSON.parse]).every((parser) => {
        try {
          config2 = parser(content);
        } catch (error) {
          errors.push(`Parser ${index++}: ${error.message}`);
        }
        return !config2;
      });
      if (!config2) {
        errors.unshift(`Unable to parse '${name}'`);
        message = errors.join("; ");
      }
      return {
        config: config2,
        message
      };
    }
    function getEnabledRulesPerLineNumber(ruleList, lines, frontMatterLines, noInlineConfig, config2, configParsers, aliasToRuleNames) {
      let enabledRules = {};
      let capturedRules = {};
      const allRuleNames = [];
      const enabledRulesPerLineNumber = new Array(1 + frontMatterLines.length);
      function handleInlineConfig(input, forEachMatch, forEachLine) {
        for (const [lineIndex, line] of input.entries()) {
          if (!noInlineConfig) {
            let match = null;
            while (match = helpers.inlineCommentStartRe.exec(line)) {
              const action = match[2].toUpperCase();
              const startIndex = match.index + match[1].length;
              const endIndex = line.indexOf("-->", startIndex);
              if (endIndex === -1) {
                break;
              }
              const parameter = line.slice(startIndex, endIndex);
              forEachMatch(action, parameter, lineIndex + 1);
            }
          }
          if (forEachLine) {
            forEachLine();
          }
        }
      }
      function configureFile(action, parameter) {
        if (action === "CONFIGURE-FILE") {
          const { "config": parsed } = parseConfiguration(
            "CONFIGURE-FILE",
            parameter,
            configParsers
          );
          if (parsed) {
            config2 = {
              ...config2,
              ...parsed
            };
          }
        }
      }
      function applyEnableDisable(action, parameter, state) {
        state = { ...state };
        const enabled = action.startsWith("ENABLE");
        const trimmed = parameter && parameter.trim();
        const items = trimmed ? trimmed.toUpperCase().split(/\s+/) : allRuleNames;
        for (const nameUpper of items) {
          for (const ruleName of aliasToRuleNames[nameUpper] || []) {
            state[ruleName] = enabled;
          }
        }
        return state;
      }
      function enableDisableFile(action, parameter) {
        if (action === "ENABLE-FILE" || action === "DISABLE-FILE") {
          enabledRules = applyEnableDisable(action, parameter, enabledRules);
        }
      }
      function captureRestoreEnableDisable(action, parameter) {
        if (action === "CAPTURE") {
          capturedRules = enabledRules;
        } else if (action === "RESTORE") {
          enabledRules = capturedRules;
        } else if (action === "ENABLE" || action === "DISABLE") {
          enabledRules = applyEnableDisable(action, parameter, enabledRules);
        }
      }
      function updateLineState() {
        enabledRulesPerLineNumber.push(enabledRules);
      }
      function disableLineNextLine(action, parameter, lineNumber) {
        const disableLine = action === "DISABLE-LINE";
        const disableNextLine = action === "DISABLE-NEXT-LINE";
        if (disableLine || disableNextLine) {
          const nextLineNumber = frontMatterLines.length + lineNumber + (disableNextLine ? 1 : 0);
          enabledRulesPerLineNumber[nextLineNumber] = applyEnableDisable(
            action,
            parameter,
            enabledRulesPerLineNumber[nextLineNumber] || {}
          );
        }
      }
      handleInlineConfig([lines.join("\n")], configureFile);
      const effectiveConfig = getEffectiveConfig(
        ruleList,
        config2,
        aliasToRuleNames
      );
      for (const rule of ruleList) {
        const ruleName = rule.names[0].toUpperCase();
        allRuleNames.push(ruleName);
        enabledRules[ruleName] = !!effectiveConfig[ruleName];
      }
      capturedRules = enabledRules;
      handleInlineConfig(lines, enableDisableFile);
      handleInlineConfig(lines, captureRestoreEnableDisable, updateLineState);
      handleInlineConfig(lines, disableLineNextLine);
      return {
        effectiveConfig,
        enabledRulesPerLineNumber
      };
    }
    function lintContent(ruleList, aliasToRuleNames, name, content, md, config2, configParsers, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, callback) {
      content = content.replace(/^\uFEFF/, "");
      const removeFrontMatterResult = removeFrontMatter(content, frontMatter);
      const { frontMatterLines } = removeFrontMatterResult;
      content = removeFrontMatterResult.content;
      const { effectiveConfig, enabledRulesPerLineNumber } = getEnabledRulesPerLineNumber(
        ruleList,
        content.split(helpers.newLineRe),
        frontMatterLines,
        noInlineConfig,
        config2,
        configParsers,
        aliasToRuleNames
      );
      const markdownitTokens = md.parse(content, {});
      const micromarkTokens = micromark.parse(content);
      content = helpers.clearHtmlCommentText(content);
      const lines = content.split(helpers.newLineRe);
      annotateAndFreezeTokens(markdownitTokens, lines);
      const parsers = Object.freeze({
        "markdownit": Object.freeze({
          "tokens": markdownitTokens
        }),
        "micromark": Object.freeze({
          "tokens": micromarkTokens
        })
      });
      const paramsBase = {
        name,
        parsers,
        "tokens": markdownitTokens,
        "lines": Object.freeze(lines),
        "frontMatterLines": Object.freeze(frontMatterLines)
      };
      const lineMetadata = helpers.getLineMetadata(paramsBase);
      const codeBlockAndSpanRanges = helpers.codeBlockAndSpanRanges(paramsBase, lineMetadata);
      const flattenedLists = helpers.flattenLists(paramsBase.parsers.markdownit.tokens);
      const htmlElementRanges = helpers.htmlElementRanges(paramsBase, lineMetadata);
      const referenceLinkImageData = helpers.getReferenceLinkImageData(paramsBase);
      cache.set({
        codeBlockAndSpanRanges,
        flattenedLists,
        htmlElementRanges,
        lineMetadata,
        referenceLinkImageData
      });
      let results = [];
      function forRule(rule) {
        const ruleName = rule.names[0].toUpperCase();
        const params = {
          ...paramsBase,
          "config": effectiveConfig[ruleName]
        };
        function throwError2(property) {
          throw new Error(
            "Property '" + property + "' of onError parameter is incorrect."
          );
        }
        function onError(errorInfo) {
          if (!errorInfo || !helpers.isNumber(errorInfo.lineNumber) || errorInfo.lineNumber < 1 || errorInfo.lineNumber > lines.length) {
            throwError2("lineNumber");
          }
          const lineNumber = errorInfo.lineNumber + frontMatterLines.length;
          if (!enabledRulesPerLineNumber[lineNumber][ruleName]) {
            return;
          }
          if (errorInfo.detail && !helpers.isString(errorInfo.detail)) {
            throwError2("detail");
          }
          if (errorInfo.context && !helpers.isString(errorInfo.context)) {
            throwError2("context");
          }
          if (errorInfo.range && (!Array.isArray(errorInfo.range) || errorInfo.range.length !== 2 || !helpers.isNumber(errorInfo.range[0]) || errorInfo.range[0] < 1 || !helpers.isNumber(errorInfo.range[1]) || errorInfo.range[1] < 1 || errorInfo.range[0] + errorInfo.range[1] - 1 > lines[errorInfo.lineNumber - 1].length)) {
            throwError2("range");
          }
          const fixInfo = errorInfo.fixInfo;
          const cleanFixInfo = {};
          if (fixInfo) {
            if (!helpers.isObject(fixInfo)) {
              throwError2("fixInfo");
            }
            if (fixInfo.lineNumber !== void 0) {
              if (!helpers.isNumber(fixInfo.lineNumber) || fixInfo.lineNumber < 1 || fixInfo.lineNumber > lines.length) {
                throwError2("fixInfo.lineNumber");
              }
              cleanFixInfo.lineNumber = fixInfo.lineNumber + frontMatterLines.length;
            }
            const effectiveLineNumber = fixInfo.lineNumber || errorInfo.lineNumber;
            if (fixInfo.editColumn !== void 0) {
              if (!helpers.isNumber(fixInfo.editColumn) || fixInfo.editColumn < 1 || fixInfo.editColumn > lines[effectiveLineNumber - 1].length + 1) {
                throwError2("fixInfo.editColumn");
              }
              cleanFixInfo.editColumn = fixInfo.editColumn;
            }
            if (fixInfo.deleteCount !== void 0) {
              if (!helpers.isNumber(fixInfo.deleteCount) || fixInfo.deleteCount < -1 || fixInfo.deleteCount > lines[effectiveLineNumber - 1].length) {
                throwError2("fixInfo.deleteCount");
              }
              cleanFixInfo.deleteCount = fixInfo.deleteCount;
            }
            if (fixInfo.insertText !== void 0) {
              if (!helpers.isString(fixInfo.insertText)) {
                throwError2("fixInfo.insertText");
              }
              cleanFixInfo.insertText = fixInfo.insertText;
            }
          }
          results.push({
            lineNumber,
            "ruleName": rule.names[0],
            "ruleNames": rule.names,
            "ruleDescription": rule.description,
            "ruleInformation": rule.information ? rule.information.href : null,
            "errorDetail": errorInfo.detail || null,
            "errorContext": errorInfo.context || null,
            "errorRange": errorInfo.range ? [...errorInfo.range] : null,
            "fixInfo": fixInfo ? cleanFixInfo : null
          });
        }
        const catchCallsOnError = (error) => onError({
          "lineNumber": 1,
          "detail": `This rule threw an exception: ${error.message || error}`
        });
        const invokeRuleFunction = () => rule.function(params, onError);
        if (rule.asynchronous) {
          const ruleFunctionPromise = Promise.resolve().then(invokeRuleFunction);
          return handleRuleFailures ? ruleFunctionPromise.catch(catchCallsOnError) : ruleFunctionPromise;
        }
        try {
          invokeRuleFunction();
        } catch (error) {
          if (handleRuleFailures) {
            catchCallsOnError(error);
          } else {
            throw error;
          }
        }
        return null;
      }
      function formatResults() {
        results.sort((a, b) => a.ruleName.localeCompare(b.ruleName) || a.lineNumber - b.lineNumber);
        if (resultVersion < 3) {
          const noPrevious = {
            "ruleName": null,
            "lineNumber": -1
          };
          results = results.filter((error, index, array) => {
            delete error.fixInfo;
            const previous = array[index - 1] || noPrevious;
            return error.ruleName !== previous.ruleName || error.lineNumber !== previous.lineNumber;
          });
        }
        if (resultVersion === 0) {
          const dictionary = {};
          for (const error of results) {
            const ruleLines = dictionary[error.ruleName] || [];
            ruleLines.push(error.lineNumber);
            dictionary[error.ruleName] = ruleLines;
          }
          results = dictionary;
        } else if (resultVersion === 1) {
          for (const error of results) {
            error.ruleAlias = error.ruleNames[1] || error.ruleName;
            delete error.ruleNames;
          }
        } else {
          for (const error of results) {
            delete error.ruleName;
          }
        }
        return results;
      }
      const ruleListAsync = ruleList.filter((rule) => rule.asynchronous);
      const ruleListSync = ruleList.filter((rule) => !rule.asynchronous);
      const ruleListAsyncFirst = [
        ...ruleListAsync,
        ...ruleListSync
      ];
      const callbackSuccess = () => callback(null, formatResults());
      const callbackError = (error) => callback(error instanceof Error ? error : new Error(error));
      try {
        const ruleResults = ruleListAsyncFirst.map(forRule);
        if (ruleListAsync.length > 0) {
          Promise.all(ruleResults.slice(0, ruleListAsync.length)).then(callbackSuccess).catch(callbackError);
        } else {
          callbackSuccess();
        }
      } catch (error) {
        callbackError(error);
      } finally {
        cache.clear();
      }
    }
    function lintFile(ruleList, aliasToRuleNames, file, md, config2, configParsers, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, fs2, synchronous, callback) {
      function lintContentWrapper(err, content) {
        if (err) {
          return callback(err);
        }
        return lintContent(
          ruleList,
          aliasToRuleNames,
          file,
          content,
          md,
          config2,
          configParsers,
          frontMatter,
          handleRuleFailures,
          noInlineConfig,
          resultVersion,
          callback
        );
      }
      if (synchronous) {
        lintContentWrapper(null, fs2.readFileSync(file, "utf8"));
      } else {
        fs2.readFile(file, "utf8", lintContentWrapper);
      }
    }
    function lintInput(options, synchronous, callback) {
      options = options || {};
      callback = callback || function noop() {
      };
      const ruleList = rules.concat(options.customRules || []);
      const ruleErr = validateRuleList(ruleList, synchronous);
      if (ruleErr) {
        callback(ruleErr);
        return;
      }
      let files = [];
      if (Array.isArray(options.files)) {
        files = [...options.files];
      } else if (options.files) {
        files = [String(options.files)];
      }
      const strings = options.strings || {};
      const stringsKeys = Object.keys(strings);
      const config2 = options.config || { "default": true };
      const configParsers = options.configParsers || null;
      const frontMatter = options.frontMatter === void 0 ? helpers.frontMatterRe : options.frontMatter;
      const handleRuleFailures = !!options.handleRuleFailures;
      const noInlineConfig = !!options.noInlineConfig;
      const resultVersion = options.resultVersion === void 0 ? 3 : options.resultVersion;
      const md = markdownit({ "html": true });
      const markdownItPlugins = options.markdownItPlugins || [];
      for (const plugin of markdownItPlugins) {
        md.use(...plugin);
      }
      const fs2 = options.fs || require("fs");
      const aliasToRuleNames = mapAliasToRuleNames(ruleList);
      const results = newResults(ruleList);
      let done = false;
      let concurrency = 0;
      function lintWorker() {
        let currentItem = null;
        function lintWorkerCallback(err, result) {
          concurrency--;
          if (err) {
            done = true;
            return callback(err);
          }
          results[currentItem] = result;
          if (!synchronous) {
            lintWorker();
          }
          return null;
        }
        if (done) {
        } else if (files.length > 0) {
          concurrency++;
          currentItem = files.shift();
          lintFile(
            ruleList,
            aliasToRuleNames,
            currentItem,
            md,
            config2,
            configParsers,
            frontMatter,
            handleRuleFailures,
            noInlineConfig,
            resultVersion,
            fs2,
            synchronous,
            lintWorkerCallback
          );
        } else if (currentItem = stringsKeys.shift()) {
          concurrency++;
          lintContent(
            ruleList,
            aliasToRuleNames,
            currentItem,
            strings[currentItem] || "",
            md,
            config2,
            configParsers,
            frontMatter,
            handleRuleFailures,
            noInlineConfig,
            resultVersion,
            lintWorkerCallback
          );
        } else if (concurrency === 0) {
          done = true;
          return callback(null, results);
        }
        return null;
      }
      if (synchronous) {
        while (!done) {
          lintWorker();
        }
      } else {
        lintWorker();
        lintWorker();
        lintWorker();
        lintWorker();
        lintWorker();
        lintWorker();
        lintWorker();
        lintWorker();
      }
    }
    function markdownlint(options, callback) {
      return lintInput(options, false, callback);
    }
    var markdownlintPromisify = promisify && promisify(markdownlint);
    function markdownlintPromise(options) {
      return markdownlintPromisify(options);
    }
    function markdownlintSync(options) {
      let results = {};
      lintInput(options, true, function callback(error, res) {
        if (error) {
          throw error;
        }
        results = res;
      });
      return results;
    }
    function resolveConfigExtends(configFile, referenceId, fs2, callback) {
      const configFileDirname = path2.dirname(configFile);
      const resolvedExtendsFile = path2.resolve(configFileDirname, referenceId);
      fs2.access(resolvedExtendsFile, (err) => {
        if (err) {
          try {
            return callback(null, dynamicRequire.resolve(
              referenceId,
              { "paths": [configFileDirname] }
            ));
          } catch {
          }
        }
        return callback(null, resolvedExtendsFile);
      });
    }
    function resolveConfigExtendsSync(configFile, referenceId, fs2) {
      const configFileDirname = path2.dirname(configFile);
      const resolvedExtendsFile = path2.resolve(configFileDirname, referenceId);
      try {
        fs2.accessSync(resolvedExtendsFile);
        return resolvedExtendsFile;
      } catch {
      }
      try {
        return dynamicRequire.resolve(
          referenceId,
          { "paths": [configFileDirname] }
        );
      } catch {
      }
      return resolvedExtendsFile;
    }
    function readConfig(file, parsers, fs2, callback) {
      if (!callback) {
        if (fs2) {
          callback = fs2;
          fs2 = null;
        } else {
          callback = parsers;
          parsers = null;
        }
      }
      if (!fs2) {
        fs2 = require("fs");
      }
      const os = require("os");
      file = helpers.expandTildePath(file, os);
      fs2.readFile(file, "utf8", (err, content) => {
        if (err) {
          return callback(err);
        }
        const { config: config2, message } = parseConfiguration(file, content, parsers);
        if (!config2) {
          return callback(new Error(message));
        }
        const configExtends = config2.extends;
        if (configExtends) {
          delete config2.extends;
          return resolveConfigExtends(
            file,
            helpers.expandTildePath(configExtends, os),
            fs2,
            (_, resolvedExtends) => readConfig(
              // @ts-ignore
              resolvedExtends,
              parsers,
              fs2,
              (errr, extendsConfig) => {
                if (errr) {
                  return callback(errr);
                }
                return callback(null, {
                  ...extendsConfig,
                  ...config2
                });
              }
            )
          );
        }
        return callback(null, config2);
      });
    }
    var readConfigPromisify = promisify && promisify(readConfig);
    function readConfigPromise(file, parsers, fs2) {
      return readConfigPromisify(file, parsers, fs2);
    }
    function readConfigSync2(file, parsers, fs2) {
      if (!fs2) {
        fs2 = require("fs");
      }
      const os = require("os");
      file = helpers.expandTildePath(file, os);
      const content = fs2.readFileSync(file, "utf8");
      const { config: config2, message } = parseConfiguration(file, content, parsers);
      if (!config2) {
        throw new Error(message);
      }
      const configExtends = config2.extends;
      if (configExtends) {
        delete config2.extends;
        const resolvedExtends = resolveConfigExtendsSync(
          file,
          helpers.expandTildePath(configExtends, os),
          fs2
        );
        return {
          ...readConfigSync2(resolvedExtends, parsers, fs2),
          ...config2
        };
      }
      return config2;
    }
    function getVersion() {
      return require_constants().version;
    }
    markdownlint.sync = markdownlintSync;
    markdownlint.readConfig = readConfig;
    markdownlint.readConfigSync = readConfigSync2;
    markdownlint.getVersion = getVersion;
    markdownlint.promises = {
      "markdownlint": markdownlintPromise,
      "readConfig": readConfigPromise
    };
    module2.exports = markdownlint;
  }
});

// node_modules/markdownlint-rule-helpers/micromark.cjs
var require_micromark3 = __commonJS({
  "node_modules/markdownlint-rule-helpers/micromark.cjs"(exports, module2) {
    "use strict";
    var {
      gfmAutolinkLiteral,
      gfmFootnote,
      gfmTable,
      parse,
      postprocess,
      preprocess
      // @ts-ignore
    } = require_micromark();
    function getMicromarkEvents(markdown, options = {}) {
      options.extensions = options.extensions || [];
      options.extensions.push(gfmAutolinkLiteral, gfmFootnote(), gfmTable);
      const encoding = void 0;
      const eol = true;
      const parseContext = parse(options);
      parseContext.defined.includes = (searchElement) => searchElement.length > 0;
      const chunks = preprocess()(markdown, encoding, eol);
      const events = postprocess(parseContext.document().write(chunks));
      return events;
    }
    function micromarkParse(markdown, options = {}) {
      const events = getMicromarkEvents(markdown, options);
      const document = [];
      let current = {
        "children": document
      };
      const history = [current];
      for (const event of events) {
        const [kind, token, context] = event;
        const { type: type2, start, end } = token;
        const { "column": startColumn, "line": startLine } = start;
        const { "column": endColumn, "line": endLine } = end;
        let text = null;
        try {
          text = context.sliceSerialize(token);
        } catch {
        }
        if (kind === "enter") {
          const previous = current;
          history.push(previous);
          current = {
            type: type2,
            startLine,
            startColumn,
            endLine,
            endColumn,
            text,
            "children": []
          };
          previous.children.push(current);
        } else if (kind === "exit") {
          Object.freeze(current.children);
          Object.freeze(current);
          current = history.pop();
        }
      }
      Object.freeze(document);
      return document;
    }
    function filterByPredicate(tokens, allowed, transformChildren) {
      const result = [];
      const pending = [...tokens];
      let token = null;
      while (token = pending.shift()) {
        if (allowed(token)) {
          result.push(token);
        }
        if (token.children.length > 0) {
          const transformed = transformChildren ? transformChildren(token) : token.children;
          pending.unshift(...transformed);
        }
      }
      return result;
    }
    function filterByTypes(tokens, allowed) {
      return filterByPredicate(
        tokens,
        (token) => allowed.includes(token.type)
      );
    }
    function getHtmlTagInfo(token) {
      const htmlTagNameRe = /^<([^!>][^/\s>]*)/;
      if (token.type === "htmlText") {
        const match = htmlTagNameRe.exec(token.text);
        if (match) {
          const name = match[1];
          const close = name.startsWith("/");
          return {
            close,
            "name": close ? name.slice(1) : name
          };
        }
      }
      return null;
    }
    function getTokenTextByType(tokens, type2) {
      const filtered = tokens.filter((token) => token.type === type2);
      return filtered.length === 1 ? filtered[0].text : null;
    }
    function matchAndGetTokensByType(tokens, matchTypes, resultTypes) {
      if (tokens.length !== matchTypes.length) {
        return null;
      }
      resultTypes = resultTypes || matchTypes;
      const result = [];
      for (let i = 0; i < matchTypes.length; i++) {
        if (tokens[i].type !== matchTypes[i]) {
          return null;
        } else if (resultTypes.includes(matchTypes[i])) {
          result.push(tokens[i]);
        }
      }
      return result;
    }
    module2.exports = {
      "parse": micromarkParse,
      filterByPredicate,
      filterByTypes,
      getHtmlTagInfo,
      getMicromarkEvents,
      getTokenTextByType,
      matchAndGetTokensByType
    };
  }
});

// node_modules/markdownlint-rule-helpers/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/markdownlint-rule-helpers/helpers.js"(exports, module2) {
    "use strict";
    var micromark = require_micromark3();
    var newLineRe = /\r\n?|\n/g;
    module2.exports.newLineRe = newLineRe;
    module2.exports.frontMatterRe = // eslint-disable-next-line max-len
    /((^---\s*$[\s\S]*?^---\s*)|(^\+\+\+\s*$[\s\S]*?^(\+\+\+|\.\.\.)\s*)|(^\{\s*$[\s\S]*?^\}\s*))(\r\n|\r|\n|$)/m;
    var inlineCommentStartRe = (
      // eslint-disable-next-line max-len
      /(<!--\s*markdownlint-(disable|enable|capture|restore|disable-file|enable-file|disable-line|disable-next-line|configure-file))(?:\s|-->)/gi
    );
    module2.exports.inlineCommentStartRe = inlineCommentStartRe;
    var htmlElementRe = /<(([A-Za-z][A-Za-z\d-]*)(?:\s[^`>]*)?)\/?>/g;
    module2.exports.htmlElementRe = htmlElementRe;
    module2.exports.listItemMarkerRe = /^([\s>]*)(?:[*+-]|\d+[.)])\s+/;
    module2.exports.orderedListItemMarkerRe = /^[\s>]*0*(\d+)[.)]/;
    var emphasisMarkersRe = /[_*]/g;
    var blockquotePrefixRe = /^[>\s]*/;
    module2.exports.blockquotePrefixRe = blockquotePrefixRe;
    var linkReferenceDefinitionRe = /^ {0,3}\[([^\]]*[^\\])\]:/;
    module2.exports.linkReferenceDefinitionRe = linkReferenceDefinitionRe;
    var allPunctuation = ".,;:!?\u3002\uFF0C\uFF1B\uFF1A\uFF01\uFF1F";
    module2.exports.allPunctuation = allPunctuation;
    module2.exports.allPunctuationNoQuestion = allPunctuation.replace(/[?]/gu, "");
    module2.exports.isNumber = function isNumber(obj) {
      return typeof obj === "number";
    };
    module2.exports.isString = function isString(obj) {
      return typeof obj === "string";
    };
    module2.exports.isEmptyString = function isEmptyString(str2) {
      return str2.length === 0;
    };
    module2.exports.isObject = function isObject2(obj) {
      return obj !== null && typeof obj === "object" && !Array.isArray(obj);
    };
    function isBlankLine(line) {
      const startComment = "<!--";
      const endComment = "-->";
      const removeComments = (s) => {
        while (true) {
          const start = s.indexOf(startComment);
          const end = s.indexOf(endComment);
          if (end !== -1 && (start === -1 || end < start)) {
            s = s.slice(end + endComment.length);
          } else if (start !== -1 && end !== -1) {
            s = s.slice(0, start) + s.slice(end + endComment.length);
          } else if (start !== -1 && end === -1) {
            s = s.slice(0, start);
          } else {
            return s;
          }
        }
      };
      return !line || !line.trim() || !removeComments(line).replace(/>/g, "").trim();
    }
    module2.exports.isBlankLine = isBlankLine;
    module2.exports.numericSortAscending = function numericSortAscending(a, b) {
      return a - b;
    };
    module2.exports.includesSorted = function includesSorted(array, element) {
      let left = 0;
      let right = array.length - 1;
      while (left <= right) {
        const mid = left + right >> 1;
        if (array[mid] < element) {
          left = mid + 1;
        } else if (array[mid] > element) {
          right = mid - 1;
        } else {
          return true;
        }
      }
      return false;
    };
    var htmlCommentBegin = "<!--";
    var htmlCommentEnd = "-->";
    var safeCommentCharacter = ".";
    var startsWithPipeRe = /^ *\|/;
    var notCrLfRe = /[^\r\n]/g;
    var notSpaceCrLfRe = /[^ \r\n]/g;
    var trailingSpaceRe = / +[\r\n]/g;
    var replaceTrailingSpace = (s) => s.replace(notCrLfRe, safeCommentCharacter);
    module2.exports.clearHtmlCommentText = function clearHtmlCommentText(text) {
      let i = 0;
      while ((i = text.indexOf(htmlCommentBegin, i)) !== -1) {
        const j = text.indexOf(htmlCommentEnd, i + 2);
        if (j === -1) {
          break;
        }
        if (j > i + htmlCommentBegin.length) {
          const content = text.slice(i + htmlCommentBegin.length, j);
          const lastLf = text.lastIndexOf("\n", i) + 1;
          const preText = text.slice(lastLf, i);
          const isBlock = preText.trim().length === 0;
          const couldBeTable = startsWithPipeRe.test(preText);
          const spansTableCells = couldBeTable && content.includes("\n");
          const isValid = isBlock || !(spansTableCells || content.startsWith(">") || content.startsWith("->") || content.endsWith("-") || content.includes("--"));
          if (isValid) {
            const clearedContent = content.replace(notSpaceCrLfRe, safeCommentCharacter).replace(trailingSpaceRe, replaceTrailingSpace);
            text = text.slice(0, i + htmlCommentBegin.length) + clearedContent + text.slice(j);
          }
        }
        i = j + htmlCommentEnd.length;
      }
      return text;
    };
    module2.exports.escapeForRegExp = function escapeForRegExp(str2) {
      return str2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    };
    module2.exports.fencedCodeBlockStyleFor = function fencedCodeBlockStyleFor(markup) {
      switch (markup[0]) {
        case "~":
          return "tilde";
        default:
          return "backtick";
      }
    };
    module2.exports.emphasisOrStrongStyleFor = function emphasisOrStrongStyleFor(markup) {
      switch (markup[0]) {
        case "*":
          return "asterisk";
        default:
          return "underscore";
      }
    };
    function indentFor(token) {
      const line = token.line.replace(/^[\s>]*(> |>)/, "");
      return line.length - line.trimStart().length;
    }
    module2.exports.indentFor = indentFor;
    module2.exports.headingStyleFor = function headingStyleFor(token) {
      if (token.map[1] - token.map[0] === 1) {
        if (/[^\\]#\s*$/.test(token.line)) {
          return "atx_closed";
        }
        return "atx";
      }
      return "setext";
    };
    module2.exports.unorderedListStyleFor = function unorderedListStyleFor(token) {
      switch (token.markup) {
        case "-":
          return "dash";
        case "+":
          return "plus";
        default:
          return "asterisk";
      }
    };
    function filterTokens(params, type2, handler) {
      for (const token of params.parsers.markdownit.tokens) {
        if (token.type === type2) {
          handler(token);
        }
      }
    }
    module2.exports.filterTokens = filterTokens;
    function isMathBlock(token) {
      return (token.tag === "$$" || token.tag === "math") && token.type.startsWith("math_block") && !token.type.endsWith("_end");
    }
    module2.exports.isMathBlock = isMathBlock;
    module2.exports.getLineMetadata = function getLineMetadata(params) {
      const lineMetadata = params.lines.map(
        (line, index) => [line, index, false, 0, false, false, false, false]
      );
      filterTokens(params, "fence", (token) => {
        lineMetadata[token.map[0]][3] = 1;
        lineMetadata[token.map[1] - 1][3] = -1;
        for (let i = token.map[0] + 1; i < token.map[1] - 1; i++) {
          lineMetadata[i][2] = true;
        }
      });
      filterTokens(params, "code_block", (token) => {
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][2] = true;
        }
      });
      filterTokens(params, "table_open", (token) => {
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][4] = true;
        }
      });
      filterTokens(params, "list_item_open", (token) => {
        let count = 1;
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][5] = count;
          count++;
        }
      });
      filterTokens(params, "hr", (token) => {
        lineMetadata[token.map[0]][6] = true;
      });
      for (const token of params.parsers.markdownit.tokens.filter(isMathBlock)) {
        for (let i = token.map[0]; i < token.map[1]; i++) {
          lineMetadata[i][7] = true;
        }
      }
      return lineMetadata;
    };
    function forEachLine(lineMetadata, handler) {
      for (const metadata of lineMetadata) {
        handler(...metadata);
      }
    }
    module2.exports.forEachLine = forEachLine;
    module2.exports.flattenLists = function flattenLists(tokens) {
      const flattenedLists = [];
      const stack = [];
      let current = null;
      let nesting = 0;
      const nestingStack = [];
      let lastWithMap = { "map": [0, 1] };
      for (const token of tokens) {
        if (token.type === "bullet_list_open" || token.type === "ordered_list_open") {
          stack.push(current);
          current = {
            "unordered": token.type === "bullet_list_open",
            "parentsUnordered": !current || current.unordered && current.parentsUnordered,
            "open": token,
            "indent": indentFor(token),
            "parentIndent": current && current.indent || 0,
            "items": [],
            "nesting": nesting,
            "lastLineIndex": -1,
            "insert": flattenedLists.length
          };
          nesting++;
        } else if (token.type === "bullet_list_close" || token.type === "ordered_list_close") {
          current.lastLineIndex = lastWithMap.map[1];
          flattenedLists.splice(current.insert, 0, current);
          delete current.insert;
          current = stack.pop();
          nesting--;
        } else if (token.type === "list_item_open") {
          current.items.push(token);
        } else if (token.type === "blockquote_open") {
          nestingStack.push(nesting);
          nesting = 0;
        } else if (token.type === "blockquote_close") {
          nesting = nestingStack.pop() || 0;
        }
        if (token.map) {
          lastWithMap = token;
        }
      }
      return flattenedLists;
    };
    function forEachInlineChild(params, type2, handler) {
      filterTokens(params, "inline", (token) => {
        for (const child of token.children.filter((c) => c.type === type2)) {
          handler(child, token);
        }
      });
    }
    module2.exports.forEachInlineChild = forEachInlineChild;
    module2.exports.forEachHeading = function forEachHeading(params, handler) {
      let heading = null;
      for (const token of params.parsers.markdownit.tokens) {
        if (token.type === "heading_open") {
          heading = token;
        } else if (token.type === "heading_close") {
          heading = null;
        } else if (token.type === "inline" && heading) {
          handler(heading, token.content, token);
        }
      }
    };
    function forEachInlineCodeSpan(input, handler) {
      const backtickRe = /`+/g;
      let match = null;
      const backticksLengthAndIndex = [];
      while ((match = backtickRe.exec(input)) !== null) {
        backticksLengthAndIndex.push([match[0].length, match.index]);
      }
      const newLinesIndex = [];
      while ((match = newLineRe.exec(input)) !== null) {
        newLinesIndex.push(match.index);
      }
      let lineIndex = 0;
      let lineStartIndex = 0;
      let k = 0;
      for (let i = 0; i < backticksLengthAndIndex.length - 1; i++) {
        const [startLength, startIndex] = backticksLengthAndIndex[i];
        if (startIndex === 0 || input[startIndex - 1] !== "\\") {
          for (let j = i + 1; j < backticksLengthAndIndex.length; j++) {
            const [endLength, endIndex] = backticksLengthAndIndex[j];
            if (startLength === endLength) {
              for (; k < newLinesIndex.length; k++) {
                const newLineIndex = newLinesIndex[k];
                if (startIndex < newLineIndex) {
                  break;
                }
                lineIndex++;
                lineStartIndex = newLineIndex + 1;
              }
              const columnIndex = startIndex - lineStartIndex + startLength;
              handler(
                input.slice(startIndex + startLength, endIndex),
                lineIndex,
                columnIndex,
                startLength
              );
              i = j;
              break;
            }
          }
        }
      }
    }
    module2.exports.forEachInlineCodeSpan = forEachInlineCodeSpan;
    function ellipsify(text, start, end) {
      if (text.length <= 30) {
      } else if (start && end) {
        text = text.slice(0, 15) + "..." + text.slice(-15);
      } else if (end) {
        text = "..." + text.slice(-30);
      } else {
        text = text.slice(0, 30) + "...";
      }
      return text;
    }
    module2.exports.ellipsify = ellipsify;
    function addError(onError, lineNumber, detail, context, range, fixInfo) {
      onError({
        lineNumber,
        detail,
        context,
        range,
        fixInfo
      });
    }
    module2.exports.addError = addError;
    module2.exports.addErrorDetailIf = function addErrorDetailIf(onError, lineNumber, expected, actual, detail, context, range, fixInfo) {
      if (expected !== actual) {
        addError(
          onError,
          lineNumber,
          "Expected: " + expected + "; Actual: " + actual + (detail ? "; " + detail : ""),
          context,
          range,
          fixInfo
        );
      }
    };
    module2.exports.addErrorContext = function addErrorContext(onError, lineNumber, context, left, right, range, fixInfo) {
      context = ellipsify(context, left, right);
      addError(onError, lineNumber, void 0, context, range, fixInfo);
    };
    module2.exports.codeBlockAndSpanRanges = (params, lineMetadata) => {
      const exclusions = [];
      forEachLine(lineMetadata, (line, lineIndex, inCode, onFence) => {
        if (inCode && !onFence) {
          exclusions.push([lineIndex, 0, line.length]);
        }
      });
      filterTokens(params, "inline", (token) => {
        if (token.children.some((child) => child.type === "code_inline")) {
          const tokenLines = params.lines.slice(token.map[0], token.map[1]);
          forEachInlineCodeSpan(
            tokenLines.join("\n"),
            (code, lineIndex, columnIndex) => {
              const codeLines = code.split(newLineRe);
              for (const [i, line] of codeLines.entries()) {
                exclusions.push([
                  token.lineNumber - 1 + lineIndex + i,
                  i ? 0 : columnIndex,
                  line.length
                ]);
              }
            }
          );
        }
      });
      return exclusions;
    };
    module2.exports.htmlElementRanges = (params, lineMetadata) => {
      const exclusions = [];
      forEachLine(lineMetadata, (line, lineIndex, inCode) => {
        let match = null;
        while (!inCode && (match = htmlElementRe.exec(line)) !== null) {
          exclusions.push([lineIndex, match.index, match[0].length]);
        }
      });
      forEachInlineChild(params, "html_inline", (token, parent) => {
        const parentContent = parent.content;
        let tokenContent = token.content;
        const parentIndex = parentContent.indexOf(tokenContent);
        let deltaLines = 0;
        let indent = 0;
        for (let i = parentIndex - 1; i >= 0; i--) {
          if (parentContent[i] === "\n") {
            deltaLines++;
          } else if (deltaLines === 0) {
            indent++;
          }
        }
        let lineIndex = token.lineNumber - 1 + deltaLines;
        do {
          const index = tokenContent.indexOf("\n");
          const length = index === -1 ? tokenContent.length : index;
          exclusions.push([lineIndex, indent, length]);
          tokenContent = tokenContent.slice(length + 1);
          lineIndex++;
          indent = 0;
        } while (tokenContent.length > 0);
      });
      return exclusions;
    };
    var withinAnyRange = (ranges, lineIndex, index, length) => !ranges.every((span) => lineIndex !== span[0] || index < span[1] || index + length > span[1] + span[2]);
    module2.exports.withinAnyRange = withinAnyRange;
    module2.exports.rangeFromRegExp = function rangeFromRegExp(line, regexp) {
      let range = null;
      const match = line.match(regexp);
      if (match) {
        const column = match.index + 1;
        const length = match[0].length;
        range = [column, length];
      }
      return range;
    };
    module2.exports.frontMatterHasTitle = function frontMatterHasTitle(frontMatterLines, frontMatterTitlePattern) {
      const ignoreFrontMatter = frontMatterTitlePattern !== void 0 && !frontMatterTitlePattern;
      const frontMatterTitleRe = new RegExp(
        String(frontMatterTitlePattern || '^\\s*"?title"?\\s*[:=]'),
        "i"
      );
      return !ignoreFrontMatter && frontMatterLines.some((line) => frontMatterTitleRe.test(line));
    };
    function forEachLink(line, handler) {
      const findClosingSymbol = (index) => {
        const begin = line[index];
        const end = begin === "[" ? "]" : ")";
        let nesting = 0;
        let escaping2 = false;
        let pointy = false;
        for (let i = index + 1; i < line.length; i++) {
          const current = line[i];
          if (current === "\\") {
            escaping2 = !escaping2;
          } else if (!escaping2 && current === begin) {
            nesting++;
          } else if (!escaping2 && current === end) {
            if (nesting > 0) {
              nesting--;
            } else if (!pointy) {
              return i + 1;
            }
          } else if (i === index + 1 && begin === "(" && current === "<") {
            pointy = true;
          } else if (!escaping2 && pointy && current === ">") {
            pointy = false;
            nesting = 0;
          } else {
            escaping2 = false;
          }
        }
        return -1;
      };
      let escaping = false;
      for (let i = 0; i < line.length; i++) {
        const current = line[i];
        if (current === "\\") {
          escaping = !escaping;
        } else if (!escaping && current === "[") {
          const textEnd = findClosingSymbol(i);
          if (textEnd !== -1) {
            if (line[textEnd] === "(" || line[textEnd] === "[") {
              const destEnd = findClosingSymbol(textEnd);
              if (destEnd !== -1) {
                const link = line.slice(i, destEnd);
                const text = line.slice(i, textEnd);
                const dest = line.slice(textEnd, destEnd);
                handler(i, link, text, dest);
                i = destEnd;
              }
            }
            if (i < textEnd) {
              const text = line.slice(i, textEnd);
              handler(i, text, text);
              i = textEnd;
            }
          }
        } else {
          escaping = false;
        }
      }
    }
    module2.exports.forEachLink = forEachLink;
    function emphasisMarkersInContent(params) {
      const { lines } = params;
      const byLine = new Array(lines.length);
      for (const [tokenLineIndex, tokenLine] of lines.entries()) {
        const inLine = [];
        forEachLink(tokenLine, (index, match) => {
          let markerMatch = null;
          while (markerMatch = emphasisMarkersRe.exec(match)) {
            inLine.push(index + markerMatch.index);
          }
        });
        byLine[tokenLineIndex] = inLine;
      }
      filterTokens(params, "inline", (token) => {
        const { children, lineNumber, map: map2 } = token;
        if (children.some((child) => child.type === "code_inline")) {
          const tokenLines = lines.slice(map2[0], map2[1]);
          forEachInlineCodeSpan(
            tokenLines.join("\n"),
            (code, lineIndex, column, tickCount) => {
              const codeLines = code.split(newLineRe);
              for (const [codeLineIndex, codeLine] of codeLines.entries()) {
                const byLineIndex = lineNumber - 1 + lineIndex + codeLineIndex;
                const inLine = byLine[byLineIndex];
                const codeLineOffset = codeLineIndex ? 0 : column - 1 + tickCount;
                let match = null;
                while (match = emphasisMarkersRe.exec(codeLine)) {
                  inLine.push(codeLineOffset + match.index);
                }
                byLine[byLineIndex] = inLine;
              }
            }
          );
        }
      });
      return byLine;
    }
    module2.exports.emphasisMarkersInContent = emphasisMarkersInContent;
    function getReferenceLinkImageData(params) {
      const normalizeReference = (s) => s.toLowerCase().trim().replace(/\s+/g, " ");
      const definitions = /* @__PURE__ */ new Map();
      const definitionLineIndices = [];
      const duplicateDefinitions = [];
      const references = /* @__PURE__ */ new Map();
      const shortcuts = /* @__PURE__ */ new Map();
      const filteredTokens = micromark.filterByTypes(
        params.parsers.micromark.tokens,
        [
          // definitionLineIndices
          "definition",
          "gfmFootnoteDefinition",
          // definitions and definitionLineIndices
          "definitionLabelString",
          "gfmFootnoteDefinitionLabelString",
          // references and shortcuts
          "gfmFootnoteCall",
          "image",
          "link"
        ]
      );
      for (const token of filteredTokens) {
        let labelPrefix = "";
        switch (token.type) {
          case "definition":
          case "gfmFootnoteDefinition":
            for (let i = token.startLine; i <= token.endLine; i++) {
              definitionLineIndices.push(i - 1);
            }
            break;
          case "gfmFootnoteDefinitionLabelString":
            labelPrefix = "^";
          case "definitionLabelString":
            {
              const reference = normalizeReference(`${labelPrefix}${token.text}`);
              if (definitions.has(reference)) {
                duplicateDefinitions.push([reference, token.startLine - 1]);
              } else {
                definitions.set(reference, token.startLine - 1);
              }
            }
            break;
          case "gfmFootnoteCall":
          case "image":
          case "link":
            {
              let isShortcut = false;
              let isFullOrCollapsed = false;
              let labelText = null;
              let referenceStringText = null;
              const shortcutCandidate = micromark.matchAndGetTokensByType(token.children, ["label"]);
              if (shortcutCandidate) {
                labelText = micromark.getTokenTextByType(
                  shortcutCandidate[0].children,
                  "labelText"
                );
                isShortcut = labelText !== null;
              }
              const fullAndCollapsedCandidate = micromark.matchAndGetTokensByType(
                token.children,
                ["label", "reference"]
              );
              if (fullAndCollapsedCandidate) {
                labelText = micromark.getTokenTextByType(
                  fullAndCollapsedCandidate[0].children,
                  "labelText"
                );
                referenceStringText = micromark.getTokenTextByType(
                  fullAndCollapsedCandidate[1].children,
                  "referenceString"
                );
                isFullOrCollapsed = labelText !== null;
              }
              const footnote = micromark.matchAndGetTokensByType(
                token.children,
                [
                  "gfmFootnoteCallLabelMarker",
                  "gfmFootnoteCallMarker",
                  "gfmFootnoteCallString",
                  "gfmFootnoteCallLabelMarker"
                ],
                ["gfmFootnoteCallMarker", "gfmFootnoteCallString"]
              );
              if (footnote) {
                const callMarkerText = footnote[0].text;
                const callString = footnote[1].text;
                labelText = `${callMarkerText}${callString}`;
                isShortcut = true;
              }
              if (isShortcut || isFullOrCollapsed) {
                const referenceDatum = [
                  token.startLine - 1,
                  token.startColumn - 1,
                  token.text.length,
                  // @ts-ignore
                  labelText.length,
                  (referenceStringText || "").length
                ];
                const reference = normalizeReference(referenceStringText || labelText);
                const dictionary = isShortcut ? shortcuts : references;
                const referenceData = dictionary.get(reference) || [];
                referenceData.push(referenceDatum);
                dictionary.set(reference, referenceData);
              }
            }
            break;
        }
      }
      return {
        references,
        shortcuts,
        definitions,
        duplicateDefinitions,
        definitionLineIndices
      };
    }
    module2.exports.getReferenceLinkImageData = getReferenceLinkImageData;
    function getPreferredLineEnding(input, os) {
      let cr = 0;
      let lf = 0;
      let crlf = 0;
      const endings = input.match(newLineRe) || [];
      for (const ending of endings) {
        switch (ending) {
          case "\r":
            cr++;
            break;
          case "\n":
            lf++;
            break;
          case "\r\n":
            crlf++;
            break;
        }
      }
      let preferredLineEnding = null;
      if (!cr && !lf && !crlf) {
        preferredLineEnding = os && os.EOL || "\n";
      } else if (lf >= crlf && lf >= cr) {
        preferredLineEnding = "\n";
      } else if (crlf >= cr) {
        preferredLineEnding = "\r\n";
      } else {
        preferredLineEnding = "\r";
      }
      return preferredLineEnding;
    }
    module2.exports.getPreferredLineEnding = getPreferredLineEnding;
    function normalizeFixInfo(fixInfo, lineNumber) {
      return {
        "lineNumber": fixInfo.lineNumber || lineNumber,
        "editColumn": fixInfo.editColumn || 1,
        "deleteCount": fixInfo.deleteCount || 0,
        "insertText": fixInfo.insertText || ""
      };
    }
    function applyFix2(line, fixInfo, lineEnding) {
      const { editColumn, deleteCount, insertText } = normalizeFixInfo(fixInfo);
      const editIndex = editColumn - 1;
      return deleteCount === -1 ? null : line.slice(0, editIndex) + insertText.replace(/\n/g, lineEnding || "\n") + line.slice(editIndex + deleteCount);
    }
    module2.exports.applyFix = applyFix2;
    function applyFixes2(input, errors) {
      const lineEnding = getPreferredLineEnding(input, require("os"));
      const lines = input.split(newLineRe);
      let fixInfos = errors.filter((error) => error.fixInfo).map((error) => normalizeFixInfo(error.fixInfo, error.lineNumber));
      fixInfos.sort((a, b) => {
        const aDeletingLine = a.deleteCount === -1;
        const bDeletingLine = b.deleteCount === -1;
        return b.lineNumber - a.lineNumber || (aDeletingLine ? 1 : bDeletingLine ? -1 : 0) || b.editColumn - a.editColumn || b.insertText.length - a.insertText.length;
      });
      let lastFixInfo = {};
      fixInfos = fixInfos.filter((fixInfo) => {
        const unique = fixInfo.lineNumber !== lastFixInfo.lineNumber || fixInfo.editColumn !== lastFixInfo.editColumn || fixInfo.deleteCount !== lastFixInfo.deleteCount || fixInfo.insertText !== lastFixInfo.insertText;
        lastFixInfo = fixInfo;
        return unique;
      });
      lastFixInfo = {
        "lineNumber": -1
      };
      for (const fixInfo of fixInfos) {
        if (fixInfo.lineNumber === lastFixInfo.lineNumber && fixInfo.editColumn === lastFixInfo.editColumn && !fixInfo.insertText && fixInfo.deleteCount > 0 && lastFixInfo.insertText && !lastFixInfo.deleteCount) {
          fixInfo.insertText = lastFixInfo.insertText;
          lastFixInfo.lineNumber = 0;
        }
        lastFixInfo = fixInfo;
      }
      fixInfos = fixInfos.filter((fixInfo) => fixInfo.lineNumber);
      let lastLineIndex = -1;
      let lastEditIndex = -1;
      for (const fixInfo of fixInfos) {
        const { lineNumber, editColumn, deleteCount } = fixInfo;
        const lineIndex = lineNumber - 1;
        const editIndex = editColumn - 1;
        if (lineIndex !== lastLineIndex || deleteCount === -1 || editIndex + deleteCount <= lastEditIndex - (deleteCount > 0 ? 0 : 1)) {
          lines[lineIndex] = applyFix2(lines[lineIndex], fixInfo, lineEnding);
        }
        lastLineIndex = lineIndex;
        lastEditIndex = editIndex;
      }
      return lines.filter((line) => line !== null).join(lineEnding);
    }
    module2.exports.applyFixes = applyFixes2;
    module2.exports.getRangeAndFixInfoIfFound = (lines, lineIndex, search, replace, instance = 1) => {
      let range = null;
      let fixInfo = null;
      let searchIndex = -1;
      while (instance > 0) {
        searchIndex = lines[lineIndex].indexOf(search, searchIndex + 1);
        instance--;
      }
      if (searchIndex !== -1) {
        const column = searchIndex + 1;
        const length = search.length;
        range = [column, length];
        fixInfo = {
          "editColumn": column,
          "deleteCount": length,
          "insertText": replace
        };
      }
      return {
        range,
        fixInfo
      };
    };
    function getNextChildToken(parentToken, childToken, nextType, nextNextType) {
      const { children } = parentToken;
      const index = children.indexOf(childToken);
      if (index !== -1 && children.length > index + 2 && children[index + 1].type === nextType && children[index + 2].type === nextNextType) {
        return children[index + 1];
      }
      return null;
    }
    module2.exports.getNextChildToken = getNextChildToken;
    function expandTildePath(file, os) {
      const homedir = os && os.homedir && os.homedir();
      return homedir ? file.replace(/^~($|\/|\\)/, `${homedir}$1`) : file;
    }
    module2.exports.expandTildePath = expandTildePath;
  }
});

// node_modules/ini/ini.js
var require_ini = __commonJS({
  "node_modules/ini/ini.js"(exports) {
    exports.parse = exports.decode = decode;
    exports.stringify = exports.encode = encode;
    exports.safe = safe;
    exports.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || /* @__PURE__ */ Object.create(null);
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str2) {
      return str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str2) {
      var out = /* @__PURE__ */ Object.create(null);
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str2.split(/[\r\n]+/g);
      lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = /* @__PURE__ */ Object.create(null);
            return;
          }
          p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
          return;
        }
        var key = unsafe(match[2]);
        if (key === "__proto__")
          return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _2, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = /* @__PURE__ */ Object.create(null);
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "node_modules/rc/node_modules/strip-json-comments/index.js"(exports, module2) {
    "use strict";
    var singleComment = 1;
    var multiComment = 2;
    function stripWithoutWhitespace() {
      return "";
    }
    function stripWithWhitespace(str2, start, end) {
      return str2.slice(start, end).replace(/\S/g, " ");
    }
    module2.exports = function(str2, opts) {
      opts = opts || {};
      var currentChar;
      var nextChar;
      var insideString = false;
      var insideComment = false;
      var offset = 0;
      var ret = "";
      var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      for (var i = 0; i < str2.length; i++) {
        currentChar = str2[i];
        nextChar = str2[i + 1];
        if (!insideComment && currentChar === '"') {
          var escaped = str2[i - 1] === "\\" && str2[i - 2] !== "\\";
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentChar + nextChar === "//") {
          ret += str2.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
          i++;
          insideComment = false;
          ret += strip(str2, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === "\n") {
          insideComment = false;
          ret += strip(str2, offset, i);
          offset = i;
        } else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str2.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++;
          insideComment = false;
          ret += strip(str2, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return ret + (insideComment ? strip(str2.substr(offset)) : str2.substr(offset));
    };
  }
});

// node_modules/rc/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/rc/lib/utils.js"(exports) {
    "use strict";
    var fs2 = require("fs");
    var ini = require_ini();
    var path2 = require("path");
    var stripJsonComments = require_strip_json_comments();
    var parse = exports.parse = function(content) {
      if (/^\s*{/.test(content))
        return JSON.parse(stripJsonComments(content));
      return ini.parse(content);
    };
    var file = exports.file = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      for (var i in args)
        if ("string" !== typeof args[i])
          return;
      var file2 = path2.join.apply(null, args);
      var content;
      try {
        return fs2.readFileSync(file2, "utf-8");
      } catch (err) {
        return;
      }
    };
    var json2 = exports.json = function() {
      var content = file.apply(null, arguments);
      return content ? parse(content) : null;
    };
    var env = exports.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env2) {
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          var keypath = k.substring(l).split("__");
          var _emptyStringIndex;
          while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
            keypath.splice(_emptyStringIndex, 1);
          }
          var cursor = obj;
          keypath.forEach(function _buildSubObj(_subkey, i) {
            if (!_subkey || typeof cursor !== "object")
              return;
            if (i === keypath.length - 1)
              cursor[_subkey] = env2[k];
            if (cursor[_subkey] === void 0)
              cursor[_subkey] = {};
            cursor = cursor[_subkey];
          });
        }
      }
      return obj;
    };
    var find = exports.find = function() {
      var rel = path2.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path2.join(start, rel2);
        try {
          fs2.statSync(file2);
          return file2;
        } catch (err) {
          if (path2.dirname(start) !== start)
            return find2(path2.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    };
  }
});

// node_modules/minimist/index.js
var require_minimist = __commonJS({
  "node_modules/minimist/index.js"(exports, module2) {
    module2.exports = function(args, opts) {
      if (!opts)
        opts = {};
      var flags = { bools: {}, strings: {}, unknownFn: null };
      if (typeof opts["unknown"] === "function") {
        flags.unknownFn = opts["unknown"];
      }
      if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
        flags.allBools = true;
      } else {
        [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
          flags.bools[key2] = true;
        });
      }
      var aliases = {};
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        if (aliases[key2]) {
          flags.strings[aliases[key2]] = true;
        }
      });
      var defaults = opts["default"] || {};
      var argv = { _: [] };
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false)
            return;
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split("."), value2);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2))
            return;
          if (o[key2] === void 0)
            o[key2] = {};
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype)
            o[key2] = {};
          if (o[key2] === Array.prototype)
            o[key2] = [];
          o = o[key2];
        }
        var key2 = keys[keys.length - 1];
        if (isConstructorOrProto(o, key2))
          return;
        if (o === Object.prototype || o === Number.prototype || o === String.prototype)
          o = {};
        if (o === Array.prototype)
          o = [];
        if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
          o[key2] = value2;
        } else if (Array.isArray(o[key2])) {
          o[key2].push(value2);
        } else {
          o[key2] = [o[key2], value2];
        }
      }
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          var key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== "false";
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          var key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          var key = arg.match(/^--(.+)/)[1];
          var next = args[i + 1];
          if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, next, arg);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            var next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
              setArg(letters[j], next.split("=")[1], arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          var key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
              setArg(key, args[i + 1], arg);
              i++;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === "true", arg);
              i++;
            } else {
              setArg(key, flags.strings[key] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(
              flags.strings["_"] || !isNumber(arg) ? arg : Number(arg)
            );
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function(key2) {
        if (!hasKey(argv, key2.split("."))) {
          setKey(argv, key2.split("."), defaults[key2]);
          (aliases[key2] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults[key2]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = new Array();
        notFlags.forEach(function(key2) {
          argv["--"].push(key2);
        });
      } else {
        notFlags.forEach(function(key2) {
          argv._.push(key2);
        });
      }
      return argv;
    };
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return key === "constructor" && typeof obj[key] === "function" || key === "__proto__";
    }
  }
});

// node_modules/rc/index.js
var require_rc = __commonJS({
  "node_modules/rc/index.js"(exports, module2) {
    var cc = require_utils2();
    var join = require("path").join;
    var deepExtend = require_deep_extend();
    var etc = "/etc";
    var win = process.platform === "win32";
    var home = win ? process.env.USERPROFILE : process.env.HOME;
    module2.exports = function(name, defaults, argv, parse) {
      if ("string" !== typeof name)
        throw new Error("rc(name): name *must* be string");
      if (!argv)
        argv = require_minimist()(process.argv.slice(2));
      defaults = ("string" === typeof defaults ? cc.json(defaults) : defaults) || {};
      parse = parse || cc.parse;
      var env = cc.env(name + "_");
      var configs = [defaults];
      var configFiles = [];
      function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0)
          return;
        var fileConfig = cc.file(file);
        if (fileConfig) {
          configs.push(parse(fileConfig));
          configFiles.push(file);
        }
      }
      if (!win)
        [
          join(etc, name, "config"),
          join(etc, name + "rc")
        ].forEach(addConfigFile);
      if (home)
        [
          join(home, ".config", name, "config"),
          join(home, ".config", name),
          join(home, "." + name, "config"),
          join(home, "." + name + "rc")
        ].forEach(addConfigFile);
      addConfigFile(cc.find("." + name + "rc"));
      if (env.config)
        addConfigFile(env.config);
      if (argv.config)
        addConfigFile(argv.config);
      return deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
      ]));
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);
var import_coc2 = require("coc.nvim");

// src/engine.ts
var import_coc = require("coc.nvim");
var import_deep_extend = __toESM(require_deep_extend());
var import_fs = __toESM(require("fs"));

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// src/engine.ts
var import_markdownlint = __toESM(require_markdownlint());
var import_markdownlint_rule_helpers = __toESM(require_helpers3());
var import_path = __toESM(require("path"));
var import_rc = __toESM(require_rc());
var projectConfigFiles = [".markdownlint.json", ".markdownlint.yaml", ".markdownlint.yml"];
var configFileParsers = [JSON.parse, js_yaml_default.load];
var MarkdownlintEngine = class {
  constructor() {
    this.fixAllCommandName = "markdownlint.fixAll";
    this.source = "markdownlint";
    this.outputChannel = import_coc.window.createOutputChannel(this.source);
    this.diagnosticCollection = import_coc.languages.createDiagnosticCollection(this.source);
    this.config = {};
  }
  outputLine(message) {
    if (this.outputChannel) {
      this.outputChannel.appendLine(`[${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
    }
  }
  async parseConfig() {
    try {
      this.config = (0, import_rc.default)(this.source, {});
      this.outputLine(`Info: global config: ${JSON.stringify((0, import_rc.default)(this.source, {}))}`);
    } catch (e) {
      this.outputLine(`Error: global config parse failed: ${e}`);
    }
    try {
      for (const projectConfigFile of projectConfigFiles) {
        const fullPath = import_path.default.join(import_coc.workspace.root, projectConfigFile);
        if (import_fs.default.existsSync(fullPath)) {
          const projectConfig = (0, import_markdownlint.readConfigSync)(fullPath, configFileParsers);
          this.config = (0, import_deep_extend.default)(this.config, projectConfig);
          this.outputLine(`Info: local config: ${fullPath}, ${JSON.stringify(projectConfig)}`);
          break;
        }
      }
    } catch (e) {
      this.outputLine(`Error: local config parse failed: ${e}`);
    }
    const cocConfig = import_coc.workspace.getConfiguration("markdownlint").get("config");
    if (cocConfig) {
      this.config = (0, import_deep_extend.default)(this.config, cocConfig);
      this.outputLine(`Info: config from coc-settings.json: ${JSON.stringify(cocConfig)}`);
    }
    this.outputLine(`Info: full config: ${JSON.stringify(this.config)}`);
  }
  markdownlintWrapper(document) {
    const options = {
      resultVersion: 3,
      config: this.config,
      // customRules: customRules,
      strings: {
        [document.uri]: document.getText()
      }
    };
    let results = [];
    try {
      results = (0, import_markdownlint.sync)(options)[document.uri];
    } catch (e) {
      this.outputLine(`Error: lint exception: ${e}`);
    }
    return results || [];
  }
  async provideCodeActions(document, range, context) {
    const doc = import_coc.workspace.getDocument(document.uri);
    const wholeRange = import_coc.Range.create(0, 0, doc.lineCount, 0);
    let whole = false;
    if (range.start.line === wholeRange.start.line && range.start.character === wholeRange.start.character && range.end.line === wholeRange.end.line && range.end.character === wholeRange.end.character) {
      whole = true;
    }
    const codeActions = [];
    const fixInfoDiagnostics = [];
    for (const diagnostic of context.diagnostics) {
      if (diagnostic.fixInfo) {
        const lineNumber = diagnostic.fixInfo.lineNumber - 1 || diagnostic.range.start.line;
        const line = await import_coc.workspace.getLine(document.uri, lineNumber);
        const newText = (0, import_markdownlint_rule_helpers.applyFix)(line, diagnostic.fixInfo, "\n");
        const edit = { changes: {} };
        if (typeof newText === "string") {
          const range2 = import_coc.Range.create(lineNumber, 0, lineNumber, line.length);
          edit.changes[document.uri] = [import_coc.TextEdit.replace(range2, newText)];
        } else {
          edit.changes[document.uri] = [import_coc.TextEdit.del(diagnostic.range)];
        }
        const title = `Fix: ${diagnostic.message.split(":")[0]}`;
        const action = {
          title,
          edit,
          diagnostics: [...context.diagnostics]
        };
        fixInfoDiagnostics.push(diagnostic);
        if (!whole) {
          codeActions.push(action);
        }
      }
    }
    if (range.start.line === range.end.line && range.start.character === 0) {
      const edit = import_coc.TextEdit.insert(import_coc.Position.create(range.start.line, 0), "<!-- markdownlint-disable-next-line -->\n");
      codeActions.push({
        title: "Disable markdownlint for current line",
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (whole) {
      const edit = import_coc.TextEdit.insert(import_coc.Position.create(0, 0), "<!-- markdownlint-disable-file -->\n");
      codeActions.push({
        title: "Disable markdownlint for current file",
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (fixInfoDiagnostics.length) {
      const title = "Fix All error found by markdownlint";
      const sourceFixAllAction = {
        title,
        kind: import_coc.CodeActionKind.SourceFixAll,
        diagnostics: fixInfoDiagnostics,
        command: {
          title,
          command: this.fixAllCommandName
        }
      };
      codeActions.push(sourceFixAllAction);
    }
    return codeActions;
  }
  lint(document) {
    if (document.languageId !== "markdown") {
      return;
    }
    this.diagnosticCollection.set(document.uri);
    const results = this.markdownlintWrapper(document);
    if (!results.length) {
      return;
    }
    const diagnostics = [];
    results.forEach((result) => {
      const ruleDescription = result.ruleDescription;
      let message = result.ruleNames.join("/") + ": " + ruleDescription;
      if (result.errorDetail) {
        message += " [" + result.errorDetail + "]";
      }
      const start = import_coc.Position.create(result.lineNumber - 1, 0);
      const end = import_coc.Position.create(result.lineNumber - 1, 0);
      if (result.errorRange) {
        start.character = result.errorRange[0] - 1;
        end.character = start.character + result.errorRange[1];
      }
      const range = import_coc.Range.create(start, end);
      const diagnostic = import_coc.Diagnostic.create(range, message);
      diagnostic.severity = import_coc.DiagnosticSeverity.Warning;
      diagnostic.source = this.source;
      diagnostic.fixInfo = result.fixInfo;
      diagnostics.push(diagnostic);
    });
    this.diagnosticCollection.set(document.uri, diagnostics);
  }
  async fixAll(document) {
    const results = this.markdownlintWrapper(document);
    if (!results.length) {
      return;
    }
    const text = document.getText();
    const fixedText = (0, import_markdownlint_rule_helpers.applyFixes)(text, results);
    if (text != fixedText) {
      const doc = import_coc.workspace.getDocument(document.uri);
      const end = import_coc.Position.create(doc.lineCount - 1, doc.getline(doc.lineCount - 1).length);
      const edit = {
        changes: {
          [document.uri]: [import_coc.TextEdit.replace(import_coc.Range.create(import_coc.Position.create(0, 0), end), fixedText)]
        }
      };
      await import_coc.workspace.applyEdit(edit);
    }
  }
};

// src/index.ts
var documentSelector = [
  {
    language: "markdown",
    scheme: "file"
  },
  {
    language: "markdown",
    scheme: "untitled"
  }
];
var documentVersion = 0;
var engine = new MarkdownlintEngine();
var config = import_coc2.workspace.getConfiguration("markdownlint");
function didOpenTextDocument(document) {
  if (config.get("onOpen", true)) {
    engine.lint(document);
  }
}
async function didChangeTextDocument(params) {
  if (!config.get("onChange", true)) {
    return;
  }
  if (params.textDocument.version && documentVersion !== params.textDocument.version) {
    documentVersion = params.textDocument.version;
    const { document } = await import_coc2.workspace.getCurrentState();
    engine.lint(document);
  }
}
async function didSaveTextDocument(document) {
  if (config.get("onSave", true)) {
    engine.lint(document);
  }
}
async function activate(context) {
  await engine.parseConfig();
  context.subscriptions.push(
    import_coc2.languages.registerCodeActionProvider(documentSelector, engine, "markdownlint"),
    import_coc2.commands.registerCommand(engine.fixAllCommandName, async () => {
      const { document } = await import_coc2.workspace.getCurrentState();
      engine.fixAll(document);
    }),
    import_coc2.workspace.onDidOpenTextDocument(didOpenTextDocument),
    import_coc2.workspace.onDidChangeTextDocument(didChangeTextDocument),
    import_coc2.workspace.onDidSaveTextDocument(didSaveTextDocument)
  );
  import_coc2.workspace.documents.map((doc) => {
    didOpenTextDocument(doc.textDocument);
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
/*! Bundled license information:

deep-extend/lib/deep-extend.js:
  (*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
