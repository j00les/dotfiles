"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = create;
const vue = require("@vue/language-core");
const volar_service_html_1 = require("volar-service-html");
const html = require("vscode-html-languageservice");
const data_1 = require("./data");
const vscode_uri_1 = require("vscode-uri");
let sfcDataProvider;
function create() {
    const htmlPlugin = (0, volar_service_html_1.create)({
        documentSelector: ['vue'],
        useDefaultDataProvider: false,
        getCustomData(context) {
            sfcDataProvider ??= html.newHTMLDataProvider('vue', (0, data_1.loadLanguageBlocks)(context.env.locale ?? 'en'));
            return [sfcDataProvider];
        },
        async getFormattingOptions(document, options, context) {
            return await worker(document, context, async (vueCode) => {
                const formatSettings = await context.env.getConfiguration?.('html.format') ?? {};
                const blockTypes = ['template', 'script', 'style'];
                for (const customBlock of vueCode.sfc.customBlocks) {
                    blockTypes.push(customBlock.type);
                }
                return {
                    ...options,
                    ...formatSettings,
                    wrapAttributes: await context.env.getConfiguration?.('vue.format.wrapAttributes') ?? 'auto',
                    unformatted: '',
                    contentUnformatted: blockTypes.join(','),
                    endWithNewline: options.insertFinalNewline ? true
                        : options.trimFinalNewlines ? false
                            : document.getText().endsWith('\n'),
                };
            }) ?? {};
        },
    });
    return {
        ...htmlPlugin,
        name: 'vue-sfc',
        create(context) {
            const htmlPluginInstance = htmlPlugin.create(context);
            return {
                ...htmlPluginInstance,
                provide: {
                    'vue/vueFile': document => {
                        return worker(document, context, vueFile => {
                            return vueFile;
                        });
                    },
                },
                provideDocumentLinks: undefined,
                async resolveEmbeddedCodeFormattingOptions(sourceScript, virtualCode, options) {
                    if (sourceScript.generated?.root instanceof vue.VueVirtualCode) {
                        if (virtualCode.id === 'script_raw' || virtualCode.id === 'scriptsetup_raw') {
                            if (await context.env.getConfiguration?.('vue.format.script.initialIndent') ?? false) {
                                options.initialIndentLevel++;
                            }
                        }
                        else if (virtualCode.id.startsWith('style_')) {
                            if (await context.env.getConfiguration?.('vue.format.style.initialIndent') ?? false) {
                                options.initialIndentLevel++;
                            }
                        }
                        else if (virtualCode.id === 'template') {
                            if (await context.env.getConfiguration?.('vue.format.template.initialIndent') ?? true) {
                                options.initialIndentLevel++;
                            }
                        }
                    }
                    return options;
                },
                provideDocumentSymbols(document) {
                    return worker(document, context, vueSourceFile => {
                        const result = [];
                        const descriptor = vueSourceFile.sfc;
                        if (descriptor.template) {
                            result.push({
                                name: 'template',
                                kind: 2,
                                range: {
                                    start: document.positionAt(descriptor.template.start),
                                    end: document.positionAt(descriptor.template.end),
                                },
                                selectionRange: {
                                    start: document.positionAt(descriptor.template.start),
                                    end: document.positionAt(descriptor.template.startTagEnd),
                                },
                            });
                        }
                        if (descriptor.script) {
                            result.push({
                                name: 'script',
                                kind: 2,
                                range: {
                                    start: document.positionAt(descriptor.script.start),
                                    end: document.positionAt(descriptor.script.end),
                                },
                                selectionRange: {
                                    start: document.positionAt(descriptor.script.start),
                                    end: document.positionAt(descriptor.script.startTagEnd),
                                },
                            });
                        }
                        if (descriptor.scriptSetup) {
                            result.push({
                                name: 'script setup',
                                kind: 2,
                                range: {
                                    start: document.positionAt(descriptor.scriptSetup.start),
                                    end: document.positionAt(descriptor.scriptSetup.end),
                                },
                                selectionRange: {
                                    start: document.positionAt(descriptor.scriptSetup.start),
                                    end: document.positionAt(descriptor.scriptSetup.startTagEnd),
                                },
                            });
                        }
                        for (const style of descriptor.styles) {
                            let name = 'style';
                            if (style.scoped) {
                                name += ' scoped';
                            }
                            if (style.module) {
                                name += ' module';
                            }
                            result.push({
                                name,
                                kind: 2,
                                range: {
                                    start: document.positionAt(style.start),
                                    end: document.positionAt(style.end),
                                },
                                selectionRange: {
                                    start: document.positionAt(style.start),
                                    end: document.positionAt(style.startTagEnd),
                                },
                            });
                        }
                        for (const customBlock of descriptor.customBlocks) {
                            result.push({
                                name: `${customBlock.type}`,
                                kind: 2,
                                range: {
                                    start: document.positionAt(customBlock.start),
                                    end: document.positionAt(customBlock.end),
                                },
                                selectionRange: {
                                    start: document.positionAt(customBlock.start),
                                    end: document.positionAt(customBlock.startTagEnd),
                                },
                            });
                        }
                        return result;
                    });
                },
                async provideCompletionItems(document, position, context, token) {
                    const result = await htmlPluginInstance.provideCompletionItems?.(document, position, context, token);
                    if (!result) {
                        return;
                    }
                    result.items = result.items.filter(item => item.label !== '!DOCTYPE' && item.label !== 'Custom Blocks');
                    for (const scriptItem of result.items.filter(item => item.label === 'script' || item.label === 'script setup')) {
                        scriptItem.kind = 17;
                        scriptItem.detail = '.js';
                        for (const lang of ['ts', 'tsx', 'jsx']) {
                            result.items.push({
                                ...scriptItem,
                                detail: `.${lang}`,
                                kind: 17,
                                label: scriptItem.label + ' lang="' + lang + '"',
                                textEdit: scriptItem.textEdit ? {
                                    ...scriptItem.textEdit,
                                    newText: scriptItem.textEdit.newText + ' lang="' + lang + '"',
                                } : undefined,
                            });
                        }
                    }
                    const styleItem = result.items.find(item => item.label === 'style');
                    if (styleItem) {
                        styleItem.kind = 17;
                        styleItem.detail = '.css';
                        for (const lang of ['css', 'scss', 'less', 'postcss']) {
                            result.items.push({
                                ...styleItem,
                                kind: 17,
                                detail: lang === 'postcss' ? '.css' : `.${lang}`,
                                label: styleItem.label + ' lang="' + lang + '"',
                                textEdit: styleItem.textEdit ? {
                                    ...styleItem.textEdit,
                                    newText: styleItem.textEdit.newText + ' lang="' + lang + '"',
                                } : undefined,
                            });
                        }
                    }
                    const templateItem = result.items.find(item => item.label === 'template');
                    if (templateItem) {
                        templateItem.kind = 17;
                        templateItem.detail = '.html';
                        result.items.push({
                            ...templateItem,
                            kind: 17,
                            detail: '.pug',
                            label: templateItem.label + ' lang="pug"',
                            textEdit: templateItem.textEdit ? {
                                ...templateItem.textEdit,
                                newText: templateItem.textEdit.newText + ' lang="pug"',
                            } : undefined,
                        });
                    }
                    return result;
                },
            };
        },
    };
    function worker(document, context, callback) {
        const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(document.uri));
        const sourceScript = decoded && context.language.scripts.get(decoded[0]);
        const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
        if (virtualCode instanceof vue.VueVirtualCode) {
            return callback(virtualCode);
        }
    }
}
//# sourceMappingURL=vue-sfc.js.map